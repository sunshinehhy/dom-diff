## 数组解构
- 如果解构不成功，变量的值就等于undefined。
```
let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []

let [foo] = [];
let [bar, foo] = [1];
foo的值都会等于undefined。
```


- 不完全解构:
```
let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
```
- 如果等号的右边不是数组,会报错
```
// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
报错的原因是因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式）
要么本身就不具备 Iterator 接口（最后一个表达式）
```
- 只要某种`数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。`
```
Set 结构，也可以使用数组的解构赋值。
let [x, y, z] = new Set(['a', 'b', 'c']);
x // "a"
```

```
function* fibs() {
  let a = 0;
  let b = 1;
  while (true) {
    yield a;
    console.log(a);
    [a, b] = [b, a + b];
  }
}

let [first, second, third, fourth, fifth, sixth] = fibs();
sixth // 5

fibs是一个 Generator 函数，原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。
```
- 解构赋值允许指定默认值。只有当一个数组成员严格等于undefined，默认值才会生效。
- 默认值可以是表达式，并且是惰性求值
- 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
```
let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null

null不严格等于undefined
```

```
let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = [];     // ReferenceError: y is not defined
//y没有声明
```
```
const iterable = ['a', 'b'];
const [x, y] = iterable;
  // x = 'a'; y = 'b'
```