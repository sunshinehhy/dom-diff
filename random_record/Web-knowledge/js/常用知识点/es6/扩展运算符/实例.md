https://blog.csdn.net/qq_30100043/article/details/53391308  （关于扩展运算符的各种实例）

## 对象转为真正数组的方法
1. 扩展运算符  ----  字符串、数组、对象
2. Array.from

- `任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。`

```
var nodeList = document.querySelectorAll('div');  
var array = [...nodeList];  
上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 接口。
```
- 对于那些`没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组`。可以改为使用Array.from

```
let arrayLike = {  
'0': 'a',  
'1': 'b',  
'2': 'c',  
length: 3  
};  
// TypeError: Cannot spread non-iterable object.  
let arr = [...arrayLike];  
上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。
```
- Map 和 Set 结构， Generator 函数具有 Iterator 接口的对象，因此都可以使用扩展运算符
```
let map = new Map([  
[1, 'one'],  
[2, 'two'],  
[3, 'three'],  
]);  
let arr = [...map.keys()]; // [1, 2, 3]  
```
```
var go = function*(){  
yield 1;  
yield 2;  
yield 3;  
};  
[...go()] // [1, 2, 3]  
```

- 扩展运算符将字符串转为真正的数组。
```
[...'hello']  
// [ "h", "e", "l", "l", "o" ]  
```

## 识别 32 位的 Unicode 字符
- 能够正确识别 32 位的 Unicode 字符。`凡是涉及到操作 32 位 Unicode 字符的函数，都有js会将其识别为2个字符这个问题。因此，最好都用扩展运算符改写`。
```
'x\uD83D\uDE80y'.length // 4  
[...'x\uD83D\uDE80y'].length // 3
上面代码的第一种写法， JavaScript 会将 32 位 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数 
```
```
let str = 'x\uD83D\uDE80y';  
str.split('').reverse().join('')  
// 'y\uDE80\uD83Dx'  
[...str].reverse().join('')  
// 'y\uD83D\uDE80x' 
```