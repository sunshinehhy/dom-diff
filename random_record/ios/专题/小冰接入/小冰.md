图片是异步加载
UIView.transition

## 签名
```
每一个Partner会对应一个或多个认证Token
每个Token，包含一个appkey，一个primarySecret，一个secondarySecret。
一般只需要用primarySecret, secondarySecret只是backup。appkey会附在request中，secret partner留存，仅用于签名生成。
签名生成
GET
将get方法中的参数(除signature以外)按字母序排列，在最前面加上secret，
然后HMAC-SHA1生成签名，HMAC-SHA1的key采用小冰给的app secret。转成two uppercase hexadecimal characters(C#中ToString("X2"))
 
POST
将post json body中的参数构建成一个有序(按json key排序)的字典，在最前面加上secret
然后HMAC-SHA1生成签名，HMAC-SHA1的key采用小冰给的app secret。转成 two uppercase hexadecimal characters (C#中 ToString("X2"))
Request
{
    "appKey": "I7Ka2XhqY0V4r7m18xj3HzerUf44GlDyuAvLNqRT",
    "sign":"15D742E4CC2536244EBE2EFB9BADA3DAd",
    "appId":"wx83f20f753ed225bf",
    "startTime": "2017-01-01",
    "endTime": "2017-03-30",
    "paging": { "index": 1, "pageLength": 20, "offset": 0}
}
 
生成如下的字符串(XXXXX表示secret)
xxxxxappIdwx83f20f753ed225bfappKeyI7Ka2XhqY0V4r7m18xj3HzerUf44GlDyuAvLNqRTendTime2017-03-30paging{\"index\":1,\"pageLength\":20,\"offset\":0}startTime2017-01-01
  
认证
分两层
用户认证
如果appkey没有注册，则是伪造用户
签名认证
appkey有效，但是签名无效
任何一种情况，系统都认为是无效请求，予以拒绝
```

通过HMAC-SHA生成签名

CCHmacAlgorithm算法
```
extension String {
    /// HmacSHA1 Encrypt
    ///
    /// -Parameter key: secret key
    ///
    func HmacSHA1Base64(key: String) -> String {
        let cKey = key.cString(using: String.Encoding.utf8)
        let cData = self.cString(using: String.Encoding.utf8)
        var result = [CUnsignedChar](repeating: 0, count: Int(CC_SHA1_DIGEST_LENGTH))
        
        if let realCKey = cKey, let realCData = cData {
            CCHmac(CCHmacAlgorithm(kCCHmacAlgSHA1), realCKey, Int(strlen(realCKey)), realCData, Int(strlen(realCData)), &result)
            let hmacData:NSData = NSData(bytes: result, length: (Int(CC_SHA1_DIGEST_LENGTH)))
            let hmacBase64 = hmacData.base64EncodedString(options: NSData.Base64EncodingOptions.lineLength76Characters)
            print("Sign not base64:\(String(describing: hmacData))")
            return String(hmacBase64)
        } else {
            return ""
        }
    }
    func HmacSHA1X2(key: String) -> String {
        let cKey = key.cString(using: String.Encoding.utf8)
        let cData = self.cString(using: String.Encoding.utf8)
        var result = [UInt8](repeating:0, count:Int(CC_SHA1_DIGEST_LENGTH))

        if  let realCKey = cKey, let realCData = cData{
            CCHmac(CCHmacAlgorithm(kCCHmacAlgSHA1), realCKey, Int(strlen(realCKey)), realCData, Int(strlen(realCData)), &result)
            let hexBytes = result.map {
                String(format:"%02hhX", $0)
            }
            return hexBytes.joined()
        } else {
            return ""
        }
        
    }
}

```

appkey怎么生成的？
appkey怎么验证是否有效？

````
"sessionID": "xxxxxxx",                        // session ID，用户多次时间相近的
                                    // impression共同组成一个session，
                                    // Partner反馈行为信息回写
"impressionID": "xxxxxxx",                 // 标识本次返回的推荐列表, Partner反馈                   
                            // 行为信息时需要回写
```