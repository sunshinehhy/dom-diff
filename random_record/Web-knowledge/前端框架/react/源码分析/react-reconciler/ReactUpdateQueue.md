UpdateQueue是一个列出优先级更新的链接列表。
与纤程一样，更新队列是成对出现的:当前队列(表示屏幕的可见状态)和正在进行的工作队列(可以在提交之前进行异步突变和处理)——一种双缓冲形式。如果正在处理的工作呈现在完成之前被丢弃，我们通过克隆当前队列来创建正在处理的新工作。两个队列共享一个持久的、单链接的列表结构。为了调度更新，我们将它附加到两个队列的末尾。每个队列在未处理的持久列表中维护一个指向第一次更新的指针。正在工作指针的位置总是等于或大于当前队列，因为我们总是对该队列进行处理。只有在提交阶段更新当前队列的指针，即在正在进行的工作中进行交换时。

我们将两个队列都追加的原因是，否则我们可能会删除更新，而不会对它们进行处理。例如，如果我们只向正在进行中的工作队列添加更新，那么当工作正在进行的渲染通过从当前克隆重新启动时，就会丢失一些更新。类似地，如果我们只向当前队列添加更新，那么当已经在进行中的队列提交并与当前队列交换时，更新就会丢失。但是，通过添加到两个队列，我们保证更新将成为下一个正在进行的工作的一部分。(而且，由于正在进行的工作队列一旦提交后就成为当前队列，因此不存在两次应用相同更新的危险。)

优先级
/ / - - - - - - - - - - - - - - -
`更新不是按优先级排序，而是按插入排序;新的更新总是附加在列表的末尾`。不过，优先级仍然很重要。在呈现阶段处理更新队列时，结果中只包含具有足够优先级的更新。如果因为没有足够的优先级而跳过更新，那么在较低的优先级呈现期间，更新仍然在队列中待稍后处理。至关重要的是，在跳过的更新之后的所有更新都保留在队列中*，而不考虑它们的优先级*。这意味着高优先级更新有时会在两个不同的优先级上处理两次。我们还跟踪一个基状态，它表示应用队列中的第一个更新之前的状态。

因为我们按照插入顺序处理更新，并`在跳过前面的更新时,重新设置高优先级更新`，所以无论优先级如何，最终结果都是确定的。根据系统资源的不同，中间状态可能不同，但是最终状态总是相同的。