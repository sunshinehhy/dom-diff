
##javascript中apply、call和bind的区别

在JS中，这三者都是用来`改变函数的this对象的指向的`他们有什么样的区别呢。
在说区别之前还是先总结一下三者的相似之处：
1、都是用来改变函数的this对象的指向的。
2、第一个参数都是this要指向的对象。
3、都可以利用后续参数传参。
call和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以。

## switch

switch语句中可以使用任何数据类型；case的值不一定是常量，可以是变量，甚至是表达式。
switch语句在比较事使用的是全等操作符。

## auguments

没有传递值得命名参数将自动被赋予undefined值。
`应用场景`:当调用一个函数时候，这个函数的参数数量比它显示声明的参数数量多的时候。
例如：
1 检查参数的个数 
2 模拟函数重载

严格模式
1 function.caller,function.arguments 报错
2 arguments.callee 报错
3 arguments 不再追踪参数的变化

1.箭头函数有作用域（词法作用域），词法作用域简单来讲就是，一切变量（包括this）都根据作用域链来查找。

2.箭头函数中的this因为绑定了词法作用域，所以始终指向自身外的第一个this（由于自身没有声明this，所以会去作用域链上找this），也就是始终等于调用它的函数的this（以为这个this离它最近）。

3.严格模式下不允许使用arguments（规定），并且，普通函数里 arguments 代表了调用时传入的参数，但是箭头函数不是，箭头函数会把 arguments 当成一个普通的变量，顺着作用域链由内而外地查询（词法作用域）

4.arguments可以用...rest取代，所以完全没必要追求argument。

##  数组的结构赋值

如果解构不成功，变量的值就等于undefined。
如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。

```
// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```

事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。所以Set也行。

注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。

对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；
而`对象的属性没有次序，变量必须与属性同名，才能取到正确的值。`

对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。

let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError

## JavaScript判断变量是否为数组的方法(Array)

http://www.jb51.net/article/79939.htm

var ary = [1,23,4];
console.log(typeof ary); //输出结果是Object
不能实时的检测出是否是数组，只能判断其类型，所以说typeof判断基本类型数据还是挺好的，但是不能准确测试出是否是数组。

var ary = [1,23,4];
console.log(ary.__proto__.constructor==Array);//true
console.log(ary.constructor==Array)//true 这两段代码是一样的

instanceof 和constructor `判断的变量，必须在当前页面声明的`，比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个ary，并将其赋值给父页面的一个变量，这时判断该变量，Array == object.constructor;会返回false；

原因：

1、array属于引用型数据，在传递过程中，仅仅是引用地址的传递。

2、每个页面的Array原生对象所引用的地址是不一样的，在子页面声明的array，所对应的构造函数，是子页面的Array对象；父页面来进行判断，使用的Array并不等于子页面的Array；切记，不然很难跟踪问题！

`通用的方法:`
var ary = [1,23,4];
function isArray(o){
  return Object.prototype.toString.call(o)=='[object Array]';
}
console.log(isArray(ary))

想要判断某个对象值属于哪种内置类型,最靠谱的做法就是通过Object.prototype.toString方法.





## setTimeout
```
var t1 = new Date().getTime();
var time1 = setTimeout(function() {
    clearTimeout(time1);
    console.log(new Date().getTime()-t1);   //得出大于500 
}, 500);  
```

## for循环的阻塞机制
Js阻塞机制，跟Js引擎的单线程处理方式有关，每个window一个JS线程。所谓`单线程，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码`。
```
for(var i=0;i<3;i++){
    setTimeout(function(){
        console.log(i);
    }, (i+1)*1000); 
}
```
对于for循环，记住，是在不满足条件的情况下停止循环，对于以上代码，可以看出，i=3的时候才不满足。

```
for(var i=0;i<3;i++){
    (function(i){
        setTimeout(function(){
            console.log(i);
        }, (i+1)*1000);
    })(i)
}
```
加一个立即执行的匿名函数，并且将for循环的i作为实参传入进去。这样，setTimeout就会被立即执行，而不会等待。

http://ju.outofmemory.cn/entry/161495  （解释for循环得出相同结果机制，后面用闭包解决）


## 数组无法直接进行相等比较
[1,2,3] === [1,2,3];//false
[1,2,3] == [1,2,3];//false

## 判断字符串为空
```
if (a.replace(/(^\s*)|(\s*$)/g,'').length == 0 ) {
  console.log('空字符串')
}
```
