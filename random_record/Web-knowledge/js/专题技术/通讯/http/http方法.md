http协议:http://www.cnblogs.com/imyalost/p/7223493.html

安全版本HTTPS就是在HTTP和TCP之间插入一个（TLS或SSL）密码加密层。

## http方法
https://www.jianshu.com/p/1a49a7b08ee0

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS

- GET	    请求指定的页面信息，并`返回实体主体`。
- HEAD	    类似get请求，只不过`返回的响应中没有具体的内容，用于获取报头`(只请求页面的首部)。
- POST	    向`指定资源提交数据`进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。 POST请求`可能会导致新的资源的建立和/或已有资源的修改`。
- PUT	    从客户端向服务器传送的数据`取代指定的文档的内容`。
- DELETE	请求服务器`删除指定的页面`。
- CONNECT	HTTP/1.1协议中预留给能够`将连接改为管道方式的代理服务器`。
- OPTIONS	`允许客户端查看服务器的性能`。它用于获取当前URL所支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息。
- TRACE	    回显服务器收到的请求，`主要用于测试或诊断`。

方法中的4种可以和数据库的CRUD操作对应起来：
```
Create: PUT  
Read: GET  
Update: POST  
Delete: DELETE  
```
### put方法

**POST和PUT的区别**

都是想服务器提交数据

POST方法和PUT方法请求`最根本的区别是请求URI的含义不同`。

1. 

POST是用来提交数据的。`提交的数据放在HTTP请求的正文里`，目的在于`提交数据并用于服务器端的存储`，而不允许用户过多的更改相应数据（主要是相对于在url修改要麻烦很多)。

PUT操作是幂等的。所谓幂等是指`不管进行多少次操作，结果都一样`。比如我用PUT修改一篇文章，然后在做同样的操作，每次操作后的结果并没有不同。

2. 
POST操作`既不是安全的，也不是幂等的`，比如常见的POST重复加载问题：当我们多次发出同样的POST请求后，其结果是创建出了若干的资源。

安全和幂等的意义在于：当操作没有达到预期的目标时，我们可以不停的重试，而不会对资源产生副作用。从这个意义上说，POST操作往往是有害的，但很多时候我们还是不得不使用它。

3. 
创建操作可以使用POST，也可以使用PUT，区别在于`POST 是作用在一个集合资源之上`的（/articles），而`PUT操作是作用在一个具体资源之上`的（/articles/123），再通俗点说，`如果URL可以在客户端确定，那么就使用PUT，如果是在服务端确定，那么就使用POST`，比如说很多资源使用数据库自增主键作为标识信息，而创建的资源的标识信息到底是什么只能由服务端提供，这个时候就必须使用POST。

4. 
POST：它请求里的URI 指示一个`能处理请求实体的资源`（译注：此资源可能是一段程序，如jsp 里的servlet）;此资源可能是一个*数据接收过程*、*某种协议的网关*（gateway，译注：网关和代理的区别是：网关可以进行协议转换，而代理不能，只是起代理的作用，比如缓存服务器其实就是一个代理），或者一个*单独接收注释的实体*。

PUT：请求中的URI`标识请求里封装的实体`一一用户代理知道URI意指什么，并且`服务器不能把此请求应用于其它资源`（resource）。如果服务器期望`请求被应用于一个不同的URI`，那么它`必须发送301（永久移动）响应`；用户代理`可以自己决定是否重定向请求`。

5. 
`PUT指定了资源在服务器上的位置，而POST没有`。PUT方法请求服务器去把请求里的实体存储在请求;

6. 

POST方法被用于请求源服务器`接受请求中的实体`作为`请求资源`的一个`新的从属物`。(前端写的post内容是请求都得数据的新的从属物)

PUT方法请求服务器去把`请求里的实体存储在请求URI（Request-URI）标识下`。

### put特点
- HTTP/1.1没有定义一个PUT请求如何影响原始服务器的状态。 
- PUT请求`必须遵守信息传输要求`。 
- 除非另有说明，PUT请求中的`实体头部应该用于PUT创建或修改`的资源上。
- URI（Request-URI）标识下:
    + 如果请求URI（Request-URI）`指定的的资源已经在源服务器上存在`，那么此`请求里的实体`应该被当作是源服务器关于此`URI所指定资源实体的最新修改版本`。

    + 如果请求RI（Request-URI）指定的资源`不存在`，并且此URI被用户代理`定义为一个新资源`，那么源服务器就应该根据请求里的实体创建一个此URI所标识下的资源。

    + 如果一个`新的资源被创建了`，源服务器必须能向用户代理（user agent）`发送201（已创建）响应`。
    + 如果`已存在的资源被改变了`，那么源服务器应该发送`200（Ok）或者204（无内容）响应`。
    + 如果资源`不能根据请求URI创建或者改变`，一个合适的`错误响应应该给出以反应问题的性质`。实体的接收者不能忽略任何它不理解和不能实现的Content-*（如：Content-Range）头域，并且必须返回`501（没有被实现）响应。`
    + 如果请求穿过一个缓存（cache），并且此请求 URI（Request-URI）指示了一个或多个当前缓存的实体，那么这些实体应该被看作是旧的。PUT方法的响应是不可缓存的。POST方法和PUT方法请求最根本的区别是请求URI（Request-URI）的含义不同。


- 一个单独的资源`可能会被许多不同的URI指定`。如：一篇文章可能会有一个URI指定当前版本，而这个URI区别于这篇文章其它特殊版本的URI。这种情况下，对一个通用URI的PUT请求`可能会导致其资源的其它URI请求被源服务器重定义`。HTTP/1.1没有定义PUT方法对源服务器的状态影响。`PUT方法请求里的实体头域应该被用于资源的创建或修改。`


### connect方法

`connect是为了建立http tunnel`，connect是http众多方法中的其中一种，它跟post、get、put、options方法是并列的。但是它的使用场景很特殊。只有在受限制的网络环境中（防火墙、NAT、代理器）并且是https通信时，客户端使用http connect请求代理服务器，代理服务器使用connect方法与目标服务器建立http tunnel，通道建立后，客户端与服务器进行通信，代理服务器就像透明一样，只是接收、转发tcp stream。

为什么要建立http tunnel呢？ 
这是因为，网络环境受限，客户端无法直接访问某些网络，所以只能通过代理服务器访问网络，然后，将内容转发给客户端，从宏观上看，客户端与服务器端就像建立了一条隧道一样。 
但是由于http tunnnel可控性不强，所以，服务器通常会限制”可connect的端口”(一般只开放SSL的443端口)

connect：要求用隧道协议连接代理 
connect方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行tcp通信。主要使用SSL和TLS协议把通信内容加密后经网络隧道传输。


## HTTP连接处理

目前现存和常用的连接方法大概有一下四种：

http://www.cnblogs.com/imyalost/p/7887667.html

1、串行连接

最早的连接方式，即HTTP事务需要按顺序进行传输，等待服务端完成处理并回传。

2、并行连接

通过多条TCP连接发情并发的HTTP请求。

3、持久连接

重用TCP连接，以消除连接及关闭时延，持久连接+并行连接，可能是最高效的连接方式。

持久连接有两种方式，分别为HTTP/1.0+的“Keep-alive”连接，以及HTTP/1.1的“persistent”连接。

Keep-alive：该首部只是请求将连接保持在活跃状态，客户端和服务端可以随时关闭空闲的Keep-alive连接。

4、管道化连接

通过共享TCP连接发起并发的HTTP请求，这也是在持久连接的基础上对性能的一种优化。

原理：在响应到达前，将多条请求放入队列，在高延时网络条件下，可以降低网络环回时间，提高性能。

## http协议  代理

web代理服务器是网络的中间实体，位于客户端和服务器之间，扮演“中间人”的角色，作用是在各端点之间来回传送报文。

其原理是：客户端向代理服务器发送请求报文，代理服务器正确的处理请求和连接，然后返回响应；同时代理服务器自身要向web服务器发送请求并接收响应。

## 请求知识

- 物理层：通过媒介传输比特，确定机械及电器规范（比特bit）
- 数据链路层：将比特组装成帧和点到点的传递（帧frame）
- 网络层：负责数据包从源到宿的传递和网际互连（包packetT）
- 传输层：提供端到端的可靠报文传递和错误恢复（段segment）
- 会话层：建立、管理和终止会话（会话协议数据单元SPUD）
- 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
- 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）

## 各种协议：

- ICMP协议：因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。
- TFTP协议：是TCP/IP协议族的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。
- HTTP协议：超文本传输协议，是一个属于应用层的面向对象协议，由于间接、快速方式，适用于分布式超媒体信息系统。
- DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置手段。

- HTTP工作原理：
地址解析-封装HTTP请求数据包-封装成TCP包，建立TCP连接（TCP的三次握手）-客户机发送请求命令-服务器响应，返回数据-服务器关闭TCP连接

## DNS：

DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。

DNS协议运行在UDP协议之上，使用端口号53。在RFC文档中RFC 2181对DNS有规范说明，RFC 2136对DNS的动态更新进行说明，RFC 2308对DNS查询的反向缓存进行说明。

JavaScript是单线程的，使用setTimeout并不能保证在所有情况下加速onload事件。但大多数时候，它会。
这意味着我们可以使用setTimeout(fn, 0)模式来防止延迟onload事件，从而导致感知的负载/呈现时间减少。当然，这种技术只能用于不依赖的脚本。

我认为跟踪脚本就是一个很好的例子。其中大多数都是动态地将一个新的\<script\>元素插入DOM。正如您所知道的，每个DOM操作都有一定的性能损失。例如，默认的谷歌分析代码将在遇到代码片段时修改DOM，从而延迟onload事件。

HTML5规范允许的最小setTimeout超时值为4 ms。较小的值(如0)应夹在4毫秒内。您可以在这里测试哪些浏览器遵循规范。


    ```
    var scriptList = document.scripts;
    scriptList是一个HTMLCollection对象.你可以像使用数组一样通过索引来获取其中包含的<script>元素.
    
    ```
## eTag

https://baike.baidu.com/item/ETag/4419019?fr=aladdin

**ETag：** 是实体标签(Entity Tag)的缩写。ETag一般不以明文形式相应给客户端。

在资源的各个生命周期中，它都具有不同的值，用于标识出资源的状态。

当资源发生变更时，如果其头信息中一个或者多个发生变化，或者消息实体发生变化，那么ETag也随之发生变化。

ETag值的变更说明资源状态已经被修改。往往可以通过时间戳就可以便宜的得到ETag头信息。在服务端中如果发回给

消费者的相应从一开始起就由ETag控制，那么可以确保更细粒度的ETag升级完全由服务来进行控制。服务计算ETag值，

并在相应客户端请求时将它返回给客户端。

如果ETag没改变，则返回状态304然后不返回，这也和Last-Modified一样。测试Etag主要在断点下载时比较有用。

### **ETag与Last-Modified头信息用途上的区别：**

按照HTTP标准，Last-Modified只能精确到<font color='red'>秒级</font>。ETag的出现可以很好的解决这个问题。在用途上，ETag常与If-None-Match或者If-Match一起，由客户端通过HTTP头信息(包括ETag值)发送给服务端处理。

ETag使用如下：

Get /Order/36 Http1.1

If-Match:"22FAA065-2664-4197-9C5E-C92EA03D0A16"

或If-None-Match:"22FAA065-2664-4197-9C5E-C92EA03D0A16"

Last-Modified常与If-Modified-Since一起由客户端将Last-Modified值包括在HTTP头信息中发给服务端进行处理。

其使用如下：

If-Modified-Since:Sat,24 Dec 2011 11:55:36 GMT

老的HTTP标准里有个<font color='red'>Last-Modified+If-Modified-Since</font>表明URL对象是否改变。Etag也具有这种功能，因为对象改变也造成Etag改变，并且它的控制更加准确。Etag有两种用法 If-Match/If-None-Match，就是如果服务器的对象和客户端的对象ID（不）匹配才执行。这里的<font color='red'>If-Match/If-None- Match</font>都能一次提交多个Etag。**If-Match可以在Etag未改变时断线重传。If-None-Match可以刷新对象（在有新的Etag时返回）**。

### 如何区分相同URL不同对象，避免频繁刷新，减少CGI操作和网络传输：

eTag:有些URL是多语言的网页，相同的URL会返回不同的东东。还有不同的Session有不同的Cookie也就有不同的内容。这种情况下如果用Proxy，Proxy就无法区分导致串门，只能简单的取消cache功能。Etag解决了这个问题，因为它能区分相同URL不同的对象。

**用途举例**：Etag对于cache CGI页面很有用。特别是论坛，论坛有办法为每个帖子页面生成唯一的Etag，在帖子未改变时，查看话题属性比较Etag就能避免刷新帖子，减少CGI操作和网络传输。比如论坛中看帖就返回Etag，减少论坛负担。

**Etag在不同URL之间没有可比性，也就是不同URL相同Etag没有特别意义。**

If-None-Match 是一个条件式请求首部。
- **对于 GET 和 HEAD 请求方法来说**，当且仅当**服务器上没有<font color='red'>任何</font>资源**的 ETag 属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为200。
- **对于其他方法来说**，当且仅当**最终确认没有<font color='red'>已存在</font>的资源**的  ETag 属性值与这个首部中所列出的相匹配的时候，才会对请求进行相应的处理。

CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。

## 浏览器加载和渲染html的顺序

https://www.cnblogs.com/gyjWEB/p/4547177.html
https://www.cnblogs.com/sunrunzhi/p/5407725.html

## URL访问网站的整个过程

http://blog.csdn.net/sinat_29912455/article/details/51135508
http://blog.csdn.net/wdzxl198/article/details/11265475

- DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。
- 域名解析：通过主机名，最终得到该主机名对应的IP地址的过程。
- DNS运行在UDP协议上。
- UDP是用户数据报协议，是OSI（开放式系统互联）参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传输服务。
- 向DNS服务器发出DNS请求是获取域名对应的IP地址 。

若DNS缓存中没有相关数据，则浏览器先向NDS服务器发出DNS请求——> 获取域名对应IP地址 ——> 浏览器向本机DNS模块发出DNS请求 ——> 生成相关的DNS报文 ——> 将报文传递给**传输层**的UDP协议单元 ——> 将该数据封装成UDP数据包 ——> 传递给网络层的IP协议单元 ——> 将该数据封装成IP数据包（其中目的IP地址为DNS服务器的OP地址） ——> 封装好的IP数据包将传递给**数据链路层**的协议单元进行发送 ——> 发送时如果ARP缓存中没有相关数据，则发送ARP广播请求，等待ARP回应 ——> 得到ARP回应后，将IP地址与路由下一跳MAC地址对应的信息写入ARP缓存表 ——> 写入缓存后，以路由下一跳地址填充目的MAC地址 ，并以数据帧形式转发 ——> 这个转发过程可能会进行多次， 取决于DNS服务器的位置——> DNS请求被发送到DNS服务器的**数据链路层**协议单元 ——> 将协议单元解析收到的数据帧，将其内部所含有的IP数据包传递给**网络层**IP协议单元 ——> 解析收到的UDP数据包 ——> 将其内部所含有的DNS报文传递给该服务器上的DNS服务单元 ——> DNS服务单元收到DNS请求，将域名解析为对应的IP地址，产生DNS回应报文（所有应用层报文必须通过**传输层、网络层和数据链路层**，因此在下面的叙述中，我将简化这一过程的叙述，简化形式如下面的样子，其中单箭头为本机内部传递，双箭头为网络上的发送）——> 
DNS回应报文→UDP→IP→MAC→→请求域名解析的主机； ——> 请求域名解析的主机收到数据帧，该数据帧→IP→UDP→DNS→IE浏览器 ——> 将域名解析的结果以域名和IP地址对应的形式写入DNS缓存表。


