## 定义
`浅拷贝`：如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。源对象的任何变化，`都会反映到目标对象上面`。
`深拷贝`：开辟一块新的内存地址，将原对象的各个属性逐个复制进去。对拷贝对象和源对象各自的操作`互不影响`。

## 问题缘起

如果给一个变量赋值一个对象，那么新变量和原对象变量`将会是同一个引用，其中一方改变，另一方也会改变`。

该问题可以用浅拷贝来解决。但是浅拷贝只能解决对象的第一层的引用问题(或数组的第一维)，如果接下去的属性还是对象的话那么还是同一个引用。这就需要引入深拷贝。

浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会修改原对象。

## 对象的深浅拷贝
### 1. 浅拷贝: Object.assign({},sourceObj) 或 {...sourceObj}
Object.assign()方法用于将所有自身的且可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。

当sourceObj的属性是值的时候，效果和深拷贝看起来一样；但是如果sourceObj的属性是另外一个对象时，就是浅拷贝了。

#### (1)使用Object.assign()实现浅拷贝

```js
let a = {
  age:1
}
let b = Object.assign({}, a);
a.age = 2;
console.log(b.age);//1
```
疑问：这里a的改变没有改变到b，是浅拷贝吗？看下面一步步分析
```
//这是深拷贝吧？其实Object.assign是浅拷贝，因为仅仅解决一层的深度拷贝，具体再看下面
var obj1 = { a: 10, b: 20, c: 30 };
var obj2 = Object.assign({}, obj1);;
obj2.b = 100;
console.log(obj1);  //{a: 10, b: 20, c: 30}    <-- b 沒被改到
console.log(obj2);  //{a: 10, b: 100, c: 30}

//浅拷贝
var obj1 = { a: 10, b: 20, c: 30 };
var obj2 = obj1;
obj2.b = 100;
console.log(obj1);
// { a: 10, b: 100, c: 30 } <-- b 被改到了
console.log(obj2);
// { a: 10, b: 100, c: 30 }
```
#### (2)使用{...obj}实现浅拷贝

```js
let a = {
  age: 1
}
let b = {...a};
a.age = 2;
console.log(b.age);//1
```

### 2. 深拷贝：JSON.parse(JSON.stringify(sourceObj)) 或loadash库的deepClone()方法
上面已经说过，浅拷贝只能解决第一层的引用问题，如果属性还是一个对象,那么还是会共享一个引用:

```js
let a = {
  age: 1,
  jobs: {
    main:'frontend'
  }
}

let b = {...a};
a.jobs.main = 'backend';
console.log(b.jobs.main);//'backend'

```

该问题通常可以用JSON.parse(JSON.stringify(sourceObj))或lodash的cloneDeep(Obj)方法来解决

#### (1)使用JSON.parse(JSON.stringify(sourceObj))实现深拷贝

```js
let a = {
  age: 1,
  jobs: {
    main:'frontend'
  }
}
let b = JSON.parse(JSON.stringify(a));
a.jobs.main = 'backend';
console.log(b.jobs.main);//'frontend'

```

```
var obj1 = { body: { a: 10 } };
var obj2 = JSON.parse(JSON.stringify(obj1));
obj2.body.a = 20;
console.log(obj1);
// { body: { a: 10 } } <-- 沒被改到
console.log(obj2);
// { body: { a: 20 } }
console.log(obj1 === obj2);
// false
console.log(obj1.body === obj2.body);
// false
```
这样做是真正的Deep Copy，这种方法简单易用。

但是这种方法也有不少坏处，譬如`它会抛弃对象的constructor`。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。

这种方法`能正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构`。RegExp对象是无法通过这种方式深拷贝。

也就是说，只有可以转成JSON格式的对象才可以这样用，像function没办法转成JSON。
```
var obj1 = { fun: function(){ console.log(123) } };
var obj2 = JSON.parse(JSON.stringify(obj1));
console.log(typeof obj1.fun);
// 'function'
console.log(typeof obj2.fun);
// 'undefined' <-- 没复制
```
要复制的function会直接消失，所以这个方法`只能用在单纯只有数据的对象`。

JSON.parse(JSON.stringify(sourceObj))实现深拷贝的局限:
- 会忽略undefined
- 不能处理函数，会忽略掉函数
- 不能处理循环引用的对象，会报错TypeError

#### (2)使用loadash的deepClone()方法
如果数据中出现了以上3中情况，那么可以考虑使用loadash的深拷贝函数。
```
var _ = require('lodash');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f);
// false
```

#### (3) 手动实现深拷贝
```js
function deepClone(obj) {
  const result = Object.assign({},obj);
  for(consts prop in obj) {
    const value = obj[prop];
    if (Object.prototype.toString.apply(value) === '[object Object]') {
      result[prop] = deepClone(value);
    }
  }
  return result;
}
//test
const myObj1 = {
  a:1,
  b:{
    c:2,
    d:3
  }
}
const result1 = deepClone(myObj1);
result1.b.c = 4;
console.log(result1.b.c);//4
console.log(myObj1.b.c);//2
```

#### (4) 使用Object.create()方法
直接使用var newObj = Object.create(oldObj)，可以达到深拷贝的效果。
```
function deepClone(initalObj, finalObj) {    
  var obj = finalObj || {};    
  for (var i in initalObj) {        
    var prop = initalObj[i];        // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况
    if(prop === obj) {            
      continue;
    }   
    if (Object.prototype.toString.apply(prop) === '[object Object]') { //最好用此判断
    // if (typeof prop === 'object') {
      obj[i] = (prop.constructor === Array) ? [] : Object.create(prop);
    } else {
      obj[i] = prop;
    }
  }    
  return obj;
}
```
#### (5) jquery 有提供一个$.extend可以用来做 Deep Copy
```
var $ = require('jquery');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = $.extend(true, {}, obj1);
console.log(obj1.b.f === obj2.b.f);
// false
```
#### (6) 
```
function deepClone(initalObj, finalObj) {    
  var obj = finalObj || {};    
  for (var i in initalObj) {        
    var prop = initalObj[i];        // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况
    if(prop === obj) {            
      continue;
    } 
    if (Object.prototype.toString.apply(prop) === '[object Object]') { //最好用此判断      
    //if (typeof prop === 'object') {
      obj[i] = (prop.constructor === Array) ? [] : {};   
      deepClone(prop, obj[i]);  //最好用此代替       
    //  arguments.callee(prop, obj[i]);返回正被执行的 Function 对象，也就是所指定的 Function 对象的正文，这有利于匿名函数的递归或者保证函数的封装性。
    现在已经不推荐使用arguments.callee()；原因：访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响现代浏览器的性能，还会影响闭包。

    } else {
      obj[i] = prop;
    }
  }    
  return obj;
}
var str = {};
var obj = { a: {a: "hello", b: 21} };
deepClone(obj, str);
console.log(str.a);
```

## 数组的深浅拷贝
### 1.浅拷贝：arr.slice()或arr.concat():
浅拷贝，即到数组只有一维的时候,且每一项不是对象的话这样拷贝看起来和深拷贝效果一样

#### (1) 使用Array.prototype.slice()实现浅拷贝

语法
const newArray = oldArray.slice();
`浅拷贝一个数组，这样操作新数组时，就不会改变原数组`。

```js
const a = [1,2,3]
const b = a.slice();
a.push(4);
console.log(a);//[1,2,3,4]
console.log(b);//[1,2,3]
```

slice不修改原数组，只返回一个浅复制了原数组总的元素的一个新数组。原数组的元素会按照下述规则拷贝：
- 如果该元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。
- 对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。

如果向两个数组任一中添加了新元素，则另一个不会受到影响。

#### (2)使用 Array.prototype.concat()实现浅拷贝
```js
const a = [1,2,3]
const b = a.concat();
a.push(4);
console.log(a);//[1,2,3,4]
console.log(b);//[1,2,3]

const a = [1,2,{b:1}];
const b = a.concat();
a.push(4);
console.log(a);//[1,2,{b:1},4]
console.log(b);//[1,2,{b:1}]

a[2].b = 3;
console.log(a);//[1,2,{b:3},4]
console.log(b);//[1,2,{b:3}]  证明是浅拷贝

```


concat方法创建一个新的数组，它由被调用的对象中的元素组成，每个参数的顺序依次是该参数的元素（如果参数是数组）或参数本身（如果参数不是数组）。它不会递归到嵌套数组参数中。

concat方法不会改变this或任何作为参数提供的数组，而是`返回一个浅拷贝`，它包含与原始数组相结合的相同元素的副本。 原始数组的元素将按照如下规则复制到新数组中:

- 对象引用（而不是实际对象）：concat将对象引用复制到新数组中。 原始数组和新数组都引用相同的对象。 也就是说，如果引用的对象被修改，则更改对于新数组和原始数组都是可见的。 这包括也是数组的数组参数的元素。
- 数据类型如字符串，数字和布尔（不是String，Number 和 Boolean 对象）：concat将字符串和数字的值复制到新数组中。



### 2. 深拷贝:JSON.parse(JSON.stringify(arr)) 或loadash的deepClone()方法

同对象的深拷贝。

## 引申阅读:拷贝不变性的重要意义
参见<https://reactjs.org/tutorial/tutorial.html#why-immutability-is-important>

## 参考资料:
<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice>
<https://github.com/wengjq/Blog/issues/3>
<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice>
<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat>


## 深拷贝

- 拷贝字符串、数字及布尔值等基本类型是深拷贝

```
var a = 'str';
var b = a;
b = '111';
"111"
a
"str"
b
"111"
```

## 浅拷贝

- slice拷贝对象是伪深拷贝，只有一维的时候才深拷贝

```
var array = [1,2,3]; 
var array_shallow = array; 
var array_concat = array.concat(); 
var array_slice = array.slice(0); 
console.log(array === array_shallow); //true 
console.log(array === array_slice); //false，“看起来”像深拷贝
console.log(array === array_concat); //false，“看起来”像深拷贝
```
```
var array = [1, [1,2,3], {name:"array"}]; 
var array_concat = array.concat();
var array_slice = array.slice(0);
array_concat[1][0] = 5;  //改变array_concat中数组元素的值 
console.log(array[1]); //[5,2,3] 
console.log(array_slice[1]); //[5,2,3] 
array_slice[2].name = "array_slice"; //改变array_slice中对象元素的值 
console.log(array[2].name); //array_slice
console.log(array_concat[2].name); //array_slice
```

- Object.assign方法实行的是浅拷贝，而不是深拷贝。

```
const obj1 = {a: {b: 1}};
const obj2 = Object.assign({}, obj1);

obj1.a.b = 2;
obj2.a.b // 2

加深深拷贝和浅拷贝的理解
const obj1 = {a: {b: 1}};
const obj2 = Object.assign({}, obj1);

obj2.a.b = 2;
obj1.a.b  //2
```

- 数组、布尔值、对象，都可以通过直接等号来拷贝，并且这样是浅拷贝。

```
实例证明：
var a ={'yes':true,'no':false,'obj':{'c':11}};
var b = '';
b = a
a.obj.c = 'haha';
console.log(a)
console.log(b)
//{yes: true, no: false, obj: {'c':"haha"}}
//{yes: true, no: false, obj: {'c':"haha"}}
```

### 简单的引用复制
```
function shallowClone(copyObj) {
  var obj = {};
  for ( var i in copyObj) {
    obj[i] = copyObj[i];
  }
  return obj;
}
var x = {
  a: 1,
  b: { f: { g: 1 } },
  c: [ 1, 2, 3 ]
};
var y = shallowClone(x);
console.log(y.b.f === x.b.f);     // true
```

## 数组的深拷贝：
1. arr.slice(0)或arr.concat():
伪深拷贝，即到数组只有一维的时候,且每一项不是对象的话这样拷贝看起来和深拷贝效果一样

2. JSON.parse(JSON.stringify(arr)):
可以实现真正的深拷贝，


## ES6下的对象克隆

（1）通过Object.assigin实现
```
const deepClone=(obj)=>{
   var proto=Object.getPrototypeOf(obj);
   return Object.assign({},Object.create(proto),obj);
}
```
通过Object.getPrototypeOf函数得到obj被克隆函数的原型上的属性，然后通过Object.assign实现深度克隆。

（2）通过proto来实现（仅适合浏览器端）
```
const deepClone=(obj)=>({
  __proto__: Object.getPrototypeOf(obj),
  ...obj
})

```
通过扩展运算符…和proto属性来实现

>注意：以上两种办法，当obj为{a: 10, b: 20, c: 30, d: Array(2)}，即包含引用类型，深度克隆得到的值改变引用类型，原对象也会对应改变，相反改变原对象，深度克隆得到的值也会对应改变。·意味着这是浅拷贝（我的理解）·。


