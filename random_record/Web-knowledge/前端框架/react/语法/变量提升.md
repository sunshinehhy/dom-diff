There should be a single “source of truth” for any data that changes in a React application. Usually, the state is first added to the component that needs it for rendering. Then, if other components also need it, you can lift it up to their closest common ancestor. Instead of trying to sync the state between different components, you should rely on the top-down data flow.

对于任何React application中发生变化的数据，都应该有一个“source of truth”。通常，状态首先被添加到需要它进行呈现的组件中。然后，如果其他组件也需要它，您可以将其提升到它们最接近的共同祖先。`您应该依赖自顶向下的数据流，而不是尝试在不同组件之间同步状态。`

Lifting state involves writing more “boilerplate” code than two-way binding approaches, but as a benefit, it takes less work to find and isolate bugs. Since any state “lives” in some component and that component alone can change it, the surface area for bugs is greatly reduced. Additionally, you can implement any custom logic to reject or transform user input.

提升状态涉及到编写更多的““boilerplate””代码，而不是双向绑定方法，但是作为一个好处，找到并隔离bug需要的更少工作。由于任何状态“lives”在某些组件中，而且仅组件本身就可以改变它，所以缺陷的表面积就大大减少了。此外，您还可以实现任何自定义逻辑来拒绝或转换用户输入。

If something can be derived from either props or state, it probably shouldn’t be in the state. For example, instead of storing both celsiusValue and fahrenheitValue, we store just the last edited temperature and its scale. The value of the other input can always be calculated from them in the render() method. This lets us clear or apply rounding to the other field without losing any precision in the user input.

如果某些东西可以从props 或 state中得到，它可能不应该在state中。例如，我们只存储最后编辑过的温度和它的刻度，而不是存储celsiusValue和fahrenheitValue。其他输入的值总是可以从render()方法中计算出来。这可以让我们清楚地了解或应用到其他字段，而不会在用户输入中失去任何精度。

When you see something wrong in the UI, you can use `React Developer Tools `to inspect the props and move up the tree until you find the component responsible for updating the state. This lets you trace the bugs to their source:

当您在UI中看到错误时，您可以使用React Developer工具检查道具并向上移动树，直到您找到负责更新状态的组件。这可以让您跟踪bug的来源:


In React, sharing state is accomplished by moving it up to the closest common ancestor of the components that need it. This is called “lifting state up”. We will remove the local state from the TemperatureInput and move it into the Calculator instead.

In React，共享状态是通过将其`移动到需要它的组件的最接近的共同祖先`来完成的。这被称为“提升状态”。我们将把本地状态从温度中移除，并将其移到计算器中。

If the Calculator owns the shared state, it becomes the “source of truth” for the current temperature in both inputs. It can instruct them both to have values that are consistent with each other. Since the props of both TemperatureInput components are coming from the same parent Calculator component, the two inputs will always be in sync.

如果Calculator拥有共享状态，那么它就会成为输入中current temperature的“真相源”。它可以指导他们双方都有一致的values。由于这两种元素的支柱都来自相同的父计算器组件，所以这两个输入将始终保持同步。

```
从state转化为props
render() {
    // Before: const temperature = this.state.temperature;
    const temperature = this.props.temperature;
    // ...
```