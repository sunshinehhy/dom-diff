## 立即执行函数（IIFE--立即调用的函数表达式）
https://www.cnblogs.com/cnfxx/p/7337889.html

除了使用()运算符之外，！，+，-，=等运算符都能起到立即执行的作用。这些运算符的作用就是将匿名函数或函数声明转换为函数表达式

#### `1. JS立即执行函数的写法：`

方式1、最前最后加括号： (function(){alert(1);}()); 
 
方式2、function外面加括号： (function(){alert(1);})(); 
 
方式3、function前面加运算符，常见的是!与void

!function(){alert(1);}(); 与
void function(){alert(2);}(); 

#### `2. 立即执行函数的参数：`

可以给立即执行函数传递参数，例如
```
    (function(who, when) {
    &nbsp; &nbsp; console.log("I met " + who + " on " + when);
    } ("Joe Black", new Date()));
```
`记住：`
- 立即函数内部是可以访问外部变量的，所以很多情况下，我们并不需要传参数。如：jQuery的window实参，如果不传入。内部也是可以直接使用的。
- 通常你不应该给立即执行函数传递太多的函数，因为它很快会成为一个负担——为了理解代码是如何工作的，你不得不经常上下滚动源代码。

#### `3. 立即执行函数的返回值：`

像其它任何函数一样，一个立即执行函数也能返回值并且可以复制给其它变量，例如
```
var result = (function () {
    return 2 + 2;
}());
 
var result = (function () {
    return 2 + 2;
})();
```
#### `4. 关于括号的一些重要笔记：`
- 在一些情况下，当额外的带着歧义的括号围绕在函数表达式周围是没有必要的(因为这时候的括号已经将其作为一个表达式去表达)，但当括号用于调用函数表达式时，这仍然是一个好主意。

- 这样的括号指明函数表达式将会被立即调用，并且`变量将会储存函数的结果，而不是函数本身`。当这是一个非常长的函数表达式时，这可以节约比人阅读你代码的时间，不用滚到页面底部去看这个函数是否被调用。

- 作为规则，当你书写清楚明晰的代码时，有必要阻止 JavaScript 抛出错误的，同样也有必要阻止其他开发者对你抛出错误 WTFError!

#### `5. 作用：`
- IIFE最常用的功能显然是`隔离作用域`。

- ES6之前JS原生又不提供块级作用域，所以只能用函数作用域模拟了。

- 还有种常用就是，`用IIFE写惰性载入`，因为函数被执行引擎以同步的方式立即执行了，所以当你在之后的代码访问这个变量的时候可以直接返回给你计算后的筛选结果了。

## 惰性函数
https://www.cnblogs.com/pigtail/p/3442463.html

- 所谓惰性载入，就是说函数的if分支只会执行一次，之后调用函数时，直接进入所支持的分支代码。
- 有两种实现惰性载入的方式，第一种事函数在第一次调用时，对函数本身进行二次处理，该函数会被覆盖为符合分支条件的函数，这样对原函数的调用就不用再经过执行的分支了，我们可以用下面的方式使用惰性载入重写addEvent()。

- 惰性载入表示函数执行的分支只会在函数第一次掉用的时候执行，在第一次调用过程中，该函数会被覆盖为另一个按照合适方式执行的函数，这样任何对原函数的调用就不用再经过执行的分支了。

`惰性函数定义，应用场景我们可以总结一下：`
1. 应用频繁，如果只用一次，是体现不出它的优点出来的，用的次数越多，越能体现这种模式的优势所在；
2. 固定不变，一次判定，在固定的应用环境中不会发生改变；
3. 复杂的分支判断，没有差异性，不需要应用这种模式；
    
### 变量
`初始化未经声明的变量，总是会创建一个全局变量。函数声明只会创建局部函数。`
+ 为自定义类型创建私有变量和特权方法。
特权方法：有权访问私有变量和私有函数的公有方法。
 - 第一种：是在构造函数中定义特权方法。
    缺点：必须使用构造函数模式来达到这个目的。
    构造函数的缺点：针对每个实例都会创建同样一组新方法，
 - 第二种：使用静态私有变量来实现特权方法。
    封装一个构造函数，公有或特权方法是在原型上定义，因此所有的实例都使用同一函数。在一个实例上改变变量值，会影响所有实例。
    缺点：会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。

+ 为单例创建私有变量和特权方法
 - 模块模式 P189
 如果必须创建一个对象并以某些数据对其进行实例化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。
 以这种模式创建的每个单例都是`object实例`，因为最终要通过一个`对象字面量`来表示它。
 - 增强的模块模式：适合那些单例必须是某种类型的实例。P191

### 创建对象

 + 工厂模式 P144
   - 优点：解决了创建多个相似对象的问题
   - 缺点：但没有解决对象识别的问题（即怎么知道一个对象的类型？）
 + 构造函数模式 
   - 优点：
    + `可以创建特定类型的对象`，比如Array属于原生构造函数，也可以自定义构造函数；
    + 没有显示地创建对象；
    + 直接将属性和方法赋给了this对象；
    + 没有return语句；
    + 首字母大写，非构造函数则应该以小字母开头；
    + 必须用new操作符；
    + 不同对象分别保存着不同的实例，每个对象都有；
    + 都有constructor（构造函数）属性，对象的constructor属性最初是用来标识对象类型的，但是，提到检测对象类型，还是instanceof操作符更可靠一些。
    + 不同实例上的同名函数是不相等的。
   - 缺点：每个方法都要在每个实例上重新创建一遍。
   **在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方法，那么就要定义很多个全局函数。**
 + 原型模式
   - 优点：解决了创建多个相似对象的问题
    + 每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。按字面意思理解，prototype是通过调用构造函数而创建的那个对象实例的原型对象。
    + 可以让搜优对象实例共享它所包含的属性和方法。
    + 默认情况下，所有原型对象都会自动获得一个constructor属性，包含指向prototype属性所在函数的指针。
   - 缺点：实例一般都是要有属于自己的全部属性。
 + 组合使用构造函数模式和原型模式
   - 优点：构造函数用于定义实例属性，而原型模式用于定义方法和共享的属性。
    + 使用最广泛、认同度最高的一种创建自定义类型的方法。
   - 缺点：
 + 动态原型模式
   - 优点：可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。
    + 把所有信息都封装在构造函数中，在构造函数中初始化原型，保持了同时使用构造函数和原型的优点。
    + 方法很好
   - 缺点：
 + 寄生构造函数模式
   - 优点：封装创建对象的代码，然后返回新创建的对象。
   - 缺点：
    + 不用使用此模式
    + 返回的对象与构造函数或者是构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。因此，`不能依赖instanceof操作符确定对象`。
 + 稳妥构造函数模式
   - 特点：
    + 新创建对象的实例方法不引用this
    + 不使用new操作符调用构造函数
    + 没有公共属性
    + 最适合在一些安全的环境中，或者在防止数据被其它应用程序改动时使用。
   - 优点：
   - 缺点：
   

 ### 继承

 + 原型链
 基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。
 缺点：来自引用类型值的原型。通过原型实现继承时，原型实际上会变成另一类型的实例。
 创建子类型的实例时，不能向超类型的构造函数中传递参数。
 + 借用构造函数
 基本思想：在子类型构造函数的内部调用超类型构造函数。可以通过apply和call方法在新创建的对象上执行构造函数。
 缺点：无法避免构造函数模式存在的问题。
 + 组合继承
 思路：使用原型链实现对原型属性和方法的继承，又通过借用构造函数来实现对实例属性的继承
 优点：最常用继承模式

 + 原型式继承
 + 寄生式继承
 + 寄生组合式继承

### 纯函数

纯函数是函数式编程的概念，必须遵守以下一些约束。

- 不得改写参数
- 不能调用系统 I/O 的API
- 不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果