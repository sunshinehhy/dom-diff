

#### 数组的扩展

+ Array.from()将两类对象转为真正的数组，类似数组的对象和可遍历对象都可以。
+ 只要是部署了iterator接口的数据结构，Array.from()都能将其转为数组。
+ <font color="red">任何有length属性的对象，都可以用Array.from()转为数组，扩展运算符无法转换</font>
    * Array.from({ length: 3 });// [ undefined, undefined, undefined ]
+ 对于还没有部署Array.from()的浏览器，可以使用Array.prototype.slice方法替代。
```
    const toArray = (() =>
        Array.from ? Array.from : obj => [].slice.call(obj)
    )();

```
+ Array.from()可以接受第二个参数，作用类似于数组的map方法，用于对每个元素进行处理，将处理后的值放入返回的数组。
+ Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。
+ Array.of():将一组值转换为数组
    * Array()参数个数的不同会导致行为有差异
    * Array.of()基本上可以替代Array()或new Array()
    * Array.of()总是返回参数组成的数组，如果没有参数，就返回一个空数组。
+ copyWithin():在当前数组内部将指定位置的成员复制到其它位置（<font color="red">会覆盖原有成员</font>），然后返回当前数组。
+ 数组实例的 find() 和 findIndex()
    * <font color="red">indexOf()方法无法识别数组的NaN成员，但findIndex可以借助Object.is方法做到</font>
+ 数组实例的entries()、keys()、values():遍历数组   
    * <font color="red">可用for...of循环遍历</font>
    * keys()对键名遍历
    * values()对键值遍历
    * entries()对键值对遍历
    * 如果不适用for...of循环，可以手动调用遍历器对象的next（）方法遍历
+ 数组实例的includes()  ：某个数组是否包含给定的值
    * indexOf()方法有2个缺点：一是不够语义化，其含义是找到参数值的第一个出现位置，所以要比较是否不等于-1，表达起来不够直观；二是其内部使用严格相当运算符（===）进行判断，会导致NaN的误判。
    * [NaN].includes(NaN)// true
       [NaN].indexOf(NaN)// -1
    * Map结构的has方法是用来查找键名的
    * Set结构的has方法是用来查找值的
    * <font color="red">数组中尽量不要有空位</font>

## findIndex

array.findIndex(function(currentValue, index, arr), thisValue)

findIndex() 方法返回传入一个测试条件（函数）`符合条件的数组第一个元素位置`。

findIndex() 方法为数组中的每个元素都调用一次函数执行：

当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，`之后的值不会再调用`执行函数。
`如果没有符合条件的元素返回 -1`。

 
**注意:**

- findIndex() `对于空数组，函数是不会执行的`。
- findIndex() 并`没有改变数组的原始值`。


**indexOf和findIndex的区别**

indexOf方法`无法识别数组的NaN成员`，但是findIndex方法可以借助Object.is方法做到。
```
[NaN].indexOf(NaN)
// -1
[NaN].findIndex(y => Object.is(NaN, y))
// 0
[NaN].findIndex(NaN => Object.is(NaN, NaN))
//0
[NaN].includes(NaN)
// true

const contains = (() =>
  Array.prototype.includes
    ? (arr, value) => arr.includes(value)
    : (arr, value) => arr.some(el => el === value)
)();
contains(['foo', 'bar'], 'baz'); // => false
```

typeof NaN
"number"
NaN instanceof Object
false