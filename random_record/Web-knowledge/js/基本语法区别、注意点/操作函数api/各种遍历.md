# 各种遍历api

## forEach
array.forEach(function(currentValue, index, arr), thisValue)

forEach遍历数组，不是对象

forEach遍历Set和Map成员

```
var arr = [1,2,3,4];
let set = new Set(arr);
set.forEach(function(value,index) {
   console.log(value); 
}, this);
```
```
var bb=[1,2];
bb.forEach((value,index)=>{
    console.log('value:'+value);  
});

var para = location.search.substring(1);
var paraArr = para.split('&');
var aa = paraArr.map((value,index)=>{
    console.log('value:'+value.split('='));
    return value.split('=')
});
paraArr不会变化，还是输出原值，aa就变成return之后的数组，aa变成数组包含数组
```
## map
array.map(function(value,index,array){}

map遍历数组，不是对象

map构造函数接受参数：数组 和 任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构

map我不熟悉的特殊用法：

```
// 下面的语句返回什么呢:
["1", "2", "3"].map(parseInt);
// 你可能觉的会是[1, 2, 3]
// 但实际的结果是 [1, NaN, NaN]

// 通常使用parseInt时,只需要传递一个参数.
// 但实际上,parseInt可以有两个参数.第二个参数是进制数.
// 可以通过语句"alert(parseInt.length)===2"来验证.
// map方法在调用callback函数时,会给它传递三个参数:当前正在遍历的元素, 元素索引, 原数组本身.
// 第三个参数parseInt会忽视, 但第二个参数不会,也就是说,
// parseInt把传过来的索引值当成进制数来使用.从而返回了NaN.

function returnInt(element) {
  return parseInt(element, 10);
}

['1', '2', '3'].map(returnInt); // [1, 2, 3]
// 意料之中的结果

// 也可以使用简单的箭头函数，结果同上
['1', '2', '3'].map( str => parseInt(str) );

// 一个更简单的方式:
['1', '2', '3'].map(Number); // [1, 2, 3]
// 与`parseInt` 不同，下面的结果会返回浮点数或指数:
['1.1', '2.2e2', '3e300'].map(Number); // [1.1, 220, 3e+300]
```
## 类似数组（可先转换为数组，再进行遍历）

let divList = document.querySelectorAll('div');   //divList不是数组，而是nodeList
 
- `方法一：` 
[].slice.call(divList).forEach(function(element,index){
  element.classList.add('test')
})
 
- `方法二：` 
Array.prototype.slice.call(divList).forEach(function(element,index){
  element.classList.remove('test')
})

- `方法三：` 
[...divList].forEach(function(element,index){   //<strong>ES6写法</strong>
  //do something
})

- ` 方法四：` 
Array.from(divList).forEach(function(element,index){   //<strong>ES6写法</strong>
  //do something
})

```
let divList = document.querySelectorAll('div');
divList.forEach(function(value,index) {  //使用forEach可以得出结果
   console.log(value); 
}, this);

divList.map(function(value,index){   //使用map出错
    console.log(index); 
})
for (let key of divList) {  //使用for of可以得出结果
    console.log(key);
}
```
## reduce
array.reduce(function(total, currentValue, currentIndex, arr), initialValue)
reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。
reduce() 对于空数组是不会执行回调函数的。

## for...of
遍历数组、iterable 接口都可以（Set、Map） 

如果for (let [key,value] of obj)  //obj是一对象。这样写会报错obj is not iterable

for (let [key, value] of Object.entries(obj)) //obj是一对象。可以

## for...in
在使用for in循环之前，先检测确定该对象的值不是undefined或null。

## 遍历器
- keys()：返回键名的遍历器  ，返回数组
- values()：返回键值的遍历器  ，返回数组
- entries()：返回键值对的遍历器  ，返回数组
- forEach()：使用回调函数遍历每个成员。
数组、Map和Set都可以

## filter方法
数组
filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。

注意： filter() 不会对空数组进行检测。

注意： filter() 不会改变原始数组。

## 用于数组
filter map forEach reduce()  for...of  

splice()  该方法会改变原始数组。

slice()   返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。 
entries()，keys() 和 values()  (es6)
Array.from()
Array.of()
includes()  **假如includes不支持，可以写一个contains接口函数，见数组的扩展**
indexOf() 
find() 和 findIndex()  
```
//[NaN].includes(NaN)// true 
//[NaN].indexOf(NaN)// -1

//[NaN].indexOf(NaN)// -1   
[NaN].findIndex(y => Object.is(NaN, y)) // 0
```

map():返回一个`新的Array`，每个元素为调用func的结果

filter():返回一个符合func条件的元素数组。创建一个新的数组，不会改变原始数组，不会对空数组进行检测

some():返回一个boolean，判断是否有元素是否符合func条件。依次执行数组的每个元素，不会改变原始数组，不会对空数组进行检测；如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测；如果没有满足条件的元素，则返回false。

every():返回一个boolean，判断每个元素是否符合func条件

forEach():没有返回值，只是针对每个元素调用func
**indexOf方法`无法识别数组的NaN成员`，但是findIndex方法可以借助Object.is方法做到。见 数组的扩展**
fill()
copyWithin()
解构
扩展运算符

## 用于对象
for in
Object.keys()，Object.values()，Object.entries()  (es6)
解构

- for...in循环：只遍历`对象自身`的和`继承`的`可枚举`的属性。
- Object.keys()：返回`对象自身`的`所有可枚举`的属性的`键名`。
- JSON.stringify()：只`串行化对象自身的可枚举`的属性。
- Object.assign()： `忽略enumerable为false`的属性，`只拷贝对象自身的可枚举`的属性

属性的遍历（ES6 一共有 5 种方法可以遍历对象的属性） 见 对象的扩展
for...in 
Object.keys(obj)
Object.getOwnPropertyNames(obj)
Object.getOwnPropertySymbols(obj)
Reflect.ownKeys(obj)

for...of不能用于原生对象，除非添加遍历器 ，见http://es6.ruanyifeng.com/#docs/generator

**合并对象**
扩展运算符可以用于合并两个对象。
```
let ab = { ...a, ...b };
// 等同于
let ab = Object.assign({}, a, b);
```
**复制对象**
```
let aClone = { ...a };
// 等同于
let aClone = Object.assign({}, a);
```

## 用于字符串
includes()
解构 //const [a, b, c, d, e] = 'hello'; a // "h"
concat()
slice()、substr()和substring()
indexOf()和lastIndexOf()
trim()
toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocaleUpperCase()
match()   test()   exec()
search()
replace()
split()
charAt()和charCodeAt()

## 变成数组
- 字符串可以通过扩展运算符变成数组；或者用Array.from()将字符串转为数组，然后返回字符串的长度
- Set可以通过Array.from和扩展运算符变成数组，然后可以用数组的方法
- 部署了iterator接口的数据结构，Array.from()都能将其转为数组
- Map使用扩展运算符变成数组  

## Set
- keys()：返回键名的遍历器
- values()：返回键值的遍历器
- entries()：返回键值对的遍历器
- forEach()：使用回调函数遍历每个成员。还可以有第二个参数，表示绑定处理函数内部的this对象
- 可以直接用for...of循环遍历Set

**实例方法和属性**
- size
- add(value)：添加某个值，返回 Set 结构本身。
- delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
- has(value)：返回一个布尔值，表示该值是否为Set的成员。
- clear()：清除所有成员，没有返回值。

**特殊作用**
数组去重

## Map  （具体见Map详解）
keys()：返回键名的遍历器。
values()：返回键值的遍历器。
entries()：返回所有成员的遍历器。
forEach()：遍历 Map 的所有成员。forEach方法还可以接受第二个参数，用来绑定this。

**实例方法和属性**
- size 属性
- set(key, value)
- get(key):如果找不到key，返回undefined
- has(key)
- delete(key)
- clear()


# 遍历函数区别
## (for..in)、for of和forEach的区别  (是forEach不是foreach)
for in可以遍历数组和对象
for of可以遍历数组和对象(对象的写法需要用Object.entries(obj)等，见上面具体说明) 

- `for...in `
1. 语句以任意顺序遍历一个对象的**可枚举属性（包括原型和对象本身的属性）**。
2. 对于每个不同的属性，语句都会被执行。每次迭代时，**分配的是属性名**　　
3. 补充 : 因为迭代的顺序是依赖于执行环境的，所以数组遍历**不一定按次序访问元素**。 因此当迭代那些访问次序重要的 arrays 时用整数索引去进行 for 循环 (或者使用 Array.prototype.forEach() 或 for...of 循环)。
4. 索引为字符串类型，不能直接进行几何运算。

- `for...of `
1. 只要部署了Iterator的数据结构都可以使用 for ··· of ··· 完成遍历操作  
2. 每次迭代分配的是**属性值**
3. 可遍历NodeList

- `forEach `
1. 每次迭代分配的是**属性名和属性值**
2. forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。
3. 注意: forEach() **对于空数组是不会执行回调函数的**。

foreach更多的用来遍历数组，但使用比较复杂；
for in 一般常用来遍历对象；
for of 用来遍历数组非常方便且比较安全。

for..of为ES6新增的方法，主要来遍历可迭代的对象（包括Array, Map, Set, arguments等），它主要用来获取对象的属性值，而for..in主要获取对象的属性名。
```
var colors = ['red', 'green', 'blue'];
colors.length = 5;
colors.push('yellow');

for (var i in colors) {
  console.log(colors[i]); // red green blue yellow    发现对于不存在的项是不会被枚举出来的 
  typeof i; // string
}
至于为什么for..in在遍历数组时i为字符串？colors.0这样显然会报语法错识，那么只能使用colors['0']这种形式了。这可能就是为什么i的值为字符串，而不是数字的原因。
colors[0]  //'red'
colors['0']  //'red'
colors.0  //报错


for (var j of colors) {
  console.log(j); // red green blue undefined undefined yellow
}
可以看到使用for..of可以输出包括数组中不存在的值在内的所有值
```

- for
for..in和for遍历数组时下标类型不一样
```
var colors = ['red', 'green', 'blue'];

for (var i in colors) {
  typeof i; // string
}

for (var j = 0; j < colors.length; j++) {
  typoef i; // number
}
```
```
var colors = ['red', 'green', 'blue'];
// 将数组长度变为10
colors.length = 10;
// 再添加一个元素的数组末尾
colors.push('yellow');

for (var i in colors) {
  console.log(i); // 0 1 2 10
}
<!--新增的每一项都会取得undefined值-->
for (var j = 0; j < colors.length; j++) {
  console.log(j); // 0 1 2 3 4 5 6 7 8 9 10
}
```

## (for..in)、Object.keys()和Object.getOwnPropertyNames()的区别

- `for...in`
1. 返回的是所有能够通过对象访问的、可枚举的属性，既包括存在于实例中的属性，也包括存在于原型中的实例。（**获取可枚举的实例和原型属性名**）
2. 返回的属性因各个浏览器厂商遵循的标准不一致导致对象属性遍历的顺序有可能不是当初构建时的顺序。

- `Object.keys()`

1. 用于获取对象**自身本身所有的可枚举的属性值**，但不包括原型中的属性，然后返回一个由属性名组成的数组。
2. 注意：它同for..in一样不能保证属性按对象原来的顺序输出。

```
// 遍历数组
var colors = ['red', 'green', 'blue'];
colors.length = 10;
colors.push('yellow');
Array.prototype.demo = function () {};

Object.keys(colors); //["0", "1", "2", "10"]  不包含原型中的
console.log(colors);  //["red", "green", "blue", empty × 7, "yellow"]

// 遍历对象
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.demo = function() {};  不包含原型中的

var jenemy = new Person('jenemy', 25);

Object.keys(jenemy); // name age
```
3. 注意在 ES5 环境，如果传入的参数**不是一个对象，而是一个字符串**，那么它会报 TypeError。在 ES6 环境，如果传入的是一个非对象参数，内部会对参数作一次强制对象转换，如果转换不成功会抛出 TypeError

```
// 在 ES5 环境
Object.keys('foo'); // TypeError: "foo" is not an object

// 在 ES6 环境
Object.keys('foo'); // ["0", "1", "2"]

// 传入 null 对象
Object.keys(null); // Uncaught TypeError: Cannot convert undefined or null to object

// 传入 undefined
Object.keys(undefined); // Uncaught TypeError: Cannot convert undefined or null to object
```

- `Object.getOwnPropertyNames()`

返回对象的**所有自身属性的属性名（不管是否枚举的值）组成的数组**，但不会获取原型链上的属性

- `hasOwnProperty()`

如果只需要获取**对象的实例属性**，可以使用hasOwnProperty()将可枚举的属性过滤掉。

同时使用hasOwnProperty()和in，`判断对象是否存在实例中或者是否存在原型中`

https://www.cnblogs.com/wujie520303/p/4931384.html



## forEach 和 map 区别
forEach() 方法对数组的每个元素执行一次提供的函数。`总是返回undefined`；

map() 方法创建一个新数组，其结果是该数组中的每个元素`都调用一个提供的函数后返回的结果`。`返回值是一个新的数组`；
```
var array1 = [1,2,3,4,5];
 
var x = array1.forEach(function(value,index){
 
    console.log(value);   //1 2 3 4 5  可遍历到所有数组元素  
 
    return value + 10
});
console.log(x);   //undefined    无论怎样，总返回undefined
 
var y = array1.map(function(value,index){
 
    console.log(value);   //1 2 3 4 5 可遍历到所有数组元素
 
    return value + 10
});
console.log(y);   //[11, 12, 13, 14, 15]
```