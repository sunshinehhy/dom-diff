// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content

https://www.jianshu.com/p/c914ccd498e7
https://my.oschina.net/u/3692906/blog/2050377

https://flow.org/en/ (flow)

https://github.com/vuejs/vue/tree/dev/src (vue源码)

http://hcysun.me/vue-design/ （Vue技术内幕，逐行分析源码）
https://ustbhuangyi.github.io/vue-analysis/ （Vue.js 技术揭秘）

学习流程：
- 先看所有api
- 然后分别研究单个方面（结合）
- 研究监听test-passive
- Window.getComputedStyle()


function setSelected (el, binding, vm) {
  actuallySetSelected(el, binding, vm)
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(() => {
      actuallySetSelected(el, binding, vm)
    }, 0)
  }
}
为什么ie浏览器要用setTimeout

Array.prototype.map.call(links,function(e){})  转化为数组

## 文件保存
- src/platforms/web/runtime/directives/model.js
const directive = {
  inserted (el, binding, vnode, oldVnode) {}
  componentUpdated (el, binding, vnode) {}
}
对象能像以上这么写吗？
function setSelected (el, binding, vm) {}

- src/platforms/web/server/directives/model.js
export default function model (node: VNodeWithData, dir: VNodeDirective) {
    node.data.attrs怎么得来的？
}

- src/platforms/web/server/directives/show.js
export default function show (node: VNodeWithData, dir: VNodeDirective) {}

- src/platforms/web/server/modules/attrs.js
export default function renderAttrs (node: VNodeWithData): string {}

- src/platforms/web/server/modules/class.js
export default function renderClass (node: VNodeWithData): ?string {}

- src/platforms/web/server/modules/dom-props.js
export default function renderDOMProps (node: VNodeWithData): string {}

- src/platforms/web/compiler/options.js

- src/platforms/web/compiler/directives/html.js
```
export default function html (el: ASTElement, dir: ASTDirective) {
  if (dir.value) {
    addProp(el, 'innerHTML', `_s(${dir.value})`, dir)
  }
}
```
- src/platforms/web/compiler/directives/model.js  
- src/platforms/web/compiler/directives/text.js

- src/platforms/web/compiler/modules/class.js

- src/platforms/web/runtime/components/transition-group.js
export default {}

- src/platforms/web/runtime/node-ops.js
createElement、createElementNS、createTextNode、createComment、insertBefore、removeChild、appendChild、parentNode、nextSibling、tagName、setTextContent、setStyleScope

- src/platforms/web/runtime/patch.js
export const patch: Function = createPatchFunction({ nodeOps, modules })

- src/platforms/web/runtime/class-util.js
addClass、removeClass

- src/platforms/web/runtime/transition-util.js
export function resolveTransition (def?: string | Object): ?Object {}
addTransitionClass\removeTransitionClass\whenTransitionEnds\getTransitionInfo

- blob/dev/src/core/util/options.js
Option overwriting strategies are functions that handle how to merge a parent option value and a child option value into the final value.
选重写策略是处理如何将父选项值和子选项值合并到最终值的函数。

function normalizeProps (options: Object, vm: ?Component) {
    为什么要转化成{ type: null }？？？
}

normalizeDirectives  dirs[key] = { bind: def, update: def }

export function mergeOptions ( parent: Object,child: Object,vm?: Component){}

- blob/dev/src/core/vdom/helpers/merge-hook.js
export function mergeVNodeHook (def: Object, hookKey: string, hook: Function) {}

- blob/dev/src/core/global-api/extend.js
有继承方法
Vue.extend = function (extendOptions: Object): Function {}

- src/core/vdom/vnode.js
export default class VNode {}
export const createEmptyVNode = (text: string = '') => {}
export function createTextVNode (val: string | number) {}
export function cloneVNode (vnode: VNode): VNode {}

- src/core/components/keep-alive.js
keep-alive是一个组件
https://github.com/liutao/vue2.0-source/blob/master/keep-alive.md


- src/compiler/helpers.js
addProp addAttr addHandler  addRawAttr addDirective

- src/compiler/parser/text-parser.js
parseText 用分隔符拆分，左右中


## 理解
createCompilerCreator
模板编译分为三个阶段：生成ast、优化静态内容、生成render
在创建对象时直接传入render函数？怎么搞？模板编译这一步就可以直接跳过，这样效率肯定更高，但同时我们编写代码的难度会增加很多。实际开发过程中，根据需要，恰当选择。
 this.$options从哪里来
 SVG ：没有outHTML?
 export function createCompiler (baseOptions: CompilerOptions) {}
src/compiler/create-compiler.js:
compile,compileToFunctions: createCompileToFunctionFn(compile)

compile应用baseCompile
baseCompile中执行的就是模板编译的三个重要步骤

export function createCompileToFunctionFn (compile: Function): Function {}
```
reateCompilerCreator (baseCompile: Function): Function {
  return function createCompiler (baseOptions: CompilerOptions) {
    function compile ()
compile在reateCompilerCreator里面
```
```
用法：merge数组和对象
if (options.modules) {
        finalOptions.modules = (baseOptions.modules || []).concat(options.modules)
      }
      // merge custom directives
      if (options.directives) {
        finalOptions.directives = extend(
          Object.create(baseOptions.directives),
          options.directives
        )
      }
      // copy other options
      for (const key in options) {
        if (key !== 'modules' && key !== 'directives') {
          finalOptions[key] = options[key]
        }
      }
```


## 双向绑定
主要实现以下四个：
- 监听器Observer
对data数据对象变得“可监测”，vue2.0用Object.defineProperty()来劫持各个数据属性的 setter / getter；

get——收集订阅者watcher，dep.addSub(Dep.target)；
set——通知订阅器dep，调用notify；
```
/**
  * 循环遍历数据对象的每个属性
  */
function observable(obj) {
    if (!obj || typeof obj !== 'object') {
        return;
    }
    let keys = Object.keys(obj);
    keys.forEach((key) => {
        defineReactive(obj, key, obj[key])
    })
    return obj;
}
/**
 * 将对象的属性用 Object.defineProperty() 进行设置
 */
function defineReactive(obj, key, val) {
    Object.defineProperty(obj, key, {
        get() {
            console.log(`${key}属性被读取了...`);
            return val;
        },
        set(newVal) {
            console.log(`${key}属性被修改了...`);
            val = newVal;
        }
    })
}


defineReactive: function(data, key, val) {
	var dep = new Dep();
	Object.defineProperty(data, key, {
		enumerable: true,
		configurable: true,
		get: function getter () {
			if (Dep.target) {
				dep.addSub(Dep.target);
			}
			return val;
		},
		set: function setter (newVal) {
			if (newVal === val) {
				return;
			}
			val = newVal;
			dep.notify();
		}
	});
}

```

- 订阅器Dep
通知订阅者watcher更新函数；
```
function Dep () {
    this.subs = [];
}
Dep.prototype = {
    addSub: function(sub) {
        this.subs.push(sub);
    },
    notify: function() {
        this.subs.forEach(function(sub) {
            sub.update();
        });
    }
};
Dep.target = null;

```

- 订阅者Watcher（一个模板指令相对于一个watcher）
触发监听器Observer里的get函数，将自己添加到订阅器Dep中；
包含update属性值的函数；
更新View界面；

```
function Watcher(vm, exp, cb) {
    this.vm = vm;
    this.exp = exp;
    this.cb = cb;
    this.value = this.get();  // 将自己添加到订阅器的操作
}

Watcher.prototype = {
    update: function() {
        this.run();
    },
    run: function() {
        var value = this.vm.data[this.exp];
        var oldVal = this.value;
        if (value !== oldVal) {
            this.value = value;
            this.cb.call(this.vm, value, oldVal);
        }
    },
    get: function() {
        Dep.target = this; // 全局变量 订阅者 赋值
        var value = this.vm.data[this.exp]  // 强制执行监听器里的get函数
        Dep.target = null; // 全局变量 订阅者 释放
        return value;
    }
};

```

- 编译者Compile
初始化订阅者Watcher；
解析模板指令，并替换模板数据，初始化视图；
将模板指令对应的节点绑定对应的更新函数，初始化相应的订阅者Watcher；

传入模板指令对应节点，初始化相应的订阅者Watcher，触发订阅者Watcher中的更新函数
```
对 '{{变量}}' 这种形式的指令处理的关键代码进行分析
compileText: function(node, exp) {
	var self = this;
	var initText = this.vm[exp]; // 获取属性值
	this.updateText(node, initText); // dom 更新节点文本值
    // 将这个指令初始化为一个订阅者，后续 exp 改变时，就会触发这个更新回调，从而更新视图
	new Watcher(this.vm, exp, function (value) { 
		self.updateText(node, value);
	});
}

```
- 监听器 Observer ，用来劫持并监听所有属性（转变成setter/getter形式），如果属性发生变化，就通知订阅者
- 订阅器 Dep，用来收集订阅者，对监听器 Observer 和 订阅者 Watcher 进行统一管理
- 订阅者 Watcher，可以收到属性的变化通知并执行相应的方法，从而更新视图
- 解析器 Compile，可以解析每个节点的相关指令，对模板数据和订阅器进行初始化

自己口头描述：双向绑定主要需要实现observer、dep、watcher、compile，他们分别的功能是。。。
首先要定义observer，对data中属性的setter / getter进行拦截，compile解析模板中指令，替换模板数据，初始化视图，初始化订阅者；watcher相当于每个指令，触发getter，添加到dep中；dep收集watcher，当收到属性变化通知时，通知更新函数。（我觉得赋值是在代码中赋值，就能监听到set）

## 源码加强分析
注意：每个data对象的属性的 getter 都持有一个 dep；源码中收集watcher会有判断保证同一数据不会被添加多次
```
addDep (dep: Dep) {
  const id = dep.id
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id)
    this.newDeps.push(dep)
    if (!this.depIds.has(id)) {
      dep.addSub(this)
    }
  }
}

```
这时候会做一些逻辑判断（保证同一数据不会被添加多次）后执行 dep.addSub(this)，那么就会执行 this.subs.push(sub)，也就是说把当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个`目的是为后续数据变化时候能通知到哪些 subs 做准备`。所以在 vm._render() 过程中，会触发所有数据的 getter，这样实际上已经完成了一个依赖收集的过程。



## vue2.0怎么对数组和对象拦截
数组：observe 方法
对象：遍历对象的key调用 defineReactive 方法，

defineReactive 的功能就是定义一个响应式对象，给对象动态添加 getter 和 setter，递归调用observe 方法，这样就保证了无论 obj 的结构多复杂，它的所有子属性也能变成响应式的对象，这样我们访问或修改 obj 中一个嵌套较深的属性，也能触发 getter 和 setter。


