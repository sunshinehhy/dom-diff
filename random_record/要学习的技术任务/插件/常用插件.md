
babel :http://babeljs.io/docs/plugins/#modules
pify ：Promisify a callback-style function
path：Node.JS path module
fs-jetpack：Better file system API
load-json-file：Read and parse a JSON file

#### inline-source
inline-source：Inline all flagged js, css, image source files
内联和压缩包含内联属性的标签。支持`<script>`， <link>，和<img>(包括*)。
默认情况下的svg来源)标签，并且易于扩展，以处理其他内容。
gulp-usemin可以实现把js、css中的内容直接写入html中，减少浏览器请求次数，但是需要在被替换的标签前后加上注释
不引用外部的静态资源文件，而直接通过`<style>`或`<script>`写入的css与js，一般叫做inline resources。


```
  rollup-plugin-babel：Rollup和Babel之间的无缝集成。
  rollup-plugin-uglify：Rollup插件以缩小生成的包。
  postcss-cssnext：Use tomorrow’s CSS syntax, today
  rollup-plugin-buble：Compile ES2015 with buble
  rollup：Next-generation ES6 module bundler
  rollup-plugin-node-resolve：Bundle third-party dependencies in node_modules
  mkdirp：Recursively mkdir, like `mkdir -p`
  is-there：Check if a file or directory exists in a given path

```
Rollup是JavaScript的一个模块bundler，它将一小段代码编译成更大更复杂的代码，比如一个库或应用程序。它使用新的标准格式的代码模块包括在ES6版本的JavaScript，而不是以前的特殊解决方案，如CommonJS和AMD。ES6模块让您可以自由地、无缝地结合您最喜欢的库中最有用的单个函数。
rollup函数返回一个Promise，它将解析成具有各种属性的bundle对象。

```
    // 3中方式
    gulp.task('scripts', async () => {
    async function rollupJs() {
    try {
      const bundle = await rollup({
        input:'client/scripts/main.js',
        plugins:[
          babel({
            exclude:'node_modules/**'
          }),
          nodeResolve({
            jsnext:true,
          })
        ]
      }) ;
      await bundle.write({//返回promise，以便下一步then()
          file: '.tmp/scripts/main.js',
          format: 'iife',
          sourcemap: true
      });
    }catch (err) {
      console.log(err);
    };
    } 
    rollupJs()
    browserSync.reload();
    });

    gulp.task('script2', () => {
      return gulp.src('client/scripts/**/*.js')
        .pipe($.plumber())  //自动处理全部错误信息防止因为错误而导致 watch 不正常工作
        .pipe($.sourcemaps.init({loadMaps:true})) 
        .pipe($.babel())
        .pipe($.sourcemaps.write('./'))
        .pipe(gulp.dest('.tmp/scripts'))
        .pipe(browserSync.reload({stream: true}));
    });
    gulp.task('scripts1', () => {
      return rollup({  
        input:[babelpolyfill,'client/main.js'],    //entry改成input
        plugins: [
          babel({//这里需要配置文件.babelrc
              exclude:'node_modules/**'
          })
        ],
        cache: cache   //先注释看有什么问题？
      }).then(function(bundle) {
        // Cache for later use
        cache = bundle;

      return bundle.write({
        dest: '.tmp/main.js',
        format: 'iife',
        sourceMap: true
      });
    })
    .then(() => {
      browserSync.reload();
      return Promise.resolve();
    })
    .catch(err => {
      console.log(err);
    });
    });

```

命令行下使用npm run命令，就可以执行package.json中的scripts。
(string)APP的主入口，指定一个html文件或js文件

Promise.resolve(process.env.NODE_ENV = 'production') 线上环境

"gulp-jshint"安装它需要安装依赖包，不然出错

###如何写好.babelrc？
 https://excaliburhan.com/post/babel-preset-and-plugins.html  

 "modules": false   可以禁用模块转换

```
 {
  "presets": [
    [
      "env",  
      {
        "modules": false
      }
    ]
  ],
  "plugins": [
    "external-helpers"
  ]
}
 "es2015"不能解析async，  "env"可以解析
 Error: It looks like your Babel configuration specifies a module transformer. Please disable it. See https://github.com/rollup/rollup-plugin-babel#configuring-babel for more information
 解决办法是不应该仅仅写"es2015"

```
 改成"env"，弹出错误：
Uncaught ReferenceError: regeneratorRuntime is not defined
使用 eES7的async 会报：
ReferenceError: regeneratorRuntime is not defined".

https://github.com/rollup/rollup-plugin-babel#configuring-babel
以下仅适用于Babel 6。如果您使用的是Babel 5，请使用npm我-D rollup-plugin-babel@1，因为版本2和以上不再支持Babel 5。

引入promise polyfill，可以在前端使用promise异步，但是不能使用async，
因为会报错：RegeneratorRuntime is not defined。async解析成Regenerator，Regenerator是facebook写的东西，除非引入前端才可以使用。
async可以在服务器中使用，不能再前端使用

babel-polyfill和transform-runtime都是转化器

 Babel 5配置文件与您使用的Babel版本不兼容(6)
 Using removed Babel 5 option: foreign.modules - Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules

  npm WARN babel-loader@6.4.1 requires a peer of webpack@1 || 2 || ^2.1.0-beta || ^2.2.0-rc but none is installed. You must install peer dependencies yourself.

###gulp加上return，此错误消失
The following tasks did not complete: build-view
Did you forget to signal async completion?


<font color="red">browser-sync：</font>
在构建网站时，要同步多个浏览器和设备。
Browsersync的工作原理是，在初始请求的时候，在< body >标签的后面加上一个异步脚本标记(< script async >…< /脚本>)。为了使其正常工作，必须存在< body >标记。或者，您可以使用snippetOptions为代码片段提供一个定制规则。

随着每个web页面、设备和浏览器的出现，测试时间呈指数级增长。从重加载到URL推送，表单复制到单击镜像，Browsersync会减少重复的手工任务。这就像一双多余的手。从UI或命令行定制一个同步设置数组，以创建一个个性化的测试环境。需要更多的控制?Browsersync很容易与您的web平台、构建工具和其他node.js的项目集合。

Browsersync可以在工作时查看文件。您所做的更改将被注入到页面(CSS & images)中，或者将使所有浏览器都进行全页面刷新。
现有的vhost代理。Browsersync会用一个代理URL包装你的vhost来查看你的站点。
<font color="red">browser-synct：</font>
PostCSS- cssnext是一个PostCSS插件，它帮助您使用最新的CSS语法。它将CSS规范转换为更兼容的CSS，因此您不需要等待浏览器的支持。

<font color="red">merge-stream：</font>
合并(交错)一束溪流。

<font color="red">vinyl-source-stream：</font>
在您的gulp或乙烯管道开始时使用常规的文本流，从而与现有的npm流生态系统进行更好的互操作性。
例如,browserify。有gulp - browserify和gulpify插件，您可以将它与gulp结合使用，以便在构建中使用browserify。不幸的是，这些插件附带额外的开销:额外的GitHub存储库、npm模块、维护者、测试、语义等等。在这种情况下，直接使用原始模块就更简单了，这就是vinyl -source- stream句柄。

<font color="red">lazypipe：</font>
它的设计目的是在您想要重用部分管道的环境中使用，比如使用gulp。
这个模块返回一个可以用来开始构建lazypipe的函数。通过. pipe()方法添加各个步骤。在任何时候，可以通过添加一个现有的lazypipe而不影响之前的lazypipe来构建一个新的lazypipe。lazypipe甚至可以在另一个lazypipe中使用。一旦部分管道准备好使用，就将. pipe()的最后一个结果作为函数直接调用(例如:. pipe()())。

<font color="red">PostCSS：</font>
如果您使用其他基于PostCSS的工具，如cssnano，您可能希望使用gulp - PostCSS而不是gulp - autoprefixer来运行它们。它将会更快，因为CSS只对所有基于PostCSS的工具(包括自动修复程序)进行解析。
PostCSS插件来解析CSS，并使用可以使用的值向CSS规则添加供应商前缀。谷歌推荐使用，并在推特和淘宝上使用。
PostCSS 的主要功能只有两个：第一个就是前面提到的把 CSS 解析成 JavaScript 可以操作的 AST，第二个就是调用插件来处理 AST 并得到结果。因此，不能简单的把 PostCSS 归类成 CSS 预处理或后处理工具。
https://www.ibm.com/developerworks/cn/web/1604-postcss-css/

<font color="red">sourcemaps：</font>
首先，从名字可以看出sourcemaps是生成文件到源文件的一个映射，也就是sourcemaps记录了生成文件中的每一条语句在源文件中的对应位置
在html中引入生成的css文件，谷歌浏览器打开该html文件，我们就能够看到下图。
标红的部分可以看到对应的样式文件是scss，点击进入就能够找到这个样式对应在scss文件中的位置了。
调试起来就方便啦！ http://blog.csdn.net/xuyunfei_2012/article/details/52847988

<font color="red">gulp：</font>
gulp.src: 来源
gulp.dest: 目标
gulp.pipe: 管道
gulp.watch: 监视文件系统，文件改动时自动处理
gulp.task: 任务

<font color="red">gulp-plumber：</font>
自动处理全部错误信息防止因为错误而导致 watch 不正常工作。
简单地，它将替换管道方法，并在错误事件中移除标准onerror处理程序，默认这些错误事件是unpipes流错误。

<font color="red">gulp-changed：</font>
只编译修改过的文件，加快速度。

<font color="red">gulp-sass：</font>
sass({outputStyle: ‘compressed‘})方法里面有四种编译输出形式可以配置
nested 继承
compact 紧凑
expanded 展开
compressed 压缩

<font color="red">Cssnano：</font>
cssnano是PostCSS的CSS优化和分解插件。cssnano采用格式很好的CSS，并通过许多优化，以确保最终的生产环境尽可能小。

<font color="red">htmlmin:</font>
使用gulp-htmlmin压缩html，可以压缩页面javascript、css，去除页面空格、注释，删除多余属性等操作。

<font color="red">useref:</font>
使用gulp-useref来对html页面中的js，css引用进行合并，压缩等操作很简单。 

```
//useref ：把html中零碎的引入合并，不负责代码压缩
// gulp.task('images', () => {
//   return gulp.src('app/images/**/*')
//     .pipe($.cache($.imagemin()))         //使用gulp-cache只压缩修改的图片，没有修改的图片直接从缓存文件读取
//     .pipe(gulp.dest('dist/images'));
// });
```
