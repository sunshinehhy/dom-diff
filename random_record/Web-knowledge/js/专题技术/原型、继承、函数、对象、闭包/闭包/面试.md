## 闭包是什么？什么场景下我们需要闭包哦？

```
var foo = ( function() {
    var secret = 'secret';
    // “闭包”内的函数可以访问 secret 变量，而 secret 变量对于外部却是隐藏的
    return {
        get_secret: function () {
            // 通过定义的接口来访问 secret
            return secret;
        },
        new_secret: function ( new_secret ) {
            // 通过定义的接口来修改 secret
            secret = new_secret;
        }
    };
} () );

foo.get_secret (); // 得到 'secret'
foo.secret; // Type error，访问不能
foo.new_secret ('a new secret'); // 通过函数接口，我们访问并修改了 secret 变量
foo.get_secret (); // 得到 'a new secret'
```
之所以可能通过这种方式在 JavaScript 种`实现公有，私有，特权变量正是因为闭包`，闭包是指在 JavaScript 中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。

闭包是指在js中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回了之后。

面试时说：闭包是能够读取其它函数内部变量的函数。定义在一个函数内部的函数。闭包是将函数内部和函数外部连接起来的一座桥梁。是一个拥有父范围访问权限的函数。

需要注意的一点时，`内部函数访问的是被创建的内部变量本身，而不是它的拷贝`。所以在闭包函数内加入 loop 时要格外注意。
`闭包特性可以用于创建私有函数和方法`。

**关于为什么在 JavaScript 中闭包的应用都有关键词“return”，引用 JavaScript 秘密花园中的一段话：**

闭包是 JavaScript 一个非常重要的特性，这意味着当前作用域总是能够访问外部作用域中的变量。 因为 `函数 是 JavaScript 中唯一拥有自身作用域的结构`，因此闭包的创建依赖于函数。

作用域不想被污染，比如定义私有变量。jquey

https://zhidao.baidu.com/question/1303410499195176739.html （此链接说明闭包盲点）
## 闭包的用途 （面试点）
最大用处：
1. 可以读取函数内部的变量
2. 让这些变量的值始终保存在内存中

## 使用闭包的注意点 （面试点）
1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。
解决方法是，在`退出函数之前，将不使用的局部变量全部删除`。
2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），
把内部变量当作它的私有属性（private value），这时一定要小心，`不要随便改变父函数内部变量的值`。
（可以看以上例子foo.new_secret ('a new secret');，修改了内部变量的值）
```
　　function f1(){
　　　　var n=999;
　　　　function f2(){
　　　　　　alert(n); // 999
　　　　}
　　}
```
在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，
对f1就是不可见的。这就是`Javascript语言特有的"链式作用域"结构（chain scope），子对象会 "一级一级" 地向上寻找所有父对象的变量`。

## JQuery闭包与自调用方法
https://blog.csdn.net/gowhere_/article/details/78594552


```
var a = 4;
function myFunction() {
    a = 10;
}
alert(a);  //4
```
```
var counter = 0;

function add() {
    counter += 1;
}

add();
add();
alert(counter); //这时候显示2
```

使用全局变量的话，不仅add()可以改变它的值，其它方式也可以(比如调用counter的地方)，`不安全`。而且如果这`作为一个文件被别的页面引用的话，容易造成冲突`。
```
var add = (function () {
    var counter = 0;
    return function () {return counter += 1;}
})();

add();
add();
add();

// the counter is now 3
```
闭包就很好解决了前面几个例子遇到的问题： 
1. 需要注意的是这里使用了自调用函数，从而解决了counter的初始化。 
2. 用于计数的自调用函数返回并赋值到了add变量里，从而使函数可以被外界所访问。 
3. 而实现了以上功能之外，闭包可以使本该作为全局变量的计数器counter被匿名方法保护着“变成了私有”，不会被其它方式所改变。

##  jQuery中的"闭包"  (一直以来的盲点)
https://www.cnblogs.com/darrenji/p/3804993.html#d  （着重看，里面有jquery内存泄漏知识）

"闭包"在jQuery中最常见的应用是，当Document加载完毕再执行jQuery部分：
```
    <script type="text/javascript">
        $(document).ready(function() {
            var temp = 0;
 
            function innerFunction() {
                temp++;
                console.log(temp);
            }
 
            innerFunction();
            innerFunction();
        });
    </script>
结果：
1
2
```
可见，`$(document).ready()的参数就是一个匿名外部函数，匿名函数内的函数是内部函数。` 

## JavaScript闭包有可能会造成内存泄漏：

内部函数闭包引发的内存泄漏
```
    $(function() {
        var outerVal = {};
        function innerFunction() {
            console.log(outerVal);
        }

        outerVal.fn = innerFunction;
        return innerFunction;
    });
```
以上，outVal是在内存中的一个对象，而内部函数innerFunction同样是内存中的一个对象。对象outVal的属性fn指向内部函数，而内部函数通过console.log(outerVal)引用outVal对象，这样outVal和内部函数`存在循环引用的情况，如果不手动处理，就会发生"内存泄漏"`。

如果，我们在内部函数中不显式引用outerVal对象变量，会造成"内存泄漏"吗？
```
    $(function() {
        var outerVal = {};

        function innerFunction() {
            console.log('hello');
        }

        outerVal.fn = innerFunction;
        return innerFunction;
    });
```
答案是：`会的。因为，当内部函数被引用、调用的时候，即使内部函数没有显式引用外部函数的变量，也会隐式引用外部函数变量。`

→元素事件引发的内存泄漏

旧版本IE中存在一种难以处理的引用循环问题。当一个循环中`同时包含DOM元素和常规JavaScript对象时`，`IE无法释放任何一个对象`——因为这两类对象是由不同的内存管理程序负责管理的。换句话说，除非关闭浏览器，否则这种循环在IE中永远得不到释放。

在IE中，如下写法会造成内存泄漏：
```
$(document).ready(function(){
    var button = document.getElementById("btn");
    button.onclick = function(){
        console.log('hello');
        return false;
    }
});
 ```
当指定单击事件处理程序时，就创建了一个在其封闭的环境中`包含button变量`的闭包。而且，现在的`button也包含一个指向闭包（onclick属性自身）的引用`。这样，就导致了在IE中即使离开当前页面也不会释放这个循环。

`为了释放内存，就需要断开循环引用`，例如在关闭窗口并删除onclick属性（此时必须注意不要在window及其onunload处理程序间引入新的循环）。另外，也可以像下面这样重写代码来避免这种闭包：

而如下JavaScript写法不会造成内存泄漏：
```
function hello(){
    console.log('hello');
    return false;
}
 
$(document).ready(function(){
    var button = docuemtn.getElementById('btn');
    button.onclick = hello;
});
 ```
因为hello()函数不再包含button，`引用就成了单向的`（从button到hello）、不存在的循环，所以就不会造成内存泄漏了。

而在jQuery中，类似的写法就不用担心内存泄漏了，`因为jQuery为我们做了自动处理来规避内存泄漏`。
```
$(document).ready(function(){
    var $button = $('#btn');
    $button.click(function(event){
        event.preventDefault();
        console.log('hello');
    });
});
```
`当对DOM元素进行其他操作时，仍然要处处留心。`只要是将JavaScript对象指定给DOM元素，就可能在旧版本IE中导致内存泄漏。jQuery只是有助于减少发生这种情况的可能性。
有鉴于此，`jQuery为我们提供了另一个避免这种泄漏的工具。``使用.data()方法可以像使用扩展属性（expando）一样，将信息附加到DOM元素。`由于这里的数据并非直接保存在扩展属性中（jQuery使用一个内部对象并通过它创建的ID来保存这里所说的数据），因此永远也不会构成引用循环，从而有效回避了内存泄漏问题。无论什么时候，当我们觉得扩展属性好像是一种方便的数据存储机制时，都应该首选.data()这种更安全可靠的替代方案。

## JQuery内存泄露解决办法

- 如果采用此方式多次生成jquery对象的话，html代码字符串会在内存中多次重复，占用额外的内容，也会有泄露。而$("<span></span>").attr('id',_id)写法无此问题。
 ```
 $.lui.widget.__clean$ = $("<span id='" + $.lui.newGuid()+ "'></span>");
 ```


 - 释放jquery对象，无返回值。此方法用以解决jquery的内存泄露问题

  ```
 $.fn.del = function( selector, keepData ) {
 if ( !selector || $.filter( selector, [ this ] ).length ) {
  // 释放dom对象
  var item = $(this);
  item = null;
 }
 };
 ```

 ## 我的总结
 闭包不一定会造成内存泄露。一般循环引用会导致内存泄露，比如上面button点击事件。button是dom元素，button指向onclick，onclick闭包可以引用button，这样会造成泄露。