85 320
https://thoughts.teambition.com/workspaces/5bd9593e1dfebf0001dc92e3/docs/5c74b8285c39fa00010502a5 (技术债)

https://lanhuapp.com/web/#/item/project/board?pid=e3f1c09a-a393-4736-90db-bb69cdbabfba (H5 设计图)

https://www.teambition.com/project/5bc579e448e15000192134ab/plugin/5b1dd4ca2e5238267d239400 （需求文档）

https://igetcool-share.igetcool.com/Active/homeCombination?groupSellPid=306645051084763136&t=28&activityPid=306665752239788032

http://localhost:8080/Active/receiveSuccess?h5Pid=305208713568198656

http://localhost:8080/Active/homeActivity?h5Pid=305208713568198656

http://localhost:8080/Active/homeCombination?groupSellPid=303246781923565568&t=28&activityPid=306665752239788032

活动未完成，未结束 ———— 分享和价格
活动已完成，未结束 ———— 分享和进入书房听
活动已完成，已结束 ———— 进入书房听
活动未完成，已结束 ———— 已结束

在 app 中还是在微信中。

http://test1-3.igetcool.com/Active/homeActivity?h5Pid=305208713568198656

305208713568198657
305208713568198659

http://localhost:8080/Active/activityToPullNew?h5Pid=305208713568198657&activityPid=274776648210878464

http://test1-3.igetcool.com/Active/activityToPullNew?h5Pid=305208713568198657&activityPid=274776648210878464

13800138000

状态 4 也能打开，但是请求没有值，如果是 1 的话获得值，但是再请求一次就是 4 了。

https://blog.csdn.net/qq_37231097/article/details/76614702

微信中 h5 输入键盘挡住

不管用 router.push 还是 window.location.href 方式，刷新还是会跳到第一页面

input 框中将 type = text 改成 number , (安卓可以调起), ios 也可以调起需要加上 parttern = "\d\*"

<input class="money-p" type="text"></p>
改成: 
<input class="money-p" type="number" pattern="\d*"></p>

os 移动端 软键盘收起后，页面内容不下滑
https://www.jianshu.com/p/0953157ca407
if(\$event.target.value.length>11) {value=value.slice(0,11)}
input 标签 type 为 number,属性 maxlength 无效

报错：
{“line”:68791,”column”:125,”sourceURL”:”http://localhost:8080/build/vendor.js”}

操作太频繁和弹框会交叉

-解决弹出蒙层滑动穿透问题

12300001109

- 阀值 100
- 电话号码限制
- 打开 app 路由
- 样式修改
- 输入框必须失去焦点，才能唤起值
- 音频继续测试
- 领取状态（活动前）

1s 只能不能再点击
第一次能触发，
setTimeout

不是只调用一次，是判断如果弹出，就不弹了

老版本可以刷，意味着还得请求 2 次，如果是老版本就执行 2 遍。因为获取不到 userid
总之刷新不能用 doGet
假如领取成功了，换个未升级的版本，第一次 userId 还是可以的

到技术一遍
老版本：出现刷新，必须要执行函数
新版本：不会出现刷新，所以不需要再加一个函数，(只是 userId 的区别，客户端没有 unserid 就)
判断一下是否在倒计时

当返回的时候不能执行 doLogin，当刷新的时候不能执行 doGet。登录之后，返回不刷新页面，进入 H5 二级页面，会刷新页面。

老版本：
刷新（会运行 mounted）但不能用 doGet(获取不到 userid)则 getData 不会执行，（可以避免 2 次倒计时）
当返回的时候（会运行 mounted），能获取到 userid，可以不执行 getData(涉及不到 2 个倒计时函数同时运行)
考虑刚进入和刷新的情况：
刚进入，会请求 2 次，（需要避免请求 mounted)
刷新因为不会执行 doGet（获取不到 userID），会请求 1 次 mounted
其实刷新和刚进入执行的逻辑一样，只不过是能不能获取到 doGet。

新版本：
当返回的时候（会运行 mounted），能获取到 userid，可以不执行 getData(涉及不到 2 个倒计时函数同时运行)

在登录状态，会请求页面，
在没登录状态下，也会再次请求页面。
判断在老版本的情况

老版本刷新，登录的情况，如果已经领取成功，这时候获取不到 userId，下面按钮会变化（验证 doLogin 是否能获得）。
不登录的情况下，显示没问题。

新版本没有刷新。

H5 页面返回，肯定是升级了版本，这样会变成新版本。所以只需要考虑刷新。

判断能不能获取到 doGet，如果有就不执行，如果没有就执行 mounted 额外的值

- 返回刷新页面了，再返回锚点的地方，获取被点击的值。
- 样式调整
- 输入框按钮动作

先是获取被点击的标签，定义被点击的 key，当点击的时候赋值

刷新页面，不仅该请求页面，又要获取 userid，在请求失败的时候请求 id

刷新的时候，还是会执行 doGet，需要强制不能执行

返回和第一次进入分别判断，如果第一次进入，index 为-1，如果点击获取从哪里来的 key

因为返回获取不到 userid，就去调用登录状态，但是又不能触发 doGet，所以报错，所以调不起来，除非加上 doLogin，但是还是有一些问题

**思路**
从 banner 中进入、刷新、登录成功之后返回都会调用 doLogin（我可以在 doLogin 里写刷新页面），但是二级 H5 页面返回不会调用 doLgoin，会调用 doGet(可以在 doGet 里写刷新页面)，因为从 banner 中进入既会执行 doLogin 又会执行 doGet，从而导致会执行 2 遍刷新（因为我没法判断从哪里进来的）。因此，我需要一个条件判断从哪里进到免费听 H5 页面中。

我需要登录之后能够自动刷新页面，看组合购买的逻辑好像强制让人去
600/750 = 80%

高度:368
文字：45
按钮：80\*320
按钮到文字：101px

（368-（228+20）-80 ）/2= 368-248-80
按钮底部到下边框：40px
按钮上部到上边框：248
文字上到上边框：102
文字高度：45
关闭：60\*60

总长度 600：
（600-320）
框的百分比：320/600 = 53.333%
文字上——按钮上(101+45)
(101+45) /80 = 1.825
文字上——关闭按钮：42 0.236
42/80=0.525
按钮和关闭按钮比例：60/80=0.75

按钮下——边界下 40/80= 0.5
按钮：0.45
底部：0.225
文字上——按钮上:0.45
文字上——关闭按钮：0.236
关闭按钮大小：0.3375

**默认进去的 0 元领取倒计时样式**
领取按钮：86px 0.5
按钮下——外框下：49px 0.28
按钮上——第一行文字下：109 第一行文字：45 0.262
按钮上——第二行文字下：43（离最低点） 49（离最高点） 0.28
第一行文字上——外框上：31 0.18
第一行文字下——第二行文字上：21(离最高点) 27(离最低点) 0.16

验证从哪里点击进入 H5 页面
checkEnterPlace(place)
place：

- banner 0
- popup 1
- push 2
- h5 3
  看看哪里还有缺的

```
.img-container {
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  bottom: 1.55rem;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}
```

## 开会讨论各端优化实现问题

doGet 方式，所以多了一种获取 id 的方式。有没什么办法任何时候都能执行 doLogin

能把一些解决问题推进就不错了。
链接进入 H5 页面，返回刷新页面，
我自己也在摸索，介于时间的原因，就都暂时延期。

以后问问题，要追问到底，不然觉得

对于牛人
对于不熟悉人

返回得刷新页面，因为领取人数得需要更新。

<!-- 去除刷新，因为刷新会导致进入分享记录页， -->

其实从 banner 进去，刚进入直接用 userId 判断就行，如果没有 userId 就直接跳转到登录页面。
从 H5 页面进入 H5 页面：
想一个办法把 userId 保存到 cookie 里，如果 cookie 里没有就去登录，（可以用 cookie 来解决这个问题。）

- 用 push
  返回不会调用 doLogin，但会调用 doGet（为什么要用 auth 接口？），尽管登录，如果仅仅用 doLogin，也会获取不到 userid（cookie 可以解决）。

返回只能刷新页面了。如果解决定位问题，得知道从哪里进来的。因为从 banner 进去还得知道（这个事情因为说暂时不考虑，我就没有说这事）

- 用原生路由
  返回也会有个函数，类似于登录进来给个函数（这样我们能调用一个函数）

## 我的思考

当时觉得刷新一下能解决问题，按照那个逻辑做，最终产品发现体验不好

### 我的问题

当时也是考虑到时间问题，然后就在已有的基础上去想各种能跑通的逻辑，着急去解决其他问题，当时沟通过这个问题，其实想清楚了

当时跟后端联调的时候。
我记得是进入页面的时候不会执行 doGet，点击按钮可以，但后面去尝试发现进入页面也会执行。因为安卓没有这个功能，

觉得一直是以组合购买的逻辑来解决问题，但是在它基础上再加上了新的东西，会产生新的问题，

我觉得做什么过程中，需要去多问一句，为什么要这个，然后让客户端知道这个逻辑，沟通起来更顺畅。我去找解决问题，希望也能记住这事，假如没有时间忙完也能来一起讨论。

因为之前忙于解决 bug，没有深入思考这些问题。

## 延期处理点（包含兼容性问题、功能性、优化）

【前端-兼容性】某一设备 qq 二次分享，分享信息错误
【前端-兼容性】某一设备领取成功页进去后，底部会有 2 厘米上一页图片展示 (可解决)
【前端-兼容性】某一设备点击输入框，输入框和键盘之间有 5 厘米图片间隔
【前端-兼容性】某一设备从领取成功页回到待领取页。之前的播放进度还在，播放按钮回到原点
【前端-兼容性】某一设备点击 input 弹出软键盘，会出现穿透问题
【前端-优化】代码逻辑优化（需要客户端配合）
【前端-功能性】返回保留原来位置定位功能（需要客户端配合）
【前端-优化】埋点（需要产品确定好以后方案，现在临时是 ip）
【安卓-优化】断网切换音频播放，通知栏是播放状态
【安卓-优化】H5 页点击音频进入播放器播放，在 H5 页面连续点击暂停播放，音频进度回到起始的位置
【安卓-功能性】网络状态监测
【IOS-优化】播放小王子，锁屏，点击暂停，再播放，偶尔会出现从 0 开始播放
【IOS-优化】没登录的时候，点击活动页图片，路由到课程列表，页面卡住
【IOS-优化】分享弹框多次出现
【IOS-功能性】网络状态监测
我整理出延期处理问题，看还有什么需要补充的。
需要客户端配合的，找时间一起讨论解决方案。

如果用 this.\$router.push ，微信下面有底部 bar；如果用 this.\$router.replace，微信下面没有底部 bar。这样总结还是得用 push

因为 position:fixed 的 bottom 固定死，所以滚动内容，下面的内容也滚不上去

在弹起键盘的时候，手动滚动 H5，然后键盘偶现被遮挡
iphoneX 拉到底会先上后下

饿了吗？会出现上下箭头

145 版本没有 doLogin
电脑上是 document.documentElement.scrollTop

手机上是 document.body.scrollTop

inputNumberFocus(e) {
if (e.target !== e.currentTarget) {
return;
}
let imgContainer = document.querySelector(".img-container");

      if (getDeviceType() === "IOS") {
        // window.scrollTo(0, document.documentElement.scrollTop + 1000); //解决第三方输入法，input被遮挡住
        // setTimeout(function() {
        // window.scrollTo(0, document.body.clientHeight);
        // }, 100);

        let inputBottom = document.querySelector(
          ".input-bottom-bar-containter"
        );
        // inputBottom.style.bottom = "100px";document.body.clientHeight
        // inputBottom.scrollIntoView(); //好像加了它，我的手机滚动都出问题了
      }

      // console.log(imgContainer.offsetHeight);
      // console.log(document.body.scrollTop); //这个一直是0
      // console.log(document.documentElement.scrollTop);
      if (document.documentElement.scrollTop) {
      }
      this.distance =
        document.body.scrollTop || document.documentElement.scrollTop;
      console.log(this.distance);
    },
    /**
     * 功能：只要失去焦点，就滚下去。可以解决第三方输入法，input被遮挡住（我认为是）
     */
    inputNumberBlur(e) {
      let ua = window.navigator.userAgent.toLowerCase();
      if (ua.indexOf("iphone") > -1 || ua.indexOf("ipad") > -1) {
        // window.scrollTo(0, 0);
        // let distance = document.documentElement.scrollTop;
        // document.documentElement.scrollTop = document.documentElement.scrollTop;
        // if (distance < 0) {
        //   distance = 0;
        // }
        // alert(document.body.scrollTop);
        // alert(document.documentElement.scrollTop);
        // alert(this.distance);
        window.scrollTo(0, this.distance);
      }
    },


    @scroll="scrollImg($event)"
    style="overflow:scroll;height:100%; -webkit-overflow-scrolling: touch !important;"


     inputNumberFocus(e) {
      if (e.target !== e.currentTarget) {
        return;
      }
      this.distance =
        document.body.scrollTop || document.documentElement.scrollTop;
      this.distance = this.distance;
      // if (this.distance < 0) {
      //   this.distance = 0;
      // }
      let imgContainer = document.querySelector(".img-container");
      let inputBottom = document.querySelector(".input-bottom-bar-containter");
      let bottom = inputBottom.getBoundingClientRect().bottom;

      let rh = this.distance + screen.height - imgContainer.offsetHeight;
      if (rh > 0 && rh <= 88) {
        inputBottom.style.bottom = "1.5rem";
      }
      // alert(inputBottom.style.bottom);
      // alert(imgContainer.offsetHeight);
      // inputBottom.style.bottom = "110px";
      // imgContainer高度-屏幕高度
      // setTimeout(() => {}, 100);
      // this.interval = setTimeout(function() {
      // document.body.scrollTop = 1000;

      // }, 500);
      // var target = e.target;
      // setTimeout(function() {
      // target.scrollIntoViewIfNeeded();
      // window.scrollTo(0, imgContainer.offsetHeight - 100);
      // }, 200);
      // setTimeout(function() {
      // document.documentElement.scrollTop = document.documentElement.scrollTop;
      // document.body.scrollTop = document.body.scrollTop;
      // }, 300);
    },
    /**
     * 功能：只要失去焦点，就滚下去。可以解决第三方输入法，input被遮挡住（我认为是）
     */
    inputNumberBlur(e) {
      // let inputBottom = document.querySelector(".input-bottom-bar-containter");
      // inputBottom.style.bottom = 0 + "px";
      // 加setTimeout是为了延迟滑动，不然导致zeroReceive失效
      setTimeout(() => {
        let ua = window.navigator.userAgent.toLowerCase();
        if (ua.indexOf("iphone") > -1 || ua.indexOf("ipad") > -1) {
          window.scrollTo(0, this.distance);
        }
      }, 10);
    },

https://segmentfault.com/a/1190000006243816

https://blog.csdn.net/m0_37852904/article/details/79523570

https://blog.csdn.net/qq_19674905/article/details/80552812 (一年多才解决)

## 以后该样式

不用滚到最底端，这样就解决了第三方的问题
let imgContainer = document.querySelector(".img-container");
let inputBottom = document.getElementById("inputBottom");
let bottom = inputBottom.getBoundingClientRect().bottom;
window.scrollTo(0, imgContainer.getBoundingClientRect().bottom + 500);
inputBottom.style.position = "absolute";
imgContainer.style.position = "relative";

inputNumberBlur(e) {
let imgContainer = document.querySelector(".img-container");
let inputBottom = document.getElementById("inputBottom");
inputBottom.style.position = "fixed";
imgContainer.style.position = "static";
// 加 setTimeout 是为了延迟滑动，不然导致 zeroReceive 失效
setTimeout(() => {
let ua = window.navigator.userAgent.toLowerCase();
if (ua.indexOf("iphone") > -1 || ua.indexOf("ipad") > -1) {
window.scrollTo(0, this.distance);
}
}, 10);
}

<!-- <input
  @focus="inputNumberFocus"
  @blur="inputNumberBlur"
  type="tel"
  ref="inputNumber"
  maxlength="11"
  min="0"
  max="99999999999"
  @input="numberValue=$event.target.value.replace(/\D/g,'')"
  v-bind:value="numberValue"
>-->

type="tel"发现有些设备不会调用第三方输入法

https://h5.ele.me/login/?from=singlemessage&isappinstalled=0#from=wechat_bind&redirect=https%3A%2F%2Fh5.ele.me%2Fhongbao%2F%3Ffrom%3Dsinglemessage%26isappinstalled%3D0&authcode=011kolkR141CW21KDfkR1YdmkR1kolkB （饿了吗输入框研究）

## 最终总结

对于输入框碰到兼容性问题多
对于 ios 和 android 的函数用法不清晰，跟客户端沟通时间多，以后应该穷追不舍的问清楚。
了解客户端函数功能和版本不同点耗时多

H5 1.4.7 影响说明：

1. 分享后的页面

- 修改原因：为了解决兼容性问题
- 修改范围：修改聚焦和失焦输入框的逻辑，并且 非 app 中 ios 设备中改了体验逻辑
- 测试点：键盘弹起、聚焦和失焦输入框、领取的整个操作逻辑、按钮文案
- 忽略点：当有光标错位问题时，点击【确定提交】按钮，软键盘消失，需要再次点击按钮(系统导致的，穿透问题由此引起，可忽略)

2. 分享记录页

- 修改原因：为了提高弹出分享框速度
- 修改范围：从点击【立即邀请好友】弹出分享框，把从后台获取数据改成进入页面就获取（逻辑跟活动页同步，也就是【立即 0 元领取】逻辑一致）
- 测试点：分享出去数据是否正确

3. app 内按钮显示状况

- 测试原因：因为控制 ios 和 android 中的在非 app 中逻辑不一致，担心不小心，稍微看看

4. ios 低版本刷新之后的情况

- 测试原因：删了几行没用的代码，刷新后数据能正常显示就 ok

ios 第三方键盘弹跳一下

如果有 2 位数怎么办
OSVision.replace("\_", "") 仅仅替换的是第一个
如果是 2 位数，如果是 3 位数
11_4
12_0
建年是否大于哪个版本
如果第一个小数点之前大于 2 位数，并且小于 12

getOSVersion() {
// 获取操作系统版本
let splitVersion = [];
var OSVision = "1.0";
var u = navigator.userAgent;
var isAndroid = u.indexOf("Android") > -1 || u.indexOf("Linux") > -1; //Android
var isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios 终端
if (isAndroid) {
OSVision = navigator.userAgent.split(";")[1].match(/\d+\.\d+/g)[0];
OSVision = Number(OSVision.replace(".", ""));
splitVersion = OSVision.split(".");
}
if (isIOS) {
OSVision = navigator.userAgent
.split(";")[1]
.match(/(\d+)_(\d+)_?(\d+)?/)[0];
splitVersion = OSVision.split("\_");
}
return splitVersion;
},

    if (isIOS) {
      let splitVersionArr = this.getOSVersion();
      if (splitVersionArr[0] < 12 && splitVersionArr[1] < 4) {
        this.hasCursorDislocation = true;
      }
    }
