## ES6:
#### 函数的扩展
<http://es6.ruanyifeng.com/#docs/function>
+ ES6允许为函数的参数设置为默认值，函数参数是默认声明的；
+ 好处：阅读代码的人可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档。有利于将来的代码优化，即使未来的版本彻底拿掉这个参数，也不会导致以前的代码无法运行。
+ 与结构赋值默认值结合使用


         ```
        function foo({x, y = 5}) {
          console.log(x, y);
        }

        foo({}) // undefined 5
        foo({x: 1}) // 1 5
        foo({x: 1, y: 2}) // 1 2
        foo() // TypeError: Cannot read property 'x' of undefined

        ```

    上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错

+ 有默认值的参数都不是尾参数
    如果传入undefined，将触发该参数等于默认值，null则没有这个结果
+ 函数的length属性：没有指定默认值的参数个数，指定默认值的参数会失真，不会计入；restc阐述也不会计入
+ 作用域：如果参数默认值是一个变量，则先是当前函数的作用域，然后才是全局作用域。它与其他变量的作用域规则时一样的。
+ rest的参数之后不能再有其他参数，rest参数搭配的变量是一个数组
+ 扩展运算符是三个点（...），将一个数组转为用逗号分隔的参数序列，它可以替代数组的apply方法
    - 如果将扩展云算法用于数组赋值，只能放在参数的最后一位
    - 涉及到操作32位和64位的字符，最好用扩展运算符
    - 任何类似数组的对象都可以用扩展运算符转为真正的数组
    - 扩展运算符内部调用的是数据结构的iterator接口，因此只要具有iterator接口的对象，都可以使用扩展运算符，比如Map结构
    - 如果对没有iterator接口的对象使用扩展运算符，将会报错
+ name属性：函数的name属性返回该函数的函数名。
+ 箭头函数：
    * 函数内的this对象就是定义时所在的对象，而不是使用时所在的对象。
    * 不可以当做构造函数。也就是说，不可以使用new命令，否则会抛出一个错误。
    * 不可以使用argumentd对象，该对象在函数体内部存在。如果要用，可以用rest参数代替。
    * 不可以使用yield命令，因此箭头函数不能用在generator函数。
    * 箭头函数的几个不存在变量：arguments\super\new target
    * 箭头函数没有自己的this，当然就不能使用call()、apply()、bind()
    * 箭头函数内部还可以使用箭头函数
+ 函数的绑定:
    * 函数绑定运算符是并排的双冒号（：：），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象作为上下文环境绑定到右边的函数上。
    * 如果双冒号左边为空，右边是一个对象的方法，则等于将方法绑定在该对象上。
    * 由于双冒号运算符返回的还是原对象，因此可以采用链式写法。
+ 尾调用优化:
    * 尾调用指某个函数的最后一步是调用另一个函数。
    * 尾调用不一定出现在函数尾部，只要是最后一步操作就可。
    * 尾调用优化：只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时调用帧只有一项，这将大大节省内存。
    * 尾递归：函数调用自身称为递归，如果尾调用自身就称为尾递归
    * 尾调用只在严格模式下有效，它对递归操作意义重大。
    * 允许函数的最后一个参数有尾逗号


**rest参数**

// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}
arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。

// rest参数的写法
const sortNumbers = (...numbers) => numbers.sort();
rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。
```
function push(array, ...items) {
  items.forEach(function(item) {
    array.push(item);
    console.log(item);
  });
}

var a = [];
push(a, 1, 2, 3)
```
rest 参数之后不能再有其他参数（即只能是最后一个参数）。
函数的length属性，不包括 rest 参数。
只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。

**name属性**

- 如果将一个`匿名函数赋值给一个变量`，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。
- 如果将一个`具名函数赋值给一个变量`，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。
- Function构造函数返回的函数实例，name属性的值为anonymous。
- bind返回的函数，name属性值会加上bound前缀。
```
var f = function () {};

// ES5
f.name // ""

// ES6
f.name // "f"
```

**箭头函数**

- 如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。
- 箭头函数可以与变量解构结合使用。
- 箭头函数使得表达更加简洁。
- rest 参数与箭头函数结合
- 箭头函数可以与变量解构结合使用
- 箭头函数可以很方便地改写 λ 演算。

#### 对象的扩展

+ 属性的简洁表示法:
    * ES6允许直接如屑变量和函数作为对象的属性和方法。
    * 允许在对象中只写属性名，不写属性值。
+ 属性名表示法:
    * 一是直接用标识符作为属性名；方法二是用表达式作为属性名，这事要将表达式放在方括号内。
    * 属性名表达式与简洁表示法不能同时使用。
    * 表达式还可以用于定义方法名。
+ 方法的name属性:同函数的name属性
+ 方法：
    * Object.is():比较两个值是否严格相等
    * +0===-0 //true    
    * Object.is(+0,-0) //false
    * NaN===NaN //false
    * Object.is(NaN,NaN)//true
    * Object.assign()将源对象的所有可枚举属性复制到目标对象。
    * Object.assign()如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。
    * Object.assign()只复制自身属性，不可枚举的属性和继承的属性不会被复制
    * Object.assign()属性名为Symble值的属性，也会被复制
    * Object.assign()对于嵌套的对象，是替换，而不是添加，浅复制
    * Object.assign()可以处理数组，但是会将其视为对象
    * Object.assign()可以为对象添加属性和方法
    * 尽量不要用for...in循环，而用Object.keys()替代；因为Object.keys()只遍历自身的所有可枚举属性的键名，而for...in还会遍历继承的可枚举属性。
    * 使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替，不要使用_proto__属性。



#### Module

+ CommonJS
    * require()方式,require 是同步的，只适用于服务器。
    * 用户服务器
    * 输出的是一个值的拷贝，加载时执行
    * 循环加载原理：一个CommonJS模块就是一个脚本文件，加载时执行，即脚本代码在require时就会全部执行。
    * 一旦出现某个模块被“循环执行”，就只输出已经执行的部分，还未执行的部分不会输出。
+ ES6模块：设计思想是尽量静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。
    * import  export
    * 输入时采用静态命令的形式
    * 效率比CommonJS模块的加载方式高
    * 不再需要UMD模式格式
    * export命令可以出现在模块的任何位置，只要除于模块顶层即可。如果处于块级作用域内，会报错。
    * export语句输出的值是动态绑定的，绑定其所在的模块
    * 优先考虑大括号输出一组变量
    * import命令具有提升效果，会提升到整个模块的头部首先执行
    * module命令可以取代import语句，达到整体输入模块的作用
    * export default输出的，import命令后面不使用大括号并且可以自己定义任意名称指向输出的方法，否则需要使用大括号
    * 一个模块只能有一个默认输出
    * 输出的是值的引用，需要开发者自己保证真正取值时能够取到值
+ AMD(Asynchronous Module Definition)：异步加载，在服务器和浏览器都可以运行
    * 主要有两个Javascript库实现了AMD规范：require.js和curl.js。

+ CMD 
    * 如何实现一个 CMD 模块加载器：http://annn.me/how-to-realize-cmd-loader/

#### Promise 对象

[ES6-Promise](https://segmentfault.com/a/1190000006557624)

Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。