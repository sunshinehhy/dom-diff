 ## JS 原型与原型链
https://www.jianshu.com/p/dee9f8b14771  (一)
https://www.jianshu.com/p/652991a67186  (二)
https://www.jianshu.com/p/a4e1e7b6f4f8  (三)


`实例的构造函数属性（constructor）指向构造函数，这个属性是一个指针。`
比如Person为构造函数
  console.log(person1.constructor == Person); //true

`每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性。`
`每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象。`
```
Person.prototype = {
   name:  'Zaxlct',
   age: 28,
   job: 'Software Engineer',
   sayName: function() {
     alert(this.name);
   }
}
```
`原型对象就是 Person.prototype` ，如果你还是害怕它，那就把它想想成一个字母 A： var A = Person.prototype。
在默认情况下，所有的原型对象都会自动获得一个 constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person）。

`Person.prototype.constructor == Person`

person1.constructor == Person（实例的构造函数属性（constructor）指向构造函数）

Person.prototype （你把它想象成 A） 也是Person 的实例。

原型对象（Person.prototype）是 构造函数（Person）的一个实例。

null不是一个空引用, 而是一个原始值。null 有 _proto_。

*这个连接存在于实例（person1）与构造函数（Person）的原型对象（Person.prototype）之间，而不是存在于实例（person1）与构造函数（Person）之间。*

JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个`叫做__proto__ 的内置属性，用于指向创建它的构造函数的原型对象。`
```
person1.__proto__ === Person.prototype
Person.__proto__ === Function.prototype

typeof Number/String/Boolean/Data/Array/Function/Object
 // "function"   这些构造器都是函数对象
NumberString/Boolean/Data/Array/Function/Object/RegExp/Error.constructor == Function   
//true

Person.prototype.__proto__ === Object.prototype
Object.prototype.__proto__ === null

因为 person1.__proto__ === person1 的构造函数.prototype
因为 person1的构造函数 === Person
所以 person1.__proto__ === Person.prototype

因为 Person.__proto__ === Person的构造函数.prototype
因为 Person的构造函数 === Function
所以 Person.__proto__ === Function.prototype

Person.prototype 是一个普通对象，我们无需关注它有哪些属性，只要记住它是一个普通对象。
因为一个普通对象的构造函数 === Object
所以 Person.prototype.__proto__ === Object.prototype

Object.prototype 对象也有proto属性，但它比较特殊，为 null 。因为 null 处于原型链的顶端，这个只能记住。
Object.prototype.__proto__ === null

 Person 和 Object 一样都是构造函数

 所有函数对象的proto都指向Function.prototype，它是一个`空函数`（Empty function）
```
总结：
 原型和原型链是JS实现继承的一种模型。
 原型链的形成是真正是靠__proto__ 而非prototype

```
 Function.prototype
 ƒ () { [native code] 
```
 ## 几个函数的用法区别
 
**valueOf()**:
- valueOf() 方法返回 Array/ Boolean等对象的原始值。
- 该原始值由对象派生的`所有对象继承`。
- valueOf() 方法通常由 JavaScript `在后台自动调用，并不显式地出现在代码中`。
- 注意： valueOf() 方法不会改变原数组。
```
class A {}

class B extends A {
  constructor() {
    super();
    console.log(super.valueOf() instanceof B); // true
  }
}

let b = new B();
super.valueOf()表明super是一个对象，因此就不会报错。
同时，由于super使得this指向B，所以super.valueOf()返回的是一个B的实例。
```
**getPrototypeOf()**

 `Object.getPrototypeOf方法可以用来从子类上获取父类`。可以使用这个方法`判断，一个类是否继承了另一个类`。
比如：Object.getPrototypeOf(ColorPoint) === Point  // true

Object.getPrototypeOf(person1) === Person.prototype  // true

**setPrototypeOf()**

Object.setPrototypeOf = function (obj, proto) {
  obj.__proto__ = proto;
  return obj;
}

Object.setPrototypeOf(B.prototype, A.prototype);

**isPrototypeOf()**
判断是否存在关系（什么关系呢？专业词汇还不知道怎么描述）

Person.prototype.isPrototypeOf(person1)   //true

**hasOwnProperty()**
- `检查一个属性是存在于实例中，还是存在于原型中`。
- 这个方法是从Object继承来的。
- 只在给定属性`存在于对象实例中时，才会返回true`。


http://blog.csdn.net/mr_wuch/article/details/70318818

```
o = new Object();
o.prop = 'exists';
o.hasOwnProperty('prop');             // 返回 true
o.hasOwnProperty('toString');         // 返回 false
o.hasOwnProperty('hasOwnProperty');   // 返回 false
```
**in**
- `无论是存在于对象实例中还是原型中，都返回true`。
- 同时使用hasOwnProperty()和in，`判断对象是否存在实例中或者是否存在原型中`

**Object.keys()**
- 接受一对象作为参数，返回包含所有可枚举属性的字符串数组。
- 不用for-in的原因：
  1. 有些浏览器把不可枚举属性（即Enumerable为false）的实例属性也会循环出来，ie浏览器不会循环出来。

**getOwnPropertyNames()**
如果想得到`所有实例属性`，`无论它是否可枚举`，都可以使用Object.getOwnPropertyNames()方法。

**defineProperty()**
es有两种属性：数据属性和访问器属性。



  + **数据属性**
描述其行为的特征：[[Configurable]]、 [[Enumerable]]、[[Writable]]、 [[Value]]

defineProperty()是修改数据属性的默认特性
此方法接受三个参数：属性所在的对象、属性的名字和一个描述符对象。
描述符对象的属性必须是：configurable、enumerable、writable、value

可以多次调用Object.defineProperty()修改同一属性，但`把configurable特效设置为false之后就会有限制`。
在调用Object.defineProperty()方法`创建一个新的属性`时，如果不指定configurable、enumerable、writable，它们的`默认值都是false`。如果调用此方法是`修改已定义的属性的特性`，则`无此限制`。

  + **访问器属性**
特征：[[Configurable]]、 [[Enumerable]]、[[Get]]、 [[Set]]
访问器属性不能直接定义，必须使用Object.defineProperty()来定义。

在`不支持Object.defineProperty()方法的浏览器中不能修改[[Configurable]]、 [[Enumerable]]`

 + **兼容性考虑（待确定？）**
在ie8下只能在DOM对象上使用，尝试在原生的对象使用 Object.defineProperty()会报错。

**defineProperties()**
接受2个对象参数：
1. 第一个对象是要添加和修改其属性的对象
2. 第二个对象的属性与第一个对象中要添加或修改的属性一一对应

**getOwnPropertyDescriptor()**
- 取得给定属性的描述符。这个方法接收2个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象。
- 如果是访问器属性，这个对象的属性有：configurable、 enumerable、get、 set
- 如果是数据属性，这个对象的属性有：configurable、 enumerable、writable、value

## 更简单的原型语法，但引起的问题
- 每创建一个函数，就会同时创建它的prototype对象，这个对象也会自动获取constructor属性。如果用简单原型语法，本质上完全重写了默认的prototype对象。
- 如果Person.prototype设置为等于一个以对象字面量形式创建的新对象。最终结果相同，但有一个例外：`constructor属性不再指向Person了`
- 以添加constructor:Student方式，会`导致enumerable特性设置为true`
- 默认情况下，原生的constructor属性是不可枚举的，因此`可以使用Object.defineProperty()`
- 实例中的指针仅指向原型，而不指向构造函数
- 重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型

```
  function Person(){
                                  
  }
 //简单原型语法，没有分开写
  Person.prototype={
      *constructor:Student,*  //如果特意设置，person1.constructor==Person会变为true
      name:'yjj',
      age:15,
      myName:function (){
          alert(this.name);    
          
      }                
  }
  //简单原型写法本质上完全重写了默认的prototype对象,因此construtor属性也就变成了新对象的constructor属性,指向了object构造函数，不再指向Student函数。
  //通过constructor已经无法确定对象类型了
  var person1 = new Person();
  alert(person1 instanceof Object);//true
  alert(person1 instanceof Person);//true
  alert(person1.constructor==Person);//false
  alert(person1.constructor==Object);//true 
```
```
Object.defineProperty方式：

Object.defineProperty(Person.prototype,"constructor",{
  enumerable:false,
  value:Person
});
```
