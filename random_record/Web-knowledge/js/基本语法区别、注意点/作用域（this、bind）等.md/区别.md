## call,apply 和 bind 的区别

它们在功能上是没有区别的，都是改变 this 的指向，它们的区别主要是在于`方法的实现形式和参数传递上的不同`。

最大的区别就是`bind绑定this指向并传参后仍然为一个函数，并没有去调用`，而 call 与 apply 是`直接调用函数`。

- 函数.call(对象,arg1,arg2....)
- 函数.apply(对象，[arg1,arg2,...])
- var ss=函数.bind(对象,arg1,arg2,....)

```
function show(sex){
    console.log("区别:"+sex);
}
var person={
    name:"aa",
    age:14
};
或者
var person = '';
或者
var person = [];
或者
var person = {};

show.call(person,"男");     //区别:男
show.apply(person,["女"]);  //区别:女
//对于bind来说，用法更加的灵活
var ss=show.bind(person,"不明");   //区别:不明
ss();
```

## 实例 (重点用法，多关注)

场景一：某些开源组件提供的函数内会有依赖注入的情况，我们直接将处理好的数据结构抛入依赖注入的函数中，组件便会帮我们完成 dom 结构的建立，如 elementui 的 autoComplete 组件，内部有一个 cb 的依赖，我们直接将数组传入 cb 中便会在 input 标签 focus 时出现对应的建议值

```
function add (arr) {
  let count = 0;
  arr.forEach( (val) => count += val );
  return count;
}

function even (num) {
  let result = num % 2 === 0 ? true:false;
  return result === true ? '偶数':'奇数';
}

function countIsLimit (arr, countFn ,limitNum) {
  let count = countFn(arr);
  // 这里你当然可以不用arguments，而选择直接在参数上多写一个参数名，这里我这样用只是为了告诉大家这种场景而已，新增参数名当然更直观。
  let isEven = arguments[3](count);
  let result = count <= limitNum ? '小于或等于限定值': '大于或等于限定值';
  return count + result + limitNum + '并且是' + isEven;
}
let testArr = [1, 2, 3, 4];

let bindResult = countIsLimit.bind(null, testArr, add, 10, even)
bindResult(); // 10小于或等于限定值10并且是偶数
```

最后的结果显而易见了，这个 demo 模仿了上述我所说的场景，首先我没有改变 countIsLimit 这个函数的 this 指向，因为在此场景下我们不需要改变，那么我们便设为 null 让他继续指向 window，在 countIsLimit 的最后一个参数并不是我后面 bind 的 even，因为原本的函数中就没这个参数，这个参数是后来我加入的一个自定义依赖，而原本函数中便存在一个 countFn 的依赖来进行最后的数据处理，但是现在我有一个需求就是我`不止需要知道测试的数组和与限定值的关系`，还要知道这个和的奇偶性，这时我们需要在函数内拿到数组的和再进行处理，即再数组内执行 add 函数后进行数据处理，这时这个需求就和我们场景中一致了，我们需要传入新的参数对函数内部得到的数据进行处理并输出，而这里我传入了一个新的依赖函数 even 来进行处理，并且将处理结果添加至最后的返回值上，`这也是函数式编程的一个概念`，所有的需求都有对应函数处理，并且`通过依赖注入的形式互相处理最终数据，这种需要依赖注入的场景只有bind能实现，因为我们需要新传入依赖函数后，在函数内部进行处理后才执行bind的函数`，如果此时用 call 与 apply 的话当然也可以，但是显然没有这么直观了，尤其是在某些我们并不清楚业务逻辑的情况下，我们是不知道业务最终返回的数据形式的，此时我们就应该只传入依赖函数，让熟悉的人去编写业务逻辑处理了，这种情况显然就不能用 call 与 apply 了！

场景 2：用别人已经封装好的事件与函数，只是需要我们传入新值去判断，实际上这种情况与场景一类似，只是这时我们扮演的是熟悉业务逻辑的人，而不是新增依赖函数的人，这种场景就简单太多了;上面讲 bind、call、apply 的运用所用的 demo 就是例子~
