## 现有方法
私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。
- 一种做法是在命名上加以区别。
```
class Widget {

  // 公有方法
  foo (baz) {
    this._bar(baz);
  }

  // 私有方法
  _bar(baz) {
    return this.snaf = baz;
  }

  // ...
}
```
_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是`不保险的，在类的外部，还是可以调用`到这个方法。

- 另一种方法就是`索性将私有方法移出模块`，因为模块内部的所有方法都是对外可见的。
```
class Widget {
  foo (baz) {
    bar.call(this, baz);
  }

  // ...
}

function bar(baz) {
  return this.snaf = baz;
}
```
上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得`bar实际上成为了当前模块的私有方法`。

- 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。
```
const bar = Symbol('bar');
const snaf = Symbol('snaf');

export default class myClass{

  // 公有方法
  foo(baz) {
    this[bar](baz);
  }

  // 私有方法
  [bar](baz) {
    return this[snaf] = baz;
  }

  // ...
};
```

上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。

## 私有属性的提案
- 与私有方法一样，ES6 不支持私有属性。目前，有一个提案，`为class加了私有属性。方法是在属性名之前，使用#表示`。
```
class Point {
  #x;

  constructor(x = 0) {
    #x = +x; // 写成 this.#x 亦可
  }

  get x() { return #x }
  set x(value) { #x = +value }
}
```
之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 Decorator。

- 私有属性也`可以设置 getter 和 setter 方法`。
```
class Counter {
  #xValue = 0;

  get #x() { return #xValue; }
  set #x(value) {
    this.#xValue = value;
  }

  constructor() {
    super();
    // ...
  }
}
```
上面代码中，#x是一个私有属性，它的读写都通过get #x()和set #x()来完成。