https://juejin.im/post/5e722aa851882548fe29322f#heading-72  （中高级前端面试）

https://juejin.im/post/5ecc0cbef265da770274b2a5

https://juejin.im/post/5ecb8d77518825433b132ae6

公司运营数据可视化渲染
数据中心
自研直播端
参与直播业务线的开发，班课系统、

组件抽离、
开发多方面运营h5活动页，售卖、裂变、专区、红包、留言

配置


经常做一些无效加班，由于迭代频繁经常需要上线，但上线时间太晚，所以经常感觉无效加班，让人感觉一直在等上线。加班有些厉害，几乎是996，需求经常不明确，
创业公司一般是没有太闲的，

## 2020做的工作
了解使用docker部署前端应用，
dockfile基于基础镜像打包成自定义镜像 
前端写dockfile文件和ngnix配置文件

devops:面向运维自动化it（有待进一步了解含义），使得项目开发、测试、运维高效推进

公司好像没有用CI，
写自动化工具，抽离出公共组件

ngnix：代理，监听，日志输出

chown -R nginx.nginx /data
chown -R 用户名:组名 ./ 及 chown用法介绍
chown将`指定文件的拥有者改为指定的用户或组`，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。

熟悉 ngnix常用指令  rewrite location try_files

shell脚本

流程：把代码部署到github上，打包发布到docker容器中，因为前端项目繁多，所以前端来控制转发逻辑，然后跟运维商量配置转发

基于node开发插件，包

整理前端内部相关文档，偶尔开展内部技术分享（分享过的是跨域、ssr和csrf攻击等）单核工作法
同事间互相codereview，增加代码质量

每季度有okr考核制度
按照sop开展每次迭代，实现高质量产品上线
小步快跑，快速迭代的理念开发迭代。

想问的问题：上线流程和时间、技术部规模、主要有哪些业务、我参与的业务、从需求提出到上线的整个工作模式是啥
跟产品商量需求合理性，减少留下不必要的技术债，并且提高代码扩展性、cms高效性。
多次做迭代负责人，它的职责是明确此次需求，追踪此处迭代涉及到的各端人、每日需求开发、测试进度，及时发现问题并协调各端解决问题、保证高质量的交付此次迭代。

直播线业务：node服务、班课系统、小程序、项目架构、运营项目、h5直播页面、裁剪系统
跟踪项目都是从0-1的过程

使用vuepress开发完成前端官网

## webpack
webpack是什么？优缺点？原理？常用插件？源码？
vconsolePlugin


## 碰到的问题
- input兼容性问题：失去焦点，自动弹出软键盘
- video兼容性问题：ios社保不会自动全屏，后来自己重写组件
- type=range兼容性问题
- 滚动不流畅，随着滚动改变标签位置、dom元素变化

- 偶现问题
逻辑不严谨：比如处理了if没有处理else
设备兼容性导致
网络问题

## react vs vue
可以从几个方面来比较
1. 学习曲线：vue学习速度快，官方文档详细，vue的定义比react严格，react不是一个包含所有功能的框架，只关注核心功能，其他都是靠第三方插件解决
2. 代码风格：css、js、html分离，符合开发者习惯，感觉更自然
3. 单个文件组件：react单文件组件时jsx写的
4. 性能：很难衡量，取决定于项目复杂度
5. 灵活性：react构建ui
6. 工具
7. 移动端支持：react有一个用于构建移动应用程序的端口
8. 社区：react有很大的社区，开发时间比vue早。react是由facebook创建和维护的框架
9. 成熟度：

## vue是什么？为什么选用vue？
vue是面向前端通过数据驱动的响应式框架，上手简单；css、js、html分离，符合开发者习惯；能满足大部分功能；大量社群；

vue对于响应式属性的更新，只会精确更新依赖的当前组件（也就是说触发此组件的更新、视图的重新渲染），而不会递归的去更新子组件，这时候它性能强大的原因之一。

## 虚拟dom的优点和原理

减少对真是dom的操作，提高网页性能

它的原理是构建虚拟dom，把dom对象抽象出js对象，毕竟操作js对象比操作dom省时也省性能，然后通过diff算法判断出新dom和旧的dom生成的js对象之间的差异，最后渲染差异。
diff算法是只对比同层的节点，可以减少时间复杂度。
相同节点、属性、key值，继续往下比较，子节点一样进行移动
如果不一样直接删除，增加的就直接新添加
key的功能：方便比较新旧节点，方便判断是否移动、删除还是添加。

for循环不用index作为key的原因：从diff算法原理了解到，不方便做节点的复用

## vue的双向绑定原理
vue数据双向绑定的原理：vue内部把data对象里每个数据的读写转化为getter、setter，当数据变化时通知视图更新。
主要通过监听器observer、订阅器dep、订阅者watcher、解析器compile，这4个步骤实现

## vue的响应式原理
利用MVVM的思想来实现数据驱动视图，数据改变，不直接操作dom，通过vue内部机制，实现视图渲染。
vue实现响应式的原理同数据双向绑定的原理

## 深度优先遍历

## router 2

## weex 2

## redux 2

## webpack
treeshaking、打包原理、插件、loader （sass-loader、 css-loader、style-loader，写得顺序需要注意，相反顺序）、常用插件
sass-loader：加载SASS / SCSS 文件并将其编译为 CSS
css-loader：仅仅只是把样式代码写入 js
style-loader：把写入js的样式代码插入到 index.html文件中

weebpack打包后产生的文件是个立即自执行函数，自执行函数的入参是个数组，这个数组包含了所有的模块，包裹在函数中。

开发了本地图片替换成cdn链接图片

听说过tree-shaking吗？webpack2开始引入了它，它是删除掉没用的代码，但是它只对es6有效，不过一般es6都会经过babel转换，所以基本上没用

tree-shaking原理：
将所有代码打包到一个作用域下，然后遍历所有作用域，去除没使用的作用域（webpack原理：遍历所有引入模块，把它们打包成一个文件，在这个过程中，就知道哪些export的模块被使用到）

要求：
使用es6模块
不能删除立即执行函数，避免使用IFEE
如果使用第三方的模块，可以尝试直接从文件路劲引用的方式使用

loader和plugin的区别：
- loader  用于对模块源码的转换，loader描述了webpack如何处理非javascript模块，并且在buld中引入这些依赖。loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。
- plugin  目的在于解决loader无法实现的其他事，比如CommonChunkPlugin主要用于提取第三方库和公共模块
html-webpack-plugin ： 自动生成html
copy-webpack-plugin： 拷贝资源插件
clean-webpack-plugin： 清理指定目录下指定的文件
compression-webpack-plugin：压缩文件
vConsolePlugin：调试

我自己开发的plugin是把本地图片文件上传到oss文件，
怎么开发的：
在vue.config.js：configureWebpack中引入插件对象
思路：获取本地文件，取出文件路径，读出文件流，上传到oss，得到链接，然后进行替换

webpack打包原理：
从webpack配置文件中配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去，最终打包成一个文件。

## js继承、异步、闭包、原型、http/https/http2、深拷贝、es6、跨域

## css  bfc、浮动、flex、实现三角、垂直和水平居中

**BFC**
bfc触发的条件：
display
positon：除了absolute static

## ES7 ES8 ES9 ES10
ES7：
- Array.prototype.includes()
- Math.pow()
ES8：
- Async/Await
- Object.values()，Object.entries()
- String padding
- Object.getOwnPropertyDescriptors()
ES9：
- for await of
- Object Rest Spread
- Promise.prototype.finally()
ES10:
- Array.prototype.flat()
- Array.prototype.flatMap()
- Object.fromEntries()
- String.trimStart 和 String.trimEnd
- String.prototype.matchAll
- try…catch
- BigInt
- Symbol.prototype.description
- Function.prototype.toString()

## 浏览器兼容性问题 1

## 总结项目经验  2

对于直播项目主要做运营h5活动页、班课系统、裁剪系统，做过一点
做过几个小程序需求

## 简历 2

白天学习，晚上总结和回想、看公司需求

cdn加速和预加载
预加载：详情页有多张图片时，为了提高加载速度，先加载前两屏的图片，随着用户下滑再加载后面的图片

cdn加速

## 踩过的坑（css、js、vue）

重复追加导致的bug、

position:fixed  的 input是最常见的坑，有光标错位、软键盘遮挡、有时候软键盘滚动不下拉

position:fixed 在百度被屏蔽

遮挡层底部还能滑动

ios 内层滚动到顶部或者底部无法滑动问题

监听滚动反应慢：position:sticky

组件抽离到私有npm包到私有仓库，私有npm仓库，包括公共组件、公共工具（自动发布、管理系统架子）、公共接口（分享、埋点、请求、字体、版本判断、跟客户端交互的接口、操作缓存、公共函数等）
移动端UI组件、cms的UI组件

企业微信中链接不能分享出去（公司内部使用，业务数据可视化页面）

搭建新项目，配置docker中需要的ngnix、Dockerfile文件（配置多环境下的ngnix），直到访问成功（域名配置解决跨域）

根据UI设计

总结现有技术债，方便迭代中插入攻克

整理前部门文档，输出开发相关的操作规范，项目代码规范文档（vue的函数顺序、缩进、），总结部门内sop（自测清单、上线清单），方便新人使用

能与各端顺利协作完成工作

多需求并行开发

每周更新okr完成情况，尽量完成自己的okr

按公司程序上线，尽量减少线上出问题

每次迭代会进行整个功能自测，保证最少的bug提测

## 自我介绍
可以参考以下提纲：

一句话概括说明自己的经历和优势
一句话简要描述之前做过的工作
一句话简要描述最近一份工作以及重点的业绩
一句话简要描述对目标岗位的理解和想法
一句话表明应聘的意愿
你的独一无二体现在哪里
为何能胜任这个职位
你的专业成就

面试官好，我叫何辉云，毕业于北京科技大学，机械自动化专业，自学转行来到前端行业，【从事前端工作3年多】，第一家单位在英国金融时报做前端开发也接触了一些ios开发，因为想有更多的锻炼机会，后来来到罗辑思维，毕竟是创业公司，参与过多条业务线，除了开发cms和h5活动页，还接触过很多从0到1的工作，比如做迭代负责人、从头开始搭建新业务项目、搭建公共组件项目、插件开发、loader开发、文档输入、规范总结、开发自动化编译发布工具，当然多需求并行开发也是惯例，我觉得干好前端除了技术上更重要的是学习能力，希望我今天的发挥能给您好的印象，能力也能满足公司的要求，更希望后期能跟大家一起相互学习，谢谢

这2年下来，锻炼了并行协作工作的能力，并且磨炼出很强的心理素质，能应对各种产品经理提出理不清的需求

- 你做过什么工作？

- 你为什么离职？
公司搬迁到离地铁站比较远的地方，因为有了孩子，毕竟有了家庭，不想花太多的时间在路上，想找离对象公司近点的单位。
负责的工作好多都是重复性的工作，想要换个挑战性高点的工作


多条业务线CMS和h5活动页开发
抽离公共组件、公共api，提高代码复用性
开发自动化工具，提高工作效率   （去看别人的逻辑）
开发本地图片替换成cdn域名插件，提高前端性能  （去看逻辑）

数据线和直播线使用react
踩过多种坑，不断的解决

项目说明、技术债

直播业务线主要开发项目

裁剪系统开发（VUE）：实现每次直播完录制的视频可裁剪
班课系统开发（VUE）：实现管理直播课相关人员和业务（直播老师、班主任），方便上课相关人员查询、操作，销售人员
作业系统开发（VUE+小程序）：基于wx小程序开发前台+基于VUE开发CMS，实现学生答题(含录音、录视频)、点赞、互评等功能
h5活动页（VUE）：售卖页、活动推广页、拉新、结课证书
音频线CMS系统：主要物料创建，音频切割打点功能，界面内实现模拟 APP 效果的动态预览；开发音频切割打点功能，实现 App 播放过程中关联图片的动态切换

班课系统：管理直播课相关人员和业务（直播老师、班主任），方便上课相关人员查询、操作，销售人员
裁剪系统：每次直播完录制的视频可裁剪

接入七陌在线客服

总结和攻克技术债，实现重点难点问题解决和产品优化

公司移动端h5

1）实现电子商城从选择商品到支付完成的整个购买流程  

【（注意微信H5支付和微信内支付，微信能不能使用支付宝支付，获取支付成功和失败的信息，支付前和支付后的监听。h5 支付唤起前的钩子函数，返回 true 时阻断 h5 跳转，默认不阻止。如果请求失败需要阻断h5跳转，如果请求成功就会唤起支付 App）

支付宝支付：前端调取支付宝支付接口（后台进行封装，没有直接调取支付宝接口），调用返回的数据中，将会有一串的form表单数据返回，我们需要将此表单在当前调用页面submit下，以跳转到支付扫码页；

缓存支付方式和用户名】

2）通过音频、视频、图片、打卡、留言、分享等方式实现活动推广

【踩坑：点击播放IOS默认全屏，安卓不会默认全屏，video安卓默认点击不能全屏播放解决办法
android x5内核等浏览器可以全屏设置（设置多个参数）

留言：position:sticky   InfiniteLoading按需加载，滚动才会执行，所以要判断刚进来是否能直接看到InfiniteLoading

微信分享sdk加载是异步的，先要获取签名，再把公众号id、签名传给微信接口，然后再设置分享信息。
openApp:
if (window.WeixinJSBridge) {
      wxCallApp(param);
    } else {
      document.addEventListener('WeixinJSBridgeReady', () => {
        wxCallApp(param); // 此时立即调用权限可能还未准备好，所以 wxCallApp 里需要延迟调用
      });
    }
h5CallApp:  安卓终端使用iframe嵌入iframe跳转

有百度浏览器会拦截自定义 scheme，可能需要提示一下，但是鉴于用户很少，不做处理先

】

3）可视化多维度的学习报告数据
【柱状图，饼图，】

4）基于第三方sdk实现在线直播

【判断浏览器，浏览器中唤期app的兼容性问题
不能用fixed，不然百度浏览器会当作广告屏蔽掉
absolute不同的浏览器展示有区别，需要根据浏览器开发
播放器得判断存不存在
首先得熟悉第三方sdk api用法，然后针对每种情况，尤其要考虑边界情况进行处理，退出再进入得重连
转屏处理
】
5）打通前端、客户端、第三方商城之间的多交互流程

【版本比较、域名】

售卖页、活动推广页、拉新、结课证书


1)含有音频、视频、图片、打卡、留言的活动推广页 
2)打通前端、客户端、第三方商城之间的多交互流程，实现用户相互之间推荐
3)学生的结课证书
4)基于百家云的h5直播，后来改为声网（h5直播）
打卡领奖学金，微信学习报告（开启学习报告，跳转到微信登录，查看学习记录），

电子商城：整个售卖过程
运营页：打卡
结课证书：基于 html2canvas 生成图片，并分享

售卖页：支持多方式购买页（单商品、组合、打折、拼团）
拉新页：

公司多条业务线内部系统 （elementUI）
1)裁剪系统（VUE）：实现每次直播完录制的视频可裁剪
【录制生成的视频进行裁剪】
2)班课系统（VUE）：实现管理直播课相关人员和业务（直播老师、班主任、销售人员），方便相关人员查询、操作，
3)数据中心（react + TypeScript + echart）：只可在企业微信中打开并且不可分享的业务数据可视化渲染页
4)音频线CMS系统（VUE）：主要包含物料创建，音频切割打点，互评，界面内实现模拟 APP 效果的动态预览


作业系统开发（VUE+小程序）
1)CMS 主功能:老师点评(支持语音、图片、评分)、锚点快速定位 
2)小程序主功能:学生答题(含录音、录视频)、点赞、互评
3)后台接口树状数据列表化


音频业务线主要开发项目
CMS管理平台（VUE）：
h5活动页（VUE）：售卖页、活动推广页、拉新、结课证书



公司内部后台管理系统开发
直播线的裁剪系统、班课管理系统CMS开发
音频线的CMS开发
效率线的分销系统开发
业务数据可视化渲染
公司内部home主页开发
作业系统小程序开发（找出所有页面）

踩过多个坑，挑几个经典的案例说说


售卖页、活动推广页、引入第三方平台开发、

熟练使用vue技术框架
了解ES6，TypeScript等语言新发展
能使用TypeScript语言开发
喜欢总结技术blog

字体：设计375的ui图，根据设计的距离设置高度，高度成语0.01


## 模板
GHI项目
我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。

其他项目
（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。）


## 微信二次分享和授权
**授权**
1、如果没有授权过（如果显式授权。判断是否存在 unionid 和 openid；如果为隐式授权则仅判断 openid 是否存在。），先进行微信原生授权跳转（微信的链接，url问号后面需要带上授权页面的url【包含response_type: 'code',
        client_id: '101481715',
        redirect_uri: uri,
        state: 'state'】）
2、显示授权时，需要 token 换用户信息（去后台请求出用户信息）

如果换取数据失败，也就是登陆失败，去掉当前 url 中的 code，重新请求 code
// 登陆失败，去掉当前 url 中的 code，重新请求 code
          // FIXME: 优化点 - 直接跳转至中间页获取 code，而不是跳转回原页面
          location.href = this._getCurrentHref();

不过重新请求次数需要限制，把次数保存到本地



**分享信息设置、从微信唤起 App、设置微信菜单**
考虑极端情况

由于授权是异步进行的，因此建议在页面组件加载完毕后立即执行（放在mounted中），以保证在 webSDK 使用时无需等待。
注意：http和https

1、微信sdk加载

2、通过url获取微信 SDK 授权签名，
wx.config(configParam); 包含签名、二次分享出现的渠道

3、设置微信分享信息
wx && wx.ready(() => {   //需在用户可能点击分享按钮前就先调用
    Log.log('handleWxShare', params)
    wx.updateAppMessageShareData(params);
    wx.updateTimelineShareData(params);
    wx.onMenuShareWeibo(params);
  });

微信唤期app：

注意：WeixinJSBridge是否存在的判断

window.WeixinJSBridge.invoke('launchApplication', {
    'appID': 'wx9516c6869545c65c',
    'parameter': openurl, // 自定义 scheme URL 中的 path 部分
    'extInfo': openurl // 格式可以自定义，第三方 APP 自主处理，可以是 path 或 json 等
  }, (res) => {/*
     * 调用成功返回“launchApplication:ok”，
     * 包括成功打开了 app 或者用户在弹窗上点击取消拉起 app
     *
     * 调用失败返回“launchApplication:fail”，jsapi 本身调用失败，
     * 或安卓上该应用未安装，或 iOS 上用户在弹窗上点击拉起但该应用未安装
     *
     */
    if (res.err_msg !== 'launchApplication:ok') {
      Log.warn('launchApplication err: ', res);
      location.href = param.downloadUrl;
    }
  });

  h5唤期app：

  注意：兼容性问题

 // 有百度浏览器会拦截自定义 scheme，可能需要提示一下
// 验证时间差，如果是阻拦代码执行的浏览器，时间会长一点，但是有的浏览器弹出一个框，不会阻止代码执行，时间会很短

  if (window.WeixinJSBridge) {
    wxCallApp(param);
  } else {
    document.addEventListener('WeixinJSBridgeReady', () => {
      wxCallApp(param); // 此时立即调用权限可能还未准备好，所以 wxCallApp 里需要延迟调用
    });
  }

  // 安卓终端使用iframe   直接跳
**支付**

注意大小写转换

目前只支持 'h5'支付 / 'wechat' 微信内支付 / 'app' APP内支付

1、调用后端一接口
2、如果是h5，跳转至微信 mweb_url，用于唤起微信支付

如果是微信里面，直接调用微信支付
WeixinJSBridge.invoke(
          'getBrandWCPayRequest', options, res => {
            if (res.err_msg == 'get_brand_wcpay_request:ok') {
              // 使用以上方式判断前端返回,微信团队郑重提示：
              // res.err_msg将在用户支付成功后返回ok，但并不保证它绝对可靠。
              resolve({
                code: 0,
                msg: '支付完成',
                wxRes: res,
                res: response,
              });
            } else {
              reject({
                code: 1,
                msg: `微信支付失败`,
                wxRes: res,
                res: response
              });
            }
          });
如果是app内，app开发的，具体还没深入了解

## app和js怎么通讯的（IGC_JS2Native）
约定一个函数IGC_Js2Native，传入对象，函数名，客户端返给前端的值
1、ios调用h5方法，并传递消息
function messageHandles_h5FunctionToios(params){

}
window.messageHandles_h5FunctionToios = this.messageHandles_h5FunctionToios

2、h5调用ios方法，并发送消息给ios
window.webkit.messageHandlers.iosFuncitonToJs.postMessage(param)

3、android调用H5方法并传递消息
原生调用js回调函数推送值
window.IGC_Native2Js，消息用onmessage监听

native 通知 js ：回调

4、h5传递消息给android

原生通过回调传回值
window.IGC_NativeCallBack[parameters.name] = function (nativeValue: any) {
  channel && channel.port1.postMessage(nativeValue);
};

 window.DDAppWebView.IGC_Js2Native(JSON.stringify(parameters));

 channel && channel.port1.postMessage(nativeValue);  原生值

// 老版本是直接绑定在window上的，新版本借助 IGC_Native2Js（前端注入） 分发。

## 写代码注意
1、防止重复追加
2、边界请求情况
3、兼容性判断
4、大小写转换，防止出错
5、图片http和https不同，会导致加载时间不同

## 直播
**PPT**
1、存储队列动作
2、设置队列长度为1
3、监听PPT的值，后端返给ppt链接

疑问：怎么生成的PPT，通过什么技术？

画箭头的思路：找到对应点，一点点画

写白板：发信令

监听按钮动作
PPT上一张、下一张需要发信令，为什么？
发信令：终止连麦、开始连麦、上一张PPT、下一张PPT、写白板、发布公告

使用了vuex，更改数据、举手类型等

发送信令是一个接口

IM（聊天通信事件）：成功加入教室，
融云

## 自适应方案
自适应方案（JS动态计算，比较常用的方法）： 根据设计稿尺寸(px)通过计算，转换成rem去布局

fontsize  使用rem，375代码
rem:是相对于html的，全局直接设置HTML的字体大小，设计图都是按照375大小设计的，
设置了html字体大小为100px，

 window.addEventListener('resize', function () {
    setFontSize();
  }, false);

0.2rem*100 = 20px


var size = size || 300;

var _fontSize =
          (getSize()['width'] * fontSize) / originalWidth > size
          ? size
          : (getSize()['width'] * fontSize) / originalWidth;
        oHtml.style.fontSize = _fontSize + 'px';

设备宽度 * 300 /（375*3）

翻译过来：设备宽度 * 100 / 375 > 300 ？size : 设备宽度 * 100 / 375 ，写以上逻辑就是担心设备过大，html就是300，太小就是100。

window.devicePixelRatio 

1. 
写死initial-scale=1.0，动态生成viewport

设置宽度375，字体大小为100或者300

根据设计稿尺寸(px)通过计算，转换成rem去布局。

2. px + 百分比布局


dpr是devicePixelRatio的简写，也就是屏幕分辨比。

scale是屏幕拉伸比。也就是视口上的initial-scale , maximum-sacle 等属性。

scale 和 dpr的关系是倒数。

同样大小面积，物理像素越高，显示图片越清晰，展现图片色彩能力越强

3. flex布局

物理像素/设备像素：设备像素也被称为物理像素,他是显示设备中一个最微小的物理部件。
屏幕密度：通常以每英寸有多少物理像素来计算（PPI）。
css像素：抽象的单位，用来精确的度量（确定）Web页面上的内容。

window.devicePixelRatio=物理像素/独立像素。


## 快捷管理和敏捷开发
和大家同步一下，为了能够让咱们的迭代排期更加清晰，更加清楚团队目前的压力状态，
@云娜娜 老师做了三张表，分别为人力投入表、项目排期表、项目盘点表，能够全面直观的展示出咱们的项目和投入情况，从今天开始需要依靠大家的力量去管理这三张表

迭代负责人需要关注和更新：
人力投入表、项目排期表、项目盘点表

每一位同学需要关注和更新：
人力投入表

跟各自的组员说一下吧，之后的每一天都会使用这个表来跟踪项目，务必更新及时吧


检查错误配置，diff算法

## promise使用场景
拒绝和确定使用它，
当写自动化编译工具的时候，


resolved rejected
```
bogon:vue-publish hehuiyun$ npm view @igetcool/vue-publish versions --registry http://npm.igetcool.com
 
[ '0.4.7',
  '0.4.8',
  '0.4.9',
  '0.5.0',
  '0.5.1',
  '0.5.2',
  '0.5.3',
  '0.5.4',
  '0.5.5',
  '0.5.6',
  '0.5.7',
  '0.5.8',
  '0.5.9',
  '0.6.0',
  '0.6.1',
  '0.6.2',
  '0.6.3',
  '0.6.4',
  '0.6.5',
  '0.6.6',
  '0.6.7' ]
```
获得最后面一个版本，替换换行、空白、[、]、引号

let vlist = res.replace(/\n|\s|\[|\]|'/g, '').split(',');
let last = vlist[vlist.length - 1];

本地代码版本号规则


现在使用的是vue，上一家单位使用一段时间react，做过一段时间数据线使用的是react