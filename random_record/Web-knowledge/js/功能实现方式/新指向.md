## 因为嫌console.log()的写法太繁琐，想将其简写为log()
```
<!--法1，此法可能报错（网上查找都报错，我再chrome浏览器中console中尝试没有出错，所以写可能），因为对于console.log("info…")而言，log方法在console对象上调用，因此log方法中的this指向console对象；而我们用log变量指向console.log方法，然后直接调用log方法，此时log方法的this指向的是window对象，上下文不一致，当然会报错了。-->
var log = console.log;
log("info…");

var log = console.log.bind(console);
log("info...");

Function.prototype.bind = Function.prototype.bind || function(context){
    var _this = this; 
    return function(){
         _this.apply(context, arguments);
    };
};
```

```
var obj = {
    a: 1,
    foo: function f() {
        console.log(this.a);        
    }
}

obj.foo(); //1   //foo绑定到obj上，函数this指向运行时绑定的特定对象

var g = obj.foo;
g();    //undefined  //此时输出undefined，是因为g绑定到全局对象

g = obj.foo.bind(obj);
g();    //1
```
注意：
- function中的this是个例外，this并不指function对象本身，也不是指function的作用域对象。而是`在运行时绑定到特定的对象上`。即它采用的是动态作用域规则。
- 上面的代码段中，函数foo在非严格模式下如果没有明确绑定对象，则会绑定到全局对象，所以输出undefined。在严格模式下则会报错。
- 为什么obj.foo() 可以正确输出呢？原因在于这种调用方式会隐式绑定到执行这个方法的对象上（obj）。