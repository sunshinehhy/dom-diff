- 把树形结构`按照层级分解，只比较同级元素`。只会对同一层次的节点进行比较。

- 对于`不同层的节点，只有简单的创建和删除`。

- 给列表结构的每个单元添加唯一的key属性，方便比较。(列表节点提供唯一的key属性`可以帮助React定位到正确的节点进行比较`，从而大幅减少DOM操作次数，提高了性能。)

- 深度优先遍历，记录差异。在深度优先遍历的时候，`每遍历到一个节点就把该节点和新的的树进行对比`。如果`有差异的话就记录到一个对象里面。`(有一个对象存差异 patches)

在实际的代码中，`会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记`.
```
// diff 函数，对比两棵树
function diff (oldTree, newTree) {
  var index = 0 // 当前节点的标志
  var patches = {} // 用来记录每个节点差异的对象
  dfsWalk(oldTree, newTree, index, patches)
  return patches
}

// 对两棵树进行深度优先遍历
function dfsWalk (oldNode, newNode, index, patches) {
  // 对比oldNode和newNode的不同，记录下来
  patches[index] = [...]

  diffChildren(oldNode.children, newNode.children, index, patches)
}

// 遍历子节点
function diffChildren (oldChildren, newChildren, index, patches) {
  var leftNode = null
  var currentNodeIndex = index
  oldChildren.forEach(function (child, i) {
    var newChild = newChildren[i]
    currentNodeIndex = (leftNode && leftNode.count) // 计算节点的标识
      ? currentNodeIndex + leftNode.count + 1
      : currentNodeIndex + 1
    dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点
    leftNode = child
  })
}

```

## 差异类型
上面说的节点的差异指的是什么呢？对 DOM 操作可能会：

1. 替换掉原来的节点，例如把上面的div换成了section
2. 移动、删除、新增子节点，例如上面div的子节点，把p和ul顺序互换
3. 修改了节点的属性
4. 对于文本节点，文本内容可能会改变。例如修改上面的文本节点2内容为Virtual DOM 2。


- React 只会匹配相同 class 的 component（这里面的class指的是组件的名字）。不同的是删除和创建


合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.

选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能。

参考链接：

https://segmentfault.com/a/1190000000606216

React只会对相同颜色方框内的DOM节点进行比较，`即同一个父节点下的所有子节点`。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个DOM树的比较。 (图见img)

## 列表对比算法
现在知道了新旧的顺序，`求最小的插入、删除操作`（移动可以看成是删除和插入操作的结合）。这个问题抽象出来其实是字符串的`最小编辑距离问题`（Edition Distance <https://en.wikipedia.org/wiki/Edit_distance>）。
线性算法分析（https://supnate.github.io/react-dom-diff/index.html）

https://github.com/livoras/simple-virtual-dom/blob/master/lib/diff.js

## 整个算法的步骤
步骤一：用JS对象模拟DOM树
步骤二：比较两棵虚拟DOM树的差异
步骤三：把差异应用到真正的DOM树上

因为步骤一所构建的 JavaScript 对象树和render出来真正的DOM树的信息、结构是一样的。所以我们可以对那棵DOM树也进行深度优先的遍历，遍历的时候`从步骤二生成的patches对象中找出当前遍历的节点差异，然后进行 DOM 操作`。
```
function patch (node, patches) {
  var walker = {index: 0}
  dfsWalk(node, walker, patches)
}

function dfsWalk (node, walker, patches) {
  var currentPatches = patches[walker.index] // 从patches拿出当前节点的差异

  var len = node.childNodes
    ? node.childNodes.length
    : 0
  for (var i = 0; i < len; i++) { // 深度遍历子节点
    var child = node.childNodes[i]
    walker.index++
    dfsWalk(child, walker, patches)
  }

  if (currentPatches) {
    applyPatches(node, currentPatches) // 对当前节点进行DOM操作
  }
}

```
applyPatches，`根据不同类型的差异对当前节点进行 DOM 操作`：
```
function applyPatches (node, currentPatches) {
  currentPatches.forEach(function (currentPatch) {
    switch (currentPatch.type) {
      case REPLACE:
        node.parentNode.replaceChild(currentPatch.node.render(), node)
        break
      case REORDER:
        reorderChildren(node, currentPatch.moves)
        break
      case PROPS:
        setProps(node, currentPatch.props)
        break
      case TEXT:
        node.textContent = currentPatch.content
        break
      default:
        throw new Error('Unknown patch type ' + currentPatch.type)
    }
  })
}
https://github.com/livoras/simple-virtual-dom/blob/master/lib/patch.js
```
## 链接

https://www.jianshu.com/p/b189b2949b33?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation （能很好理解算法)


https://www.youtube.com/watch?reload=9&v=ZCuYPiUIONs  （React Fiber）