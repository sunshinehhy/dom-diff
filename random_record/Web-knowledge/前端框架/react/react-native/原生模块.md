从React Native中调用原生方法（原生模块）

原生模块是JS中也可以使用的Objective-C类。一般来说这样的每一个模块的`实例都是在每一次通过JS bridge通信时创建的`。他们可以导出任意的函数和常量给React Native。(怎么创建有待研究)

原生模块是实现了“RCTBridgeModule”协议的Objective-C类

`为了实现RCTBridgeModule协议`，你的类`需要包含RCT_EXPORT_MODULE()宏`。这个宏也可以添加一个参数用来指定在Javascript中访问这个模块的名字。如果你不指定，默认就会使用这个Objective-C类的名字。

原生模块可以暴露已有的原生库给JS。

警告：所有原生模块共享同一个命名空间。创建新模块时注意命名冲突。

你`必须明确的声明要给Javascript导出的方法`，否则React Native不会导出任何方法。声明通过RCT_EXPORT_METHOD()宏来实现：
```
RCT_EXPORT_METHOD(addEvent:(NSString *)name location:(NSString *)location)
{
  RCTLogInfo(@"Pretending to create an event %@ at %@", name, location);
}
```

现在从Javascript里可以这样调用这个方法：
```
import { NativeModules } from 'react-native';
var CalendarManager = NativeModules.CalendarManager;
CalendarManager.addEvent('Birthday Party', '4 Privet Drive, Surrey');
```

桥接到Javascript的方法`返回值类型必须是void`。React Native的桥接操作是异步的，所以要返回结果给Javascript，你必须通过回调或者触发事件来进行。

## 依赖注入(实现初始化自定义的模块实例)
`bridge会自动注册实现了RCTBridgeModule协议的模块`，但是你可能也希望能够`初始化自定义的模块实例`（这样可以注入依赖）。

要实现这个功能，你需要实现RCTBridgeDelegate协议，初始化RCTBridge，并且在初始化方法里指定代理。然后用初始化好的RCTBridge实例初始化一个RCTRootView。
```
id<RCTBridgeDelegate> moduleInitialiser = [[classThatImplementsRCTBridgeDelegate alloc] init];

RCTBridge *bridge = [[RCTBridge alloc] initWithDelegate:moduleInitialiser launchOptions:nil];

RCTRootView *rootView = [[RCTRootView alloc]
                        initWithBridge:bridge
                            moduleName:kModuleName
                     initialProperties:nil];
 ```

## 给Javascript发送事件

即使没有被JavaScript调用，原生模块也可以给JavaScript发送事件通知。最好的方法是继承RCTEventEmitter，实现suppportEvents方法并调用self sendEventWithName:。

JavaScript代码可以创建一个包含你的模块的NativeEventEmitter实例来订阅这些事件。