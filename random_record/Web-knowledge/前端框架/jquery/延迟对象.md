通过$.Deferred处理过的代码，很明显没有了回调的嵌套，虽然代码量看起来多了点，但是实际上，每一个代码执行部分都被封装了起来，只留了Deferred的接口处理了，等于是我们把执行的流程控制交给了Deferred，这样的好处就是我们在写嵌套函数的时候，可以用deferred提供的管道风格编写同步代码了。

在jQuery 1.8之前，`then()只是.done().fail()写法的语法糖，两种写法是等价的`。在jQuery 1.8之后，then()`返回一个新的deferred对象，而done()返回的是原有的deferred对象`。如果then()指定的回调函数有返回值，该返回值会作为参数，传入后面的回调函数。
## 创建延迟对象 
var deferred = $.Deferred();

## deferred.always(alwaysCallback [, alwaysCallback])  
当Deferred（延迟）对象解决或拒绝时，调用添加处理程序。
// 当deferred对象`被解决或拒绝时，都执行此方法`
// 参数可以是一个函数，或是一个函数数组

## deferred.catch()
当Deferred对象被拒绝(reject)时，调用添加的处理程序。

## deferred.done()
当Deferred（延迟）对象解决时，调用添加处理程序。

## deferred.fail()
当Deferred（延迟）对象拒绝时，调用添加处理程序。

## deferred.isRejected()
确定一个Deferred（延迟）对象是否已被拒绝。

## deferred.isResolved()
确定一个Deferred（延迟）对象是否已被解决。

## deferred.notify()
根据给定的 args参数 调用Deferred（延迟）对象上进行中的回调 （progressCallbacks）。
// deferred进行处理时，调用所有的progressCallback函数
// progressCallback可通过then方法中的第3个参数设置，也可以通过deferred.progress( progressCallback )添加
// 通常此方法只能被deferred对象的创建者调用，可通过deferred.promise或then过滤此方法
// 参数可不写。若写有参数，建议为字符串或可返回字符串的函数
// `当deferred进入 resolved 或rejected状态后，再调用notify方法，progressCallback将不再被执行`


## deferred.notifyWith()
根据给定的上下文（context）和args递延调用Deferred（延迟）对象上进行中的回调（progressCallbacks ）。

## deferred.pipe()
实用的方法`来过滤 and/or 链Deferreds`。

## deferred.progress()
当Deferred（延迟）对象生成进度通知时，调用添加处理程序。

## deferred.promise()
返回Deferred(延迟)的Promise（承诺）对象。

## deferred.reject()
拒绝Deferred（延迟）对象，并根据`给定的args参数`调用任何失败回调函数（failCallbacks）。

## deferred.rejectWith()
拒绝Deferred（延迟）对象，并根据`给定的 context和args参数`调用任何失败回调函数（failCallbacks）。

## deferred.resolve([args])
args传递给完成回调函数（doneCallbacks）的可选的参数。

解决Deferred（延迟）对象，并根据给定的args参数调用任何完成回调函数（doneCallbacks）。
// 解决deferred对象，`调用所有doneCallback函数`
// doneCallback可通过then方法中第一个参数设置，也可通过dtd.done( doneCallback )添加参数将传递给doneCallback。参数可选只有deferred对象的创建者才可以调用的方法doneCallback中this为deferred或promise对象。doneCallback只接收一个参数

## deferred.resolveWith(context [, args ] )
解决Deferred（延迟）对象，并根据给定的 context和args参数调用任何完成回调函数（doneCallbacks）。
// 解决deferred对象，调用所有doneCallback函数
// 参数：第一个参数为上下文即this对象，doneCallback的this将被修改；第二个参数为数组
// doneCallback中this为调用resolveWith方法的上下文
// doneCallback接收参数个数为该方法第二个参数数组的长度

 `与resolve方法的区别在于，将改变doneCallback函数的this指向`

 通常情况下，只有递延对象（Deferred）的创建者才能调用此方法; 您可以通过deferred.promise()返回的受限制的 Promise 对象，来防止其他代码改变递延的状态 。

 比如：
```
// 调用异步队列，然后派发成功事件出去（最后使用done接收，把·上下文切换成document·，默认第一个参数是jQuery。
readyList.resolveWith(document, [jQuery]);
```
## deferred.state()
确定一个Deferred（延迟）对象的当前状态。
// 返回deferred对象当前状态，pending / resolved / rejected
// 不接受任何参数

## deferred.then()
当Deferred（延迟）对象解决，拒绝或仍在进行中时，调用添加处理程序。

## jQuery.Deferred()
一个构造函数，返回一个链式实用对象方法来注册多个回调，回调队列， 调用回调队列，并转达任何同步或异步函数的成功或失败状态。

## jQuery.when()
提供一种方法来`执行一个或多个对象的回调函数`， Deferred(延迟)对象通常表示异步事件。

## .promise([obj])
返回一个 Promise 对象用`来观察当某种类型的所有行动绑定到集合，排队与否还是已经完成。`

目的： 防止其他代码干涉其内部进度和状态
// 返回新的promise对象，包含可以执行的方法（ done, fail, then, always, progress, state, promise ），
// 不包含修改Deferred状态的方法（ resolve, reject, notify, resolveWith, rejectWith, nodifyWith ）
// 需返回deferred对象时，建议返回deferred.promise()


jQuery提供的deferred.promise()方法的作用是，在`原来的Deferred 对象上返回另一个 Deferred 对象`，即受限制的 Promise 对象，受限制的 Promise 对象只开放与改变执行状态无关的方法（比如done()方法和fail()方法），屏蔽与改变执行状态有关的方法（比如resolve()方法和reject()方法），从而`使得执行状态不能被改变`。

```
var wait = function(){
  var dtd = $.Deferred(); //在函数内部，新建一个Deferred对象
  var tasks = function(){
    alert("执行完毕！");
    dtd.resolve(); // 改变Deferred对象的执行状态
  };

  setTimeout(tasks,5000);
  return dtd.promise(); // 返回promise对象
};
$.when(wait())
.done(function(){ alert("哈哈，成功了！"); })
.fail(function(){ alert("出错啦！"); });

执行完毕！  哈哈，成功了！


var dtd = $.Deferred(); // 新建一个Deferred对象
var wait = function(dtd){
  var tasks = function(){
    alert("执行完毕！");
    dtd.resolve(); // 改变Deferred对象的执行状态
  };
  setTimeout(tasks,5000);
  return dtd;
};
$.when(wait(dtd))
.done(function(){ alert("等待执行！"); })
.fail(function(){ alert("出错啦！"); });
dtd.resolve();// 改变Deferred对象的执行状态
//代码的尾部加了一行dtd.resolve()，这就改变了dtd对象的执行状态，因此导致done()方法立刻执行

等待执行！  执行完毕！
```

当延迟对象被 resolved 时，任何通过 deferred.then或deferred.done 添加的 doneCallbacks，都会被调用。回调函数的执行顺序和它们被添加的顺序是一样的。传递给 deferred.resolve() 的 args 参数，会传给每个回调函数。当延迟对象进入 resolved 状态后，再添加的任何 doneCallbacks，当它们被添加时，就会被立刻执行，并带上传入给 .resolve()的参数。有关详细信息，请参阅文件Deferred object 。