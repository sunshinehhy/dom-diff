## 一、rem与em的区别
### 相对字体大小单位
#### rem ***考点***
代表根元素的font-size大小（如html元素的font-size）.

当用在根元素上面时，它代表了它的初始值：
- 默认的初始值是html默认的font-size大小，即当未在根元素上设置font-size大小的时候，此时1rem == 1em;
- 当设置font-size为2em，就使得页面中1rem的大小相对于html根字体默认大小的2倍。

当用在其他元素上时，可以设置各种长度:
- 在根元素font-size = 10px的时候:1rem为10px, 2rem为20px, 0.5rem为5px;
- 在根元素font-size = 20px的时候:1rem为20px, 2rem为40px,0.5rem为10px ；

该单位在实际使用中一般用于创建完美的可扩展布局。例如移动端布局。

#### em ***考点***
代表元素font-size大小的计算值。
- 当定义font-size属性时，1em等于元素的父元素的字体大小；
- 如果在网页中任何地方都没有设置文字大小的话，那它将等于浏览器默认文字大小，通常是16px。所以通常1em = 16px。2em = 32px；
- 如果你设置了body元素的字体大小为20px，那为后代元素设置1em = 20px、2em = 40px。

实践示例：一个流行的技巧是设置body元素的字体大小为62.5% (即默认大小16px的62.5%)，等于10px。现在你可以通过计算基准大小10px的倍数，在任何元素上方便的使用em单位。这样有6px为0.6em, 8px 为0.8em, 12px为1.2em, 14px为1.4em, 16px为1.6em。

#### ex
代表元素font的x-height。在含有“X”字母的字体中，它是该字体的小写字母的高度；对于很多字体， 1ex ≈ 0.5em。

#### ch
代表元素所用字体 font中“0”这一字形的宽度（“0”，Unicode字符U+0030），或更准确地说是“0”这一字形的预测尺寸。

#### lh
代表元素行高line-height的计算值。

#### rlh
代表根元素行高line-height的计算值。当用于设置根元素的行高line-height或是字体大小font-size 时，该rlh指的是根元素行高line-height或字体大小font-size 的初始值。

### 绝对长度单位
#### px
与显示设备相关：
- 对于屏幕显示，通常是一个设备像素（点）的显示；
- 对于打印机和高分辨率的屏幕，一个 **CSS像素**意味着多个**设备像素** 

> 注意：设备中每英寸的CSS像素数量保持在96左右

#### in, pt， pc, mm, cm
- in: 英寸（2.54厘米）
- pt: 磅/点，1/72英寸
- pc: 12点活字，1pc为12pt
- mm: 毫米
- cm: 厘米

CSS单位和每英寸点数(DPI):
- CSS单位不是根据物理上的英寸来表现的，而是表现为96dpi,即无论真实的设备像素是多少，在1英寸的设备尺寸上都会有96个CSS像素（1in == 96px)。
- 在一个 **高像素密度的设备中，1in 会小于实际的 1 物理英寸**。类似地 mm、cm 和 pt 都不是一个绝对的长度单位。

例如:

- 1in总等于96px
- 3pt总等于4px
- 25.4mm总等于96px
- 1pc总等于12pt等于16px

### 参考
<https://developer.mozilla.org/zh-CN/docs/Web/CSS/length>
<https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size>

## 二、setTimeout(func,0)的实际最小延迟时间
HTML5规定setTimeout()的最短时间间隔是**4ms**

## 三、es6的generator
生成器对象是由generator function返回。

和promise一样，都用于异步编程。

### 语法
```js
function* gen() {
  let a = 1 + 2；
  yield 3;
  yield 3
}

let b = gen();
console.log(b.next());//{value:2, done:false}
console.log(b.next());//{value:3, done:false}
console.log(b.next());//{value:undefined, done:true}
```

#### *
表示这是一个generator函数，当加上了*的函数执行之后拥有了next函数。

#### yield关键字

用来暂停和恢复一个生成器函数。yield关键字后面的表达式的值返回给生成器的调用者。它可以被认为是 **一个基于生成器的版本的return关键字**。生成器函数执行时（gen().next()）一旦遇到yield表达式，生成器的代码将会暂停运行;直到再次调用next(),生成器会恢复执行。

每次调用next()方法时，生成器都会恢复执行，直到到达以下某个值:
- yield:生成器再次暂停并返回生成器生成的新值:{value:xxx, done:false}
- 到达生成器的结尾:生成器执行结束，并且返回{value:undefined,done:true}
- 到达return语句:生成器执行结束，并且返回{value:return值，done:false}

yield后面可以接promise用于返回一个异步的值。

### 用例: npm包co的用法
co:使用promises为nodejs和浏览器提供基于生成器的控制流程，让你以一种很好的方式编写非阻塞代码。
```js
var co = require('co');
 
co(function *(){
  // yield any promise
  var result = yield Promise.resolve(true);
}).catch(onerror);
 
co(function *(){
  // resolve multiple promises in parallel
  var a = Promise.resolve(1);
  var b = Promise.resolve(2);
  var c = Promise.resolve(3);
  var res = yield [a, b, c];
  console.log(res);
  // => [1, 2, 3]
}).catch(onerror);
```

其实它是模拟实现了后面的async,await

### 参考:
<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator>
<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterator>

## 四、tree shaking与import的形式
基于ES6的静态引用，tree shaking 通过扫描所有es6的export,找出被import的内容并添加到最终代码中。webpack 的实现是把所有 import 标记为有使用/无使用两种，在后续压缩时进行区别处理。

### 问题:对于如下形式的export和import，webpack可以识别出只要a，不要b吗?
m:
```js
export {
  a,
  b
}
```

n:
```js
import {a} from './m.js'
```
答案，从语法层面是可以的，但目前的技术并不能实现只要a不要b。***已亲测，这个导入的还是有b***

### 更多
<https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651554785&idx=2&sn=c8224713a71c914bd278e95dfdf18cf3&chksm=80255420b752dd36c70f200ee67a394df4a7982a3a3ab09f55ed5b106b12fc03cf85f5d60d66&mpshare=1&scene=1&srcid=0823pq09kc1hzk8SnfkuC90p&pass_ticket=Sm5XBRYnwnLhYDniwso8sU%2FDpJyPjMVDWj9O4wG4q5Iueu%2BnEMW8kzR0HWZKks8r#rd>

## 五、思考如下两种方式，require与import都导入两次同样的代码端，各输出几次'test'?
### 方式1：
m.js
```js
console.log('test');
function a() {
  ....
}
import default a;
```
n.js
```js
import a from './m.js';
export default a;
```
o.js
```js
import a1 from './m.js';
import a2 from './n.js';

a1();
a2();
```
这种情况只输出1次'test'，已亲测！！！

### 方式2：

m.js
```js
console.log('test');
function a() {

}
module.exports = a
```
o.js
```js
const a1 = require('./m.js');
const a2 = require('./m.js');
a1();
a2();
```
也是只输出1次'test',已亲测！！！ ***面试官误***

## 六、webpack的loader执行顺序
同时命中一个规则的话逆序执行loader。

loader和plugin 是先loader后plugin。

### 其他webpack考点：
参考:<http://www.fly63.com/article/detial/582>


#### (1) 什么是webpack和grunt和gulp有什么不同?
webpack是一个模块化打包器。
它的一个突出特点是code-spliting,代码分裂

#### (2)什么是bundle,chunck,module?
bundle:打包好的一个结果文件

chunk：entry下可以有多个chunck，每个chunk可以包含多个要打包的文件，最终每个chunk会生成一个bundle。output的filename如果设置为'[name].js'，则可以以每个chunk名称作为每个bundle的名字。(当然如果plugin里面有一些相关插件可以分裂除其中的一些代码，比如说把css分裂出去叫[name].css)

module:指开发中的不同模块，在配置文件中module.rules是一个数组，决定了如何处理项目中的不同类型的模块。

#### (3)什么是loader？什么是plubin?
loaders告诉webpack如何转换不同类型的模块

plugin是用来自定义webpack打包过程的方式，这些插件的方法参与到整个webpack打包的各个流程(生命周期)，在loaders后执行，针对的是loaders转化好的所有文件。按照顺序执行。

#### (4)如何可以自动生成webpack配置？
webpack-cli等工具

#### (5)webpack-dev-server和http服务器如nginx有什么区别?
答案：webpack-dev-server`使用内存来存储webpack开发环境下的打包文件`，并且可以使用模块热更新，他比传统的http服务对开发更加简单高效。

使用koa的时候通常用到koa-webpack,webpack-dev-middleware和webpack-hot-middleware来实现webpack-dev-server的功能。

#### (6)什么 是模块热更新？
模块热更新是webpack的一个功能，他可以使得`代码修改过后不用刷新浏览器就可以更新`，是高级版的自动刷新浏览器。

#### (7)什么是长缓存？在webpack中如何做到长缓存优化？
浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或是更新，都需要浏览器去下载新的代码。

避免方式最方便和简单的更新方式就是引入新的文件名称。在webpack中可以在output中输出的文件指定chunkhash即设置filename:[name].[hash].js,即设置并且分离经常更新的代码和框架代码。

#### (8)webpack怎么实现treeshaking
webpack 负责对代码进行标记，把 import & export 标记为 3 类：

- 所有 import 标记为 /* harmony import */
- 被使用过的 export 标记为 /* harmony export ([type]) */，其中 [type] 和 webpack 内部有关，可能是 binding, immutable 等等。
- 没被使用过的 import 标记为 /* unused harmony export [FuncName] */，其中 [FuncName] 为 export 的方法名称

之后在 Uglifyjs (或者其他类似的工具) 步骤进行代码精简，把没用的都删除。


## 七、防抖和节流
见我的博客《防抖与节流》





## 4. cdn缓存
CDN的全称是 **Content Delivery Network**，即 **内容分发网络**。

CDN 是一种部署策略，根据不同的地区部署类似nginx 这种服务服务, 会 **缓存静态资源**。

**通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上**。

**其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度**。


CDN是一个经策略性部署的整体系统，包括 **分布式存储**、**负载均衡**、**网络请求的重定向**和 **内容管理**4个要件

## 5.闭包
我的博客《闭包深度理解》

## 6. 跨域问题，谁限制的跨域，怎么解决
我的博客 《同源策略与跨域技术》

参考答案:
  浏览器的同源策略导致了跨域
  用于隔离潜在恶意文件的重要安全机制

## 七、javascript 中常见的内存泄露陷阱
1. 内存泄露会导致一系列问题，比如：运行缓慢，崩溃，高延迟

2. 内存泄露是指你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来

3. JavaScript 中 4 种常见的内存泄露陷阱

(1)意外的全局变量
 
 这些都是不会被回收的变量（除非设置 null 或者被重新赋值），特别是那些用来临时存储大量信息的变量

(2)被遗漏的定时器和回调函数
周期函数一直在运行，处理函数并不会被回收，jq 在移除节点前都会，将事件监听移除
detach：移除节点的处理与remove一致，与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来

(3)DOM之外的节点引用
js 代码中有对 DOM 节点的引用，dom 节点被移除的时候，引用还维持

(4)闭包

参考博客:[JavaScript 中 4 种常见的内存泄露陷阱](http://web.jobbole.com/88463/) ***待再看一遍***

## 八、babel把ES6转成ES5或者ES3之类的原理是什么
### JavaScript引擎编译步骤:

- 词法分析:字符串 -> 词法单元
- 解析:词法单元流 -> 抽象语法树(AST)
- 代码生成: 抽象语法树 -> 可执行代码（机器指令）

### babel的工作原理
babel是一个转译器，感觉相对于编译器compiler，叫转译器transpiler更准确，因为它只是把同种语言的高版本规则翻译成低版本规则，而不像编译器那样，输出的是另一种更低级的语言代码。

但是和编译器类似，babel的转译过程也分为三个阶段：parsing、transforming、generating，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：

ES6代码输入 ==》 babylon进行解析 ==》 得到AST
==》 plugin用babel-traverse对AST树进行遍历转译 ==》 得到新的AST树
==》 用babel-generator通过AST树生成ES5代码

此外，还要注意很重要的一点就是，babel只是转译新标准引入的语法，比如ES6的箭头函数转译成ES5的函数；而新标准引入的新的原生对象，部分原生对象新增的原型方法，新增的API等（如Proxy、Set等），这些babel是不会转译的。需要用户自行引入polyfill来解决

参考博客: [【JavaScript】深入理解Babel原理及其使用](https://www.jianshu.com/p/e9b94b2d52e2)

## 九、Promise如何模拟终止? promise 放在try catch里面有什么结果?
看我的博客 《promise》

### Promise模拟终止:
```js
return new Promise(()=>{})////Promise {<pending>}
```

### promise放在try..catch里面
```js
try {
  new Promise((resolve, reject) => {
    setTimeout(resolve, 1000, '1')
  })
} catch(err) {
  console.log(err);
}
//结果：Promise {<pending>}
```

```js
try {
  new Promise((resolve, reject) => {
    reject('err')
  })
} catch(err) {
  console.log(err);
}
//Promise {<rejected>: "err"} 
//浏览器控制台报错 Uncaught (in promise) err
```

```js
try {
  new Promise((resolve, reject) => {
    setTimeout(reject, 1000,'err')
  })
} catch(err) {
  console.log(err);
}
//Promise {<pending>}
//浏览器控制台报错: Uncaught (in promise) err
```

可知: try...catch无法捕获异步错误，即无法捕获promise的错误。

但promise自己的catch可以捕获自己的错误。Promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止，也即是说，错误总会被下一个catch语句捕获。

## 十、网站性能优化

参考《Interview Map》 P52
### 1. 网络相关
#### （1）预解析、预加载、预渲染
- 使用DNS预解析 : 可预先获得域名对应IP
  ```html
  <link rel="dns-prefetch" href="http://example.com">
  ```
- 预加载: 预加载强制浏览器请求资源，但不阻塞onload事件，在一定程度上可以减少首屏时间
  ```html
  <head>
    <link rel="preload" href="main.js" as="script">
  </head>
  <body>

    <script src="main.js"></script>
  </body>
  ```
- 预渲染:将文件预先在后台渲染
  ```html
    <link rel="prerender" href="http://example.com" >
  ```

#### （2）使用缓存机制:
- 强缓存: 服务器设置响应头Expires和Cache-Control **Cache-Control优先级大于Expires**

  ```js
    ctx.set('Expires', new Date(2018,9,22,3,30,30).toUTCString());//"Sun, 21 Oct 2018 19:30:30 GMT"

    ctx.set('Cache-Control', 30);//单位s
  ```
- 协商缓存:
  - 'Last-Modifed'与'If-Modified-Since':Last-Modified表示文件最后修改日期。If-Modified-Since为条件式请求头，将Last-Modified值发送给服务器，询问服务器在该日前后是否有更新。有更新的话将资源返回，状态码200;否则返回一个不带消息主体的304
  -  'ETag'与'If-None-Match': ETag表示文件指纹。If-None-Match将ETag发送给服务器，询问该资源ETag是否有变动。有的话将新资源返回；否则返回304。**ETag与If-None-Match优先级大于Last-Modified与If-Modified-Since**

#### （3）HTTP协议选择和设置
- 使用HTTP/1.1时设置Connection:keep-alive,否则每个请求都要建立和断开；
- 尽量使用HTTP/2.0,可以多路复用，使多个请求使用同一个TCP连接。

###  2. 渲染过程优化:
懒加载:比如对于图片而言，可以先将图片的src属性值写入自定义属性data-src中，留出占位空间，而不使用真实的img元素；一开始只加载可视区域的图片；当滚动至其他图片的空间进入可视区域时，再去用js指定img的src属性，这时才去下载图片

懒执行:将某些逻辑片段延迟到使用时在执行，一般可以通过定时器或事件触发来唤醒。该技术可用于首屏优化。

### 3.文件优化
#### (1)图片优化
- 简单图形用CSS代替图片
- 请求图片的时候请求相应大小裁剪好的图片
- 多个小图片采用image sprites技术(图像合并技术/雪碧图)


#### (2)javascript优化
- script文件可以加上defer,如果没有任何依赖的话可以加上async,这样可以并行下载script
- script代码过长，可以使用web worker技术，开启另一个线程而不影响主线程
- js代码层面优化，合理使用闭包，减少字符串计算，减少重排重绘
- 遇到渲染大规模数据时可以使员工requestAnimationFrame（参见我的博客《ErequestAnimationFrame与页面优化渲染.md》）

#### (3)CDN的使用
静态资源尽量都用CDN加载：
- 由于浏览器对单个域名有请求上线(6个)，可考虑使用多个CDN域名。
- CDN域名要与主站不同，否则每次请求都会带上主站Cookie

#### (4)代码压缩
- 线上运行的代码都必须是压缩过的，如果使用webpack压缩则需使用production模式
- 使用ES6模块，这样压缩工具如rollup、webpack会开启tree shaking。tree shaking可以找出使用的代码:基于ES6的静态引用，treeshaking通过扫描所有ES6的export，找出被import的内容并添加到最终代码中。



## 十二、GET和POST通讯的区别
- Get 请求能缓存，Post 不能

- Post 相对 Get 安全一点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。

- Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术

- URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的

- Post 支持更多的编码类型且不对数据类型限制

## 十三、webpack原理和机制 ***待看***
从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。

***待看***我写的项目h5-management-system或charts-new-system的webpack配置

## 十四、CommonJS和ES6模块异同
参考《Interview Map》

1. CommonJS支持动态导入，即支持require(`${path}/xx.js`);ES6不支持。
2. CommonJS是同步导入，在运行时加载; ES6是异步导入，在编译时输出内容，并会编译为require/exports来执行。
3. CommonJS输出的是值拷贝，对导出值进行重新赋值不会影响导入的值；ES6输出的是引用，导入导出的都指向同一个地址，导入的变量是只读的，不能赋值。

其他几种模块
- AMD: 由RequireJS提出，**提前执行依赖，推崇依赖前置**
- CMD: **延迟执行依赖，推崇依赖就近**

## 十五：js事件循环: 在浏览器和在node
### 浏览器中的js事件循环
一次正确的事件循环顺序
1. 执行同步代码（这属于宏任务macrotask）。执行过程中会产生很多执行环境（执行上下文），这些执行环境会被顺序地加入执行栈。如果遇到异步代码则会将其加入Task队列。
2. 执行栈为空，查询是否有微任务microtask。执行所有微任务。
3. 必要的话渲染UI。
4. 开始下一轮Event Loop, 执行任务队列的下一个宏任务。

### node中的js事件循环
node中的js事件循环的**宏任务**分为6个阶段
1. timer阶段：执行setTimeout和setInterval， setTimeout至少需延迟1ms
2. I/O阶段：执行回调，是除了定时器、close事件和setImmediate的回调
3. idle,prepare阶段：内部执行
4. poll阶段:***复杂，待再研究***
  - 执行到点的定时器
  - 执行poll队列中的事件，
    - 如果poll队列不为空，会遍历回调队列并同步执行
    - 如果poll队列为空：
      - 如果有setImmediate要执行，poll阶段会停止并接入check阶段执行setImmediate
      - 如果没有setImmediate要执行，会等待回调被加入到队列并立即执行回调
      - 如果有别的setTimeout要执行，回到Timer阶段执行setTimeout
5. check阶段: 执行setImmediate
6. close回调阶段：执行close事件

微任务在每个阶段完成后立即执行。

### 注意：
1. 二者microtask执行时机不同:
  - 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行
  - Node.js中，microtask 在事件循环的各个阶段之间执行
2. node.js中process.nextTick会先于其他microtask执行


## 十六：深浅拷贝问题
看我的博客《浅拷贝与深拷贝》


[记一次凉凉的小米面试](https://mp.weixin.qq.com/s/0FG90s7TGP6qWv4rUO5MhQ)

## 一、爬虫引擎是怎样抓取页面的
暂略

## 二、浏览器渲染页面的过程
复习我的博客《打开一个url时到底会发送什么》

1. 在浏览器地址栏输入url，比如http://facebook.com
2. 浏览器对url中的域名进行dns解析以查找服务器ip:
  - (1) 浏览器缓存
  - (2) 操作系统缓存
  - (3) 路由器缓存
  - (4) isp的DNS服务器缓存
  - (5) 域名递归查找，从顶级域名开始查找对应的ip地址
3. 浏览器发送一个http请求,
  ```s
  GET http://facebook.com HTTP/1.1
  User-Agent:
  Accept:
  Accept-EnCoding:
  Connection:Keep-Alive
  Cookie: name1=value1;name2=value2..
  ```
4. 浏览器返回一个301的永久重定向，告诉浏览器应该定向到http://www.facebook.com
  ```s
   HTTP/1.1 301 Moved Permanently
   Cache-Control: no-cache
   Location: http://www.facebook.com
   Content-Type:text/html;charset=utf-8
  ```
5. 浏览器进行重定向，向http://www.facebook.com发送http请求
6. 服务器接受请求并处理它，准备好html页面，并返回一个HTML响应
7. 浏览器渲染页面
8. 页面中的静态资源会发起http请求，重复上面的过程，静态资源一般有缓存

## 三、JavaScript异步变成模式
参考[JavaScript异步编程模式](http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html)

### 1. 定时器 setTimeout回调
```js
setTimeout(function(){

}, 1000)
```
### 2. 事件监听

```js
elem.addEventListener('click',function(){

},false)
```

### 3. promise
```js
(new Promise((resolve, reject) => {
  setTimeout(resolve, 3000, 'success');
}).then(result => {
  console.log(result)
}).catch(err => {
  console.err(err);
})
```

### 4. 发布/订阅
使用node核心模块events的EventEmitter
```js
import {EventEmitter} from 'events';
const myemitter = new EventEmitter();

//订阅
const myEventListener = myemitter.on('myevent', function(data) => {
  console.log(data);
});

//发布
myemitter.emit('myevent', theData);

//取消订阅
myemitter.removeListener(myEventListener);
```

## 四、解释同步/异步，阻塞/非阻塞，并行/并发的区别
### 同步异步
- 同步: 在发出一个功能调用时，在没有得到结果之前，该调用就不返回。比如script同步代码
- 异步：当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。例如js中的定时器不立刻执行，而是在合适的时机加入任务队列，等同步任务结束再执行

### 阻塞/非阻塞
- 阻塞:阻塞调用是指调用结果返回之前，当前线程会被挂起。即一个任务执行时，后面的任务要等待它执行完，比如async函数里面的await就会阻塞同一个async函数中await后面的代码
- 非阻塞:在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。即一个任务执行时，后面的任务不必等待它执行完，比如写在Promise后面的代码，Promise是非阻塞的。

### 并行/并发
- 并行：指运算中的两件或更多件事情在同一时刻发生。这种情况只会在系统CPU拥有两个独立核心时发生，这样在同一时刻才有不同的电脉冲信号发出。并行是在物理层面上的同时工作。
- 并发：两件或多件事物在同一时间段发生。比如Promise.all()或者调用多个Ajax请求。并发是在逻辑层面上的同时工作。

## 五、js实现数值千分位
```js
parseFloat(123.11344444.toFixed(3));//123.113得到数字
```

或者

```js
123.1134444.toLocaleString();//'123.113'得到字符串
```

## 六、React非父子、兄弟组件传值 
***已复习，待再整理一下***


## 七、"123456789876543212345678987654321..."的第n位是什么？

```js
function getNum(n) {
  let value = 1,increase=true;
  for(let i = 1; i < n ;i++) {
    if (value === 1) {
      increase = true;
    }
    if (value === 9) {
      increase = false;
    }
    increase ? value++ : value--;
  }
  return value;
}
```

## 八、浏览器打开一个页面前端缓存了哪些东西?
1. 强缓存的文件:
 强缓存通过服务器端设置响应头实现。响应头中的Cache-Control和expires控制的没有过期的文件。

 用koa的写法就是:
 ```js
 ctx.set('Cache-Control','max-age=30');//单位s
 ctx.set('Expires', 'new Date("2018,09,03").toUTCString()')
 ```

 2. 协商缓存的文件
 协商缓存需要客户端和服务端共同实现：

 Last-Modifed和If-Modified-Since:
 Last-Modified是本地文件的最后修改日期，If-Modified-Since是条件式请求头，If-Modified-Since会将Last-Modified发给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新资源发送回来。

 Etag和If-None-Match：
 Etag是文件指纹，If-None-Match会将ETag发送给服务器，询问该资源Etag是否有变化，有变化就将新资源发送回来。

 3. CDN缓存的静态资源

 4. 缓存的cookie、localstorage


 ## 九、Vue/React生命周期
 Vue没用过

 React：

 1. 组件初始化挂载:

 - constructor(prop)
 - componentWillMount()
 - render()
 - componentDidMount()

 2. 组件卸载

 - componentWillUnMount()

 3. 组件prop更新

 - componentWillRecieveProps(nextProps)
 - shouldComponentUpdate(nextProps,nextState)
 - componentWillUpdate(nextProps, nextState)
 - render()
 - componentDidUpdate(prevProps, prevState)

 4. 组件state更新
 - shouldComponentUpdate(nextProps,nextState)
 - componentWillUpdate(nextProps, nextState)
 - render()
 - componentDidUpdate(prevProps, prevState)

 注意：在以上生命周期方法中，只有componentWillMount、componentDidMount、componentWillRecieveProps(nextProps)、componentDidUpdate(prevProps, prevState)可以使用this.setState()

 ## 十、Koa和Express各有什么特点
 koa:
 - 洋葱式的中间件控制逻辑。Koa 应用程序是一个包含一组中间件函数的对象，它是按照类似堆栈的方式组织和执行的。当一个中间件调用 next() 则该函数暂停并将控制传递给定义的下一个中间件。当在下游没有更多的中间件执行后，堆栈将展开并且每个中间件恢复执行其上游行为。
 - 利用async/await避免回调

## 十一、webpack配置介绍
***待回顾我的项目***

## 十二、new 一个对象后发生了什么
1. 新生成了一个对象
2. 通过__proto__链接到原型
3. 绑定this
4. 返回新对象

## 十三、响应式页面
通过媒体查询
```scss
@media only screen and (min-width: 760px) and (max-width:1000px) {

}
```


实践中更多的是利用ft的库o-grid，它是基于一个叫做scss-mq的库,实现一个用于媒体查询的mixin：

```scss
$o-grid-layouts: (
  S: 490px,
  M: 740px,
  L: 980px,
  XL: 1220px
)!default;

@mixin oGridRespondTo($from: false, $to: false) {

}
```

## 十四、说一下原型和原型链？
复习我的博客《原型与原型链》。

## 十五、有没有写过比较复杂的正则？
复习我的博客《blog-js正则采用知识总结》
已复习。

比较复杂的正则： 

满足一定强度的密码：最少6位，至少包括1个大写字母、1个小写字母、1个数字、1个特殊字符

```js
/^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*?]).*$/
```
## 十六、关于axios
Axios是一个基于promise的HTTP库，可用在浏览器和node.js中。

我自己前端一般用fetch。

node一般用 fs-jetpack包来读写文件。

## 十七、前后分离的系统，一个请求出错了，如何中断其它请求?

如果多个请求是有依赖关系的，那后一个请求写在前一个请求的成功回调里面；失败就不请求了。

如果多个请求无依赖关系，则在一个请求失败后通过xhr2.abort()中断xhr2的请求。调用这个方法后，XHR对象会停止触发事件readystatechange,也不再允许访问任何与响应有关的对象属性。

## 十八、rollup的工作原理？为什么rollup打包的冗余代码较少？
***待回顾自己的项目***


## 一、箭头函数能否执行显示绑定
```js
  const a = 2;
  var b = 4;
  const myObj = {
    a: 1,
    b: 3
  }
  const myFunc = () => {
    console.log(this.a);
    console.log(this.b);
  }
  myFunc();
  //undefined
  //4

  const myFuncNew = myFunc.bind(myObj);
  myFuncNew();
  //undefined
  //4

  console.log('func2');

  function myFunc2() {
    console.log(this.a);
    console.log(this.b);
  }
  myFunc2();
  //undefined
  // 4
  
  const myFunc2New = myFunc2.bind(myObj);
  myFunc2New();
  //1
  //3
```
### 结论
箭头函数无法执行显式绑定

## 二、async await后面加promise，该promise抛出错误会怎么样？
promise放在try...catch里面
### promise放在try..catch里面
```js
try {
  new Promise((resolve, reject) => {
    setTimeout(resolve, 1000, '1')
  })
} catch(err) {
  console.log(err);
}
//结果：Promise {<pending>}
```

```js
try {
  new Promise((resolve, reject) => {
    reject('err')
  })
} catch(err) {
  console.log(err);
}
//Promise {<rejected>: "err"} 
//浏览器控制台报错 Uncaught (in promise) err
```

```js
try {
  new Promise((resolve, reject) => {
    setTimeout(reject, 1000,'err')
  })
} catch(err) {
  console.log(err);
}
//Promise {<pending>}
//浏览器控制台报错: Uncaught (in promise) err
```

可知: try...catch无法捕获异步错误，即无法捕获promise的错误。

但promise自己的catch可以捕获自己的错误。Promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止，也即是说，错误总会被下一个catch语句捕获。

### promise放在async中的await后面
```js
async function getResultOfPromise() {
  const result = await new Promise((resolve, reject) => {
    setTimeout(resolve, 1000, '1');
  });
  console.log(result);//1
  const result2 = await new Promise((resolve, reject) => {
    setTimeout(reject, 1000, '2');
  })
  console.log(result2);//Uncaught (in promise) 2: (控制台报错)
}
getResultOfPromise();
```

### 结论
await只能获取promise的resolve的值，无法获取reject的值，如果后面接的是reject的值，那么控制台只能报错。

## 三、有没有用过react的forceUpdate() ？
forceUpdate()
#### 语法
```js
component.forceUpdate(callback);
```

#### 解读
默认情况下，当组件的state或props发生更改时，组件将重新呈现。如果render()依赖于其他一些数据，则可以通过调用forceUpdate()告诉React该组件需要重新呈现。

调用forceUpdate()将导致在组件上调用render(),跳过shouldComponentUpdate()。这将触发子组件的正常生命周期方法，包括每个子组件的shouldComponentUpdate()方法。

#### 示例
forceUpdate就是重新render。有些变量不在state上，当时你又想达到这个变量更新的时候，刷新render；或者state里的某个变量层次太深，更新的时候没有自动触发render。这些时候都可以手动调用forceUpdate自动触发render

Sub.js：
```js
class Sub extends React.Component{
    construcotr(){
        super();
        this.name = "yema";
    }
    refChangeName(name){
        this.name = name;
        this.forceUpdate(); 
    }
    render(){
        return (<div>{this.name}</div>);
    }
}
```
App.js:
```js
class App extends React.Component{

    handleClick(){
        this.subRef.refChangeName("yemafuren");
    }
    render(){
        return (<div>
            <Sub ref={(sub)=>{this.subRef = sub;}} />
            <button onClick={this.handleClick}>click</button>
        </div>);
    }
}  
```