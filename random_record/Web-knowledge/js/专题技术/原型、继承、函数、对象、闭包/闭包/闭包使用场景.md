https://blog.csdn.net/yanghua_kobe/article/details/6780181

## 采用函数引用方式得setTimeout调用 （setTimeout第一个参数调用函数传参的一个实例）
setTimeout第一个参数调用函数不能传递参数，可以通过闭包来实现。
`传递内部函数的引用作为第一个参数`
```
function fa(a,b){
    /*使用函数表达式创建并放回一个匿名内部函数的引用*/  
    return (function(){
         /* 
                这个内部函数将被setTimeout函数执行； 
                并且当它被执行时， 
                它能够访问并操作外部函数传递过来的参数 
                */
        console.log(a+b);
    });
}
/* 
        调用这个函数将在它的执行上下文中创建，并最终返回内部函数对象的引用 
        传递过来的参数，内部函数在最终被执行时，将使用外部函数的参数 
        返回的引用被赋予了一个变量 
        */
var f = fa(1,2);
/*调用setTimeout函数，传递内部函数的引用作为第一个参数*/ 
setTimeout(f,3000)
```
## 将函数关联到对象的实例方法   （避免全局污染的一个实例）
需要`分配一个函数对象的引用`，`以便在未来的某个时间执行该函数`。那么`闭包对于为这个将要执行的函数提供引用`会非常有帮助。`因为该函数可能直到执行时才能够被访问`。
因为它们不知道哪个全局变量(如果存在)的引用将被分配给它们。

好处：
1. 任何DhtmlObject的实例都能够将它们自身关联到它们感兴趣的DOM元素上去，不需要去担心这些元素将被其他的代码怎么处理。
2. 不用担心被全局命名空间“污染”；
3. 不用担心与其他的DhtmlObject的实例产生冲突
```
/* 
        一个给对象实例关联一个事件处理器的普通方法， 
        返回的内部函数被作为事件的处理器， 
        对象实例被作为obj参数，对象上将要被调用的方法名称被作为第二个参数 
        */  
        function associateObjWithEvent(obj, methodName) {  
            /*返回的内部函数被用来作为一个DOM元素的事件处理器*/  
            return (function (e) {  
                /* 
                事件对象在DOM标准的浏览器中将被转换为e参数， 
                如果没有传递参数给事件处理内部函数，将统一处理成IE的事件对象 
                */  
                e = e || window.event;  
                /* 
                事件处理器调用obj对象上的以methodName字符串标识的方法 
                并传递两个对象：通用的事件对象，事件处理器被订阅的元素的引用 
                这里this参数能够使用，因为内部函数已经被执行作为事件处理器所在元素的一个方法 
                */  
                return obj[methodName](e, this);  
            });  
        }  
  
        /* 
        这个构造器函数，通过将元素的ID作为字符串参数传递进来， 
        来创建将自身关联到DOM元素上的对象， 
        对象实例想在对应的元素触发onclick、onmouseover、onmouseout事件时 
        对应的方法被调用。 
        */  
        function DhtmlObject(elementId) {  
            /* 
            调用一个方法来获得一个DOM元素的引用 
            如果没有找到，则为null 
            */  
            var el = getElementWith(elementId);  
            /* 
            因为if语句块，el变量的值在内部进行了类型转换，变成了boolean类型 
            所以当它指向一个对象，结果就为true,如果为null则为false 
            */  
            if (el) {  
                /* 
                为了给元素指定一个事件处理函数，调用了associateObjWithEvent函数， 
                利用它自己(this关键字)作为被调用方法的对象，并且提供方法名称 
                */  
                el.onclick = associateObjWithEvent(this, "doOnClick");  
                el.onmouseover = associateObjWithEvent(this, "doOnMouseOver");  
                el.onmouseout = associateObjWithEvent(this, "doOnMouseOut");  
            }  
        }  
  
        DhtmlObject.prototype.doOnClick = function (event, element) {  
            //doOnClick body  
        }  
        DhtmlObject.prototype.doMouseOver = function (event, element) {  
            //doMouseOver body  
        }  
  
        DhtmlObject.prototype.doMouseOut = function (event, element) {  
            //doMouseOut body  
        }  
```
## 封装相关的功能集

闭包可以创建额外的scope，这可以`被用来组合相关的或有依赖性的代码`。用这种方式可以最大限度地减少代码干扰的危害。

问题引出闭包：
数组将扮演着输出缓冲区的角色，但局部定义它又将会导致它在函数的每次执行时再次创建。
如果将数组提升为全局变量，这样它不需要被再次创建也能够再次使用，但是它可以再次被其它使用，使得代码失去可控性。这样可以使用闭包。
```
/* 
    定义一个全局变量：getImgInPositionedDivHtml 
    被赋予对外部函数表达式一次调用返回的一个内部函数表达式 

    内部函数返回了一个HTML字符串，代表一个绝对定位的DIV 
    包裹这一个IMG元素，而所有的变量值都被作为函数调用的参数 
*/  
var getImgInPositionedDivHtml = (function () {  
/* 
buffAr 数组被定义在外部函数表达式中，作为一个局部变量 
它只被创建一次。数组的唯一实例对内部函数是可见的， 
所以它可以被用于每一次的内部函数执行 

空字符串仅仅被用来作为一个占位符，它将被内部函数的参数代替 
*/  
    var buffAr = [  
            '<div id="',  
        '',   //index 1, DIV ID attribute  
        '" style="position:absolute;top:',  
        '',   //index 3, DIV top position  
        'px;left:',  
        '',   //index 5, DIV left position  
        'px;width:',  
        '',   //index 7, DIV width  
        'px;height:',  
        '',   //index 9, DIV height  
        'px;overflow:hidden;\"><img src=\"',  
        '',   //index 11, IMG URL  
        '\" width=\"',  
        '',   //index 13, IMG width  
        '\" height=\"',  
        '',   //index 15, IMG height  
        '\" alt=\"',  
        '',   //index 17, IMG alt text  
        '\"><\/div>'  
    ];  

    /* 
    返回一个内部函数对象，他是函数表达式执行返回的结果 
    */  
    return (function (url, id, width, height, top, left, altText) {  
        /* 
        分配各种参数给对应的数组元素 
        */  
        buffAr[1] = id;  
        buffAr[3] = top;  
        buffAr[5] = left;  
        buffAr[13] = (buffAr[7] = width);  
        buffAr[15] = (buffAr[9] = height);  
        buffAr[11] = url;  
        buffAr[17] = altText;  

        /* 
        返回连接每个元素后创建的字符串 
        */  
        return buffAr.join('');  
    });  
})(); 
```