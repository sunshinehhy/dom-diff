https://github.com/alsotang/async_demo

```
Promise.resolve('foo')
  // 1. Receive "foo" concatenate "bar" to it and resolve that to the next then
  .then(function(string) {
    return new Promise(function(resolve, reject) {
      setTimeout(function() {
        string += 'bar';
        console.log(string);  //foobar
        resolve(string);
      }, 1);
    });
  })
  // 2. receive "foobar", register a callback function to work on that string
  // and print it to the console, but not before return the unworked on
  // string to the next then
  .then(function(string) {
    setTimeout(function() {
      string += 'baz';
      console.log(string);
    }, 1)
    return string;  //直接返回数据而不是promise
  })
  // 3. print helpful messages about how the code in this section will be run
  // before string is actually processed by the mocked asynchronous code in the
  // prior then block.  
  .then(function(string) {
    console.log("Last Then:  oops...");
 
    // Note that `string` will not have the 'baz' bit of it at this point. This 
    // is because we mocked that to happen asynchronously with a setTimeout function
    console.log(string);  //foobar
  });

Last Then:  oops... 
foobar
foobarbaz
```
执行顺序：1->3->2
因为第一个return了一个promise对象 之后的then是由这个return的promise决定的  而第二个没有返回promise  


Promise.resolve('foo')
  .then(function(string) {
    return new Promise(function(resolve, reject) {
      setTimeout(function() {
        string += 'bar';
        console.log(string);  //foobar --------------1
        resolve(string);
      }, 1);
    });
  })
  .then(function(string) {
    return new Promise(function(resolve, reject) {
      setTimeout(function() {
        string += 'bar1 ';
        console.log(string);  //foobarbar1 --------------2
        resolve(string);  //如果没有此句，则仅仅执行1 2；有此句执行顺序为1 2 4 3
      }, 1);
    });
  })
  .then(function(string) {
    setTimeout(function() {
      string += 'baz';
      console.log(string); --------------3
    }, 1)
    return string;     //直接返回数据而不是promise
  }) 
  .then(function(string) {
    setTimeout(function() {
      string += 'baz1';
      console.log(string); --------------3
    }, 3)
    return 'test return string directly'; 
  }) 
  .then(function(string) {
    console.log("Last Then:  oops..."); --------------4
    console.log(string);  //foobarbar1
  });

 foobar
 foobarbar1 
 Last Then:  oops...
 foobarbar1 
 foobarbar1 baz

```
Promise.resolve('foo')
  .then(function(string) {
    return new Promise(function(resolve, reject) {
      setTimeout(function() {
        string += 'bar';
        console.log('1'+string);  //foobar --------------1
        resolve(string);
      }, 1);
    });
  })
  .then(function(string) {
    return new Promise(function(resolve, reject) {
      setTimeout(function() {
        string += 'bar1 ';
        console.log('2'+string);  //foobarbar1 --------------2
        resolve(string);  //如果没有此句，则仅仅执行1 2；有此句执行顺序为1 2 4 3
      }, 1);
    });
  })
  .then(function(string) {
    setTimeout(function() {
      string += '-3-';
      console.log('3'+string); //--------------3
    }, 1)
    return string;     //直接返回数据而不是promise
  }) 
  .then(function(string) {
    setTimeout(function() {
      string += '-4-';
      console.log('4'+string); //--------------4
    }, 1000)
    return 'test return string directly'; 
  }) 
  .then(function(string) {
    console.log('5'+string);     //--------------5
  })
  .then(function(string) {
    console.log('6'+string);     //--------------6   
  });

1foobar
2foobarbar1 
5test return string directly
6undefined
3foobarbar1 baz
4foobarbar1 baz1

4foobarbar1 -4-
3foobarbar1 -3-
4的时间比3长，就先执行3再执行4；反之先执行4再执行3。
5得到的一直是4返回的值，如果4中注释掉return 'test return string directly'; ，则5得到的是5undefined
3和4得到的是2resolve传下来的值
6获取5处返回的值，如果有返回值就获取返回值，没有返回undefinded


```

```
Promise.resolve('foo')
  .then(function(string) {
    return new Promise(function(resolve, reject) {
      setTimeout(function() {
        string += 'bar';
        console.log('1'+string);  //foobar --------------1
        resolve(string);
      }, 1);
    });
  })
  .then(function(string) {
    return new Promise(function(resolve, reject) {
      setTimeout(function() {
        string += 'bar1 ';
        console.log('2'+string);  //foobarbar1 --------------2
        resolve(string);  //如果没有此句，则仅仅执行1 2；有此句执行顺序为1 2 4 3
      }, 1);
    });
  })
  .then(function(string) {
    setTimeout(function() {
      string += '-3-';
      console.log('3'+string); //--------------3
    }, 1000)
    return string;     //直接返回数据而不是promise
  }) .then(function(string) {
    console.log('4'+string);  //foobarbar1   //--------------5
  })
  .then(function(string) {
    setTimeout(function() {
      string += '-5-';
      console.log('5'+string); //--------------4
    }, 1)
    
  }) 
  .then(function(string) {
    console.log('6'+string);  //foobarbar1   //--------------5
  });

1foobar
2foobarbar1 
4foobarbar1 
6undefined
5undefined-5-
3foobarbar1 -3-
```

**我的理解：得出结论，下一个then回调函数参数的值是得到上一个then 返回的值**



  then可以接受promise对象，也可以接受非Promise对象，但是必须会是回调函数，若没有回调函数就会忽略这个then的执行。

  then支持延续任务调用方式（Continuation tasks），而done不支持 比如then可以这样用，而done不可以： promise().then().then().then() 2. then会捕获未处理的异常然后把错误状态作为返回值返回，而done则会把异常直接抛出

  then是会返回一个promise对象，但是这个promise对象的this是你前一个promise的，如果你return 一个新的promise，this则是这个promise，所以后面的then需要依据第二个promise是否resolve

  把以上代码直接运行，不需要调用就立即执行了，一般封装在一函数中，在需要的时候去运行这个函数。

  可以操作实例:https://cnodejs.org/topic/5a28b112d3114d3e18fac8a2

  function a(callback){
      setTimeout(function(){
        console.log('kszx');
        callback('suibian');
      },1000)
  }
  a(function(data){
        console.log(data);
  })
  kszx
  suibian

  Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用
## all的用法  （异步并行执行，谁跑得慢，以谁为准执行回调）
## race的用法  （异步并行执行，谁跑得快，以谁为准执行回调）

all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思。

  https://baijiahao.baidu.com/s?id=1577217009899769781&wfr=spider&for=pc  （特别需要看。需要去整理出来自己的知识，包括catch、all、race）

  race使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作。


function sleep(wait) {
    return new Promise((res,rej) => {
        setTimeout(() => {
            console.log(wait);
            res(wait);
        },wait);
    });
}

async function demo() {
    let result01 = await sleep(100);
    //上一个await执行之后才会执行下一句
    let result02 = await sleep(10);
    let result03 = await sleep(result02 + 100);
    // console.log(result03);
    return result03;
}

demo().then(result => {
    console.log(result); //110
});

await是强制把异步变成了同步，这一句代码执行完，才会执行下一句

sleep(100).then(result => {
    return sleep(100);
}).then(result02 => {
    return sleep(10);
}).then(result03 => {
    console.log(result03);  //10   后面的结果都是依赖前面的结果。
})

https://www.jianshu.com/p/fe0159f8beb4  (需要看)
https://www.cnblogs.com/fundebug/p/6667725.html (需要看，但是需要验证他的观点)

async/await不能并行执行和循环执行，promise可以并行执行；
当内部出现一些错误时，和Promise有点类似，还是需要catch回调捕捉。