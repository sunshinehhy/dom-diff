一、实现原理：
对于DOM元素，通过`分配一个唯一的关联id把DOM元素和该DOM元素的数据缓存对象关联起来`，关联id被附加到以jQuery.expando的值命名的属性上，数据存储在全局缓存对象jQuery.cache中。在读取、设置、移除数据时，将通过`关联id从全局缓存对象jQuery.cache中找到关联的数据缓存对象`，然后在数据缓存对象上执行读取、设置、移除操作。

对于Javascript对象，数据则直接存储在该Javascript对象的属性jQuery.expando上。在读取、设置、移除数据时，实际上是对Javascript对象的数据缓存对象执行读取、设置、移除操作。

为了避免jQuery内部使用的数据和用户自定义的数据发生冲突，数据缓存模块把内部数据存储在数据缓存对象上，把自定义数据存储在数据缓存对象的属性data上。

## 内存泄露
## jQuery的缓存系统
A.`允许我们在DOM元素上附加任意类型的数据`,避免了循环引用的内存泄漏风险
B.用于存储跟dom节点相关的数据，包括事件，动画等
C.一种低耦合的方式让DOM和缓存数据能够联系起来

对于jQuery来说，数据缓存系统本来就是为事件系统服务而分化出来的，到后来，它的事件克隆乃至后来的动画列队实现数据的存储都是离不开缓存系统，所以数据缓存也算是jQuery的一个核心基础了。

jQuery的数据缓存接口：

jQuery.data( element, key, value )
.data( )

在jQuery的官方文档中，提示用户这`jQuery.data()是一个低级的方法，应该用.data()方法来代替`。$.data( element, key, value )可以对DOM元素附加任何类型的数据，但应避免循环引用而导致的内存泄漏问题。
二者都是用来`在元素上存放数据`也就平时所说的数据缓存,都返回jQuery对象，但是内部的处理确有本质的区别。
```
在dom元素上附加任何类型的数据
jQuery.data(div, "blah", "hello");  
value = jQuery.data(div, "blah");
jQuery.removeData(div, "blah");
```

## 静态与实例方法的区别
jQuery.data(ele) 与 $(ele).data()

这两个函数都是用来在元素上`存放数据`，也就平时所说的数据缓存,`都返回jQuery对象`，初学时很容易`让人混淆`，尤其是`给dom元素添加缓存数据时`。

简单的来说：

1.jQuery.data()可以`实现为dom元素或js对象添加缓存`
2.$("ele").data()实是对前者的扩展，其目的是`可以方便的通过选择器为多个dom元素添加缓存数据`
虽然大体的意思一样，但是2个接口在处理上却有差别，也是我们容易忽视的

我们看右边的代码块

为什么通过.$("ele").data()原型方法会覆盖前面key相同的值呢？

```
<div id="aaron">缓存接口测试</div></br>

var ele1 = $("#aaron");
var ele2 = $("#aaron");

ele1.data('a',1111);
ele2.data('a',2222);  //$("ele").data()原型方法会覆盖前面key相同的值

show('第一组,通过$().data()的方式,只取到最后一个a值,之前的被覆盖')
show(ele1.data('a'))
show(ele2.data('a'))

//=======第二组=========
show('第二组,通过$.data的方式,取到2组b值，未覆盖')
$.data(ele1,"b","1111")
$.data(ele2,"b","2222")

function show(data) {
    if (arguments.length == 2) {
		var info = arguments[0]
		var data = arguments[1];
		for (var key in data) {
			$("body").append('<li>' + info +'key->' + key + '; value->' + data[key] + '</li>')
		}
		return
	}

	if (!data) {
		return $("body").append('</br>')
	}
	if (typeof data === 'object') {
		for (var key in data) {
			$("body").append('<li>key->' + key + '; value->' + data[key] + '</li>')
		}
	} else {
		$("body").append('<li>' + data + '</li>')
	}
}

```

## jQuery缓存的设计思路

jQuery缓存设计接口对数据的处理有`如下几种`：
- 用name和value为对象附加数据
- 一个对象为对象附加数据
- 为 DOM Element 附加数据

常规的数据缓存，我们都大多`为了方便直接就绑定到了dom对应的元素上了`，`最为常见的就是事件对象的回调函数了`，还有`一些DOM的属性`。当然这也不是不可以，jQuery早期就是这么干的，但是容易引发循环引用，也会带来一定的全局污染的问题。那么jQuery在之后的改进就独立出了一个”数据缓存“的模块。

`其核心的关键就是`：数据存放在内存中，通过一个`映射关系与直接的DOM元素`发生关联

数据缓存，jQuery现在支持两种：
1. dom元素，数据存储在jQuery.cache中。
2. 普通js对象，数据存储在该对象中。

首先先要在内存中`开辟一个区域，用来保存数据，jQuery用cache对象{}`,那么所有的数据无法就是针对cache的CURD操作了。

1. :如果是DOM元素，通过分配一个唯一的关联id把DOM元素和该DOM元素的数据缓存对象关联起来，关联id被附加到以jQuery.expando的值命名的属性上，数据存储在全局缓存对象jQuery.cache中。在读取、设置、移除数据时，将通过关联id从全局缓存对象jQuery.cache中找到关联的数据缓存对象，然后在数据缓存对象上执行读取、设置、移除操作。

2. :如果是Javascript对象，数据则直接存储在该Javascript对象的属性jQuery.expando上。在读取、设置、移除数据时，实际上是对Javascript对象的数据缓存对象执行读取、设置、移除操作。

3. :为了避免jQuery内部使用的数据和用户自定义的数据发生冲突，数据缓存模块把内部数据存储在数据缓存对象上，把自定义数据存储在数据缓存对象的属性data上。

所以jQuery在数据缓存的处理抽出一个Data类出来，通过2组不同的实例，分别处理不同的处理类型：
```
var data_priv = new Data();
var data_user = new Data();
```
一个是给jQuery内部只用，比如数据对象，queue，Deferred，事件，动画缓存；另一个对象data_user是提供给开发者使用的，比如$.attr(),$.data等等.
```
var obj = {};
$.data(obj, 'name', 'aaron');
show($.data(obj, 'name')) 

//2
var obj = {};
$.data(obj, {
  name1: 'aaron1'
});
show($.data(obj))

//3
var $body = $("body")
$body.data("foo", 52);
show($body.data('foo'))

```

## Data类的设计
我们看看Data类是如何构建这个缓存池的：

（1）先在jQuery`内部创建一个cache对象{}`, 来保存缓存数据。 然后往需要进行缓存的DOM节点上`扩展一个值为expando的属性`
```
function Data() {
    Object.defineProperty(this.cache = {}, 0, {
        get: function() {
            return {};
        }
    });
    this.expando = jQuery.expando + Math.random();
}
```
注：expando的值，用于`把当前数据缓存的UUID值`做一个节点的属性给写入到指定的元素上形成关联桥梁,所以，所以元素本身具有这种属性的可能性很少，所以可以忽略冲突。

（2）接着`把每个节点的dom[expando]的值都设为一个自增的变量id`，保持全局唯一性。 这个id的值就作为cache的key用来关联DOM节点和数据。也就是说`cache[id]就取到了这个节点上的所有缓存`，即id就好比是打开一个房间(DOM节点)的钥匙。 而`每个元素的所有缓存都被放到了一个map映射里面，这样可以同时缓存多个数据`。

```
Data.uid = 1;
```
关联起dom对象与数据缓存对象的一个索引标记，换句话说，先在dom元素上找到expando对应值，也就uid，然后通过这个uid找到数据cache对象中的内。

（3）所以cache对象结构应该像下面这样：
```
var cache = {
  "uid1": { // DOM节点1缓存数据，
    "name1": value1,
    "name2": value2
  },
  "uid2": { // DOM节点2缓存数据，
    "name1": value1,
    "name2": value2
  }
  // ......
};
```
每个uid对应一个elem缓存数据，每个缓存对象是可以由多个name value(名值对)对组成的，而value是可以是任何数据类型的。 

**流程分解：（复杂的过滤，找重的过程去掉）**

第一步：jQuery`本身就是包装后的数组结构`，这个不需要解析了

第二步：通过data存储数据
```
为了不把数据与dom直接关联，所以会把数据存储到一个cache对象上
产生一个 unlock = Data.uid++; unlock 标记号
把unlock标记号，作为一个属性值 赋予$body节点
cache缓存对象中开辟一个新的空间用于存储foo数据，this.cache[ unlock ] = {};
最后把foo数据挂到cache上,cache[ data ] = value;
```
第三步：通过data获取数据
```
从$body节点中获取到unlock标记
通过unlock在cache中取到对应的数据
```
## 实例方法的设计
前面的第三小节留下了一个疑问：`jQuery.data() 与 .data()为什么会有区别？`

jQuery的方法设计大都是多用的，可以根据传递参数的个数判断是set还是get处理，不仅如此jQuery还对参数的传递类型还抽出了一个处理的方法jQuery.access，我们可以传递字符串、数组、对象等等，根据这种类型`自动分解成接口所有能接受的参数。`

省略了部分，比如数据的过滤，HMLT5 data的处理之类，保留直接的处理，如下代码：
```
jQuery.fn.extend({
    data: function(key, value) {
      return access(this, function(value) {
        // 通过access解析出参数 value的值
      }, null, value, arguments.length > 1, null, true)
    })
}
```
通过access解析后的参数就能`让data_user接口所接收`，此时我们可以调用数据对象接口开始对数据进行存储设置了。
```
this.each(function() {
   var data = data_user.get( this, camelKey );
   data_user.set( this, camelKey, value );
});
```
因为jQuery可以是一个元素合集，所以`内部需要通过each对每一个合集都遍历处理`，

对数据的存储内部就是调用的data_user.get缓存类的接口。
```
get: function(owner, key) {
  var cache = this.cache[this.key(owner)];
  return key === undefined ?
    cache : cache[key];
}
```
通过get方法通过key去cache中取得之前的值，如果没有则新开辟一个空间用来存储之后的新值，

通过data_user.set去设置这个新的值：
```
set: function(owner, data, value) {
  var prop,
    unlock = this.key(owner),
    cache = this.cache[unlock];
  cache[data] = value;
  return cache;
}
```
取出cache中对应的存储空间，然后可见

cache[ data ] = value;
`数据直接就是通过对象的键值对的方式存储在内存中的`。

`当我们重复同一个key的时候，其实是反复操作同一个cache缓存区下的同一个key`

所以当下面：
```
cache[‘bar’] = {
     myType: "慕课网一",
});

cache[‘bar’] = {
     myType: "慕课网二",
});
```
这种情况下，肯定是`被覆盖掉了`。所以也就为什么通过实例的接口会覆盖数据了。
```
var body1 = $("body")
var body2 = $("body")


body1.data("bar", {
  myType: "慕课网一",
  count: 10
});

body2.data("bar", {
  myType: "慕课网二",
  count: 20
});

show( body1.data("bar") )
show('</br>')
show(body2.data("bar") )

key->myType; value->慕课网二
key->count; value->20

key->myType; value->慕课网二
key->count; value->20
```

## 静态接口设计
通过源码可见，静态方法是直接操作数据类的 data_user.access 方法
```
jQuery.extend({
    data: function(elem, name, data) {
      return data_user.access(elem, name, data)
}
```
静态方法data的实现不像attr操作直接把数据作为属性捆绑到元素节点上，如果为DOM Element 附加数据；DOM Element 也是一种 Object ，但 IE6、IE7 对直接附加在 DOM Element 上的对象的垃圾回收存在问题；因此我们将这些数据存放在全局缓存（我们称之为“globalCache”）中，即 `“globalCache” 包含了多个 DOM Element 的 “cache”，并在 DOM Element 上添加一个属性，存放 “cache” 对应的 uid。`

最后可见：

1：jQuery.data(element,[key],[value])，`每一个element都会有自己的一个{key:value}对象保存着数据`，所以新建的对象就算有key相同它也不会覆盖原来存在的对象key所对应的value，因为`新对象保存是是在另一个{key:value}对象中`

2：$("div").data("a","aaaa") 它是把数据绑定每一个匹配div节点的元素上

源码可以看出来，说到底，`数据缓存就是在目标对象与缓存体间建立一对一的关系`，整个Data类其实都是围绕着 thia.cache 内部的数据做增删改查的操作。
```
var body1 = $("body")
var body2 = $("body")


$.data(body1, "bar", '慕课网一');
$.data(body2, "bar", '慕课网二');

show(  $.data(body1, "bar") )
show(  $.data(body2, "bar") )


慕课网一
慕课网二
```