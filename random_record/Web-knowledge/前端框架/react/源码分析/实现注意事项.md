https://reactjs.org/docs/implementation-notes.html

本节是stack reconciler的实现注意的集合。

它是非常技术性的，并且假定您对React public API以及如何将其划分为core, renderers, and the reconciler有很强的理解。如果您对React代码基不是很熟悉，请首先阅读代码基概述。

它还假定您理解了React组件、它们的实例和元素之间的差异。

堆栈协调器在第15和更早的时候使用。它位于src/renderers/shared/stack/ reconciliation ler。

## Video: Building React from Scratch
https://www.youtube.com/watch?v=_MAD4Oly9yg

reconciler本身没有公共API。像React DOM和React Native这样的Renderers，根据用户编写的React组件有效地使用它去更新用户界面。

## Mounting as a Recursive Process  作为递归过程的安装。
让我们考虑第一次安装组件:ReactDOM.render(<App />, rootEl);

React DOM将把<App />传递给和解程序。记住，<App />是一个React元素，也就是要呈现的内容的描述。你可以把它想象成一个普通的物体:
```
console.log(<App />);
// { type: App, props: {} }
```
协调器将检查App是类还是函数。

如果App是一个函数，调解器会调用App(props)获取呈现的元素。

如果App是一个类，那么协调器将使用新的App(道具)实例化一个App，调用componentWillMount()生命周期方法，然后调用render()方法来获取呈现的元素。

无论哪种方式，reconciler都将学习元素App“呈现”。

这一过程是递归的。App可以渲染到<Greeting />，也可以渲染到<Button />，等等。reconciler将在了解每个组件呈现的内容时，递归地通过用户定义的组件“钻取”。

你可以把这个过程想象成一个伪代码:
```
< 代码没添加进来，看链接 >


注意:

这确实是伪代码。它与实际的实现不相似。它还会导致堆栈溢出，因为我们还没有讨论何时停止递归。
```
让我们回顾一下上面这个例子中的一些关键思想:

React元素是表示组件类型(如App)和props的普通对象。
用户定义的组件(例如App)可以是类或函数，但它们都是“呈现”元素。
“挂载”是一个递归过程，它根据顶级的React元素(例如<App />)创建DOM或Native tree。

## Mounting Host Elements
如果我们没有在屏幕上显示一些东西，这个过程将是无用的。

除了用户定义的(“复合”)组件之外，React元素还可以表示特定于平台的(“宿主”)组件。例如，Button可能从其呈现方法返回<div />。

如果元素的类型属性是字符串，我们处理的是一个主机元素:
```
console.log(<div />);
// { type: 'div', props: {} }
```

注意：reconciler本身并不与DOM绑定。挂载的确切结果(有时在源代码中称为“挂载映像”)取决于渲染器，可以是DOM节点(response DOM)、字符串(response DOM服务器)或代表本机视图的数字(response native视图)。

如果我们扩展代码来处理主机元素，会是这样的:
```
```
这正在发挥作用，但离reconciler真正实现的方式还很遥远。缺少的关键要素是对更新的支持。

## 引入内部实例
React的关键特性是可以重新呈现所有内容，它不会重新创建DOM或重置状态:
```
ReactDOM.render(<App />, rootEl);
// Should reuse the existing DOM:
ReactDOM.render(<App />, rootEl);
```
但是，上面的实现只知道如何挂载初始树。它不能对它执行更新，因为它不存储所有必要的信息，比如所有公共实例，或者哪个DOM节点对应于哪个组件。

The stack reconciler codebase 通过产生mount()函数方法并将其放在一个类上来解决这个问题。这种方法有缺点，我们在不断重写reconciler的过程中正朝着相反的方向前进。然而，这就是它现在的工作方式。

我们将创建两个类:DOMComponent和CompositeComponent，而不是单独的mountHost和mountComposite函数。

两个类都有一个接受元素的构造函数，以及一个返回已挂载节点的mount()方法。我们将用实例化正确类的工厂来替换顶级的mount()函数:
```
function instantiateComponent(element) {
  var type = element.type;
  if (typeof type === 'function') {
    // User-defined components
    return new CompositeComponent(element);
  } else if (typeof type === 'string') {
    // Platform-specific components
    return new DOMComponent(element);
  }  
}
```
首先，让我们来考虑一下CompositeComponent的实现:
```
```

这与我们以前的mountComposite()实现没有太大的不同，但是现在我们可以保存一些信息，比如用于更新期间的this.currentElement, this.renderedComponent, and this.publicInstance。

注意，CompositeComponent的实例与用户提供的element.type的实例不同。comtecposiomponent是我们的协调器的实现细节，从不向用户公开。用户定义类是我们从element.type读取的，和创建它的一个实例的CompositeComponent。

为了避免混淆，我们将CompositeComponent和DOMComponent的实例称为“内部实例”。它们存在，因此我们可以将一些长期存在的数据与它们关联起来。只有renderer and the reconciler 才知道它们的存在。

相反，我们将用户定义类的实例称为“公共实例”。公共实例是您在render()和自定义组件的其他方法中看到的。

将mountHost()函数重构为DOMComponent类上的mount()方法，看起来也很熟悉:
```
```
与mountHost()进行重构后的主要区别是我们现在保留了this.node 和与内部DOM组件实例相关联的 this.renderedChildren。我们还将在将来使用它们来应用非破坏性更新。

因此，每个内部实例(组合或主机)现在指向它的子内部实例。为了便于可视化，如果函数<App>组件呈现<Button>类组件，按钮类呈现<div>，那么内部实例树将如下所示:
```
[object CompositeComponent] {
  currentElement: <App />,
  publicInstance: null,
  renderedComponent: [object CompositeComponent] {
    currentElement: <Button />,
    publicInstance: [object Button],
    renderedComponent: [object DOMComponent] {
      currentElement: <div />,
      node: [object HTMLDivElement],
      renderedChildren: []
    }
  }
}
```
在DOM中，你只能看到<div>。然而，内部实例树包含复合和宿主内部实例。

复合内部实例需要存储:
- 当前元素。
- 元素类型为类的公共实例。
- 单个呈现的内部实例。它可以是DOMComponent也可以是CompositeComponent。

主机内部实例需要存储:
- 当前元素。
- DOM节点。
- 所有子内部实例。它们都可以是DOMComponent或CompositeComponent。

如果您很难想象内部实例树在更复杂的应用程序中是如何构建的，那么React DevTools可以给您一个近似，因为它用灰色突出显示主机实例，用紫色突出显示复合实例:
```
```
为了完成这个重构，我们将引入一个函数，该函数将一个完整的树装载到一个容器节点中，就像ReactDOM.render()一样。它返回一个公共实例，也类似于ReactDOM.render():
```
```
## Unmounting
既然我们有了保留子节点和DOM节点的内部实例，我们就可以实现卸载。对于复合组件，卸载调用生命周期挂钩并递归。
```
```
对于DOMComponent，卸载告诉每个子挂载:
```
```
实际上，卸载DOM组件也会删除事件侦听器并清除一些缓存，但我们将跳过这些细节。

现在，我们可以添加一个新的顶级函数unmountTree(containerNode)，它与ReactDOM.unmountComponentAtNode()类似:
```
```

为了使其工作，我们需要从DOM节点读取内部根实例。我们将修改mountTree()，将_internalInstance属性添加到根DOM节点。我们还将教授mountTree()来销毁任何现有树，因此可以多次调用它:
```
```
现在，运行unmountTree()或反复运行mountTree()，删除旧的树并在组件上运行componentWillUnmount()生命周期钩子。

## Updating
在前一节中，我们实现了卸载。然而，如果每个prop都被卸载并安装到整个树中，那么React就不是很有用了。协调器的目标是在可能的情况下重用现有实例，以保存DOM和状态:
```
var rootEl = document.getElementById('root');

mountTree(<App />, rootEl);
// Should reuse the existing DOM:
mountTree(<App />, rootEl);
```
我们将再用一个方法扩展我们的内部实例契约。除了mount()和unmount()之外，DOMComponent和CompositeComponent都将实现一个名为receive(nextElement)的新方法:
```
```
它的工作是做任何必要的事情，使组件(及其任何子组件)与nextElement提供的描述保持最新。

这部分通常被描述为“虚拟DOM扩散”，尽管实际发生的情况是我们递归地遍历内部树并让每个内部实例接收更新。

## Updating Composite Components
当复合组件接收到一个新元素时，我们运行componentWillUpdate()生命周期挂钩。

然后我们用新的道具重新渲染组件，并获得下一个渲染元素:
```
```
接下来，我们可以查看呈现的元素的类型。如果自上次呈现以来类型没有更改，则还可以对下面的组件进行适当的更新。
例如，如果第一次返回<Button color="red" />，第二次返回<Button color="blue" />，我们只需告诉相应的内部实例receive()下一个元素:
```
```
但是，如果下一个呈现的元素的类型与前面呈现的元素不同，我们就不能更新内部实例。一个<button>不能“变成”一个<input>。

相反，我们必须卸载现有的内部实例，并装入与呈现的元素类型相对应的新实例。例如，当先前呈现<button />的组件呈现<input />时，就会发生这种情况:
```
```
综上所述，当一个复合组件接收到一个新元素时，它可以将更新委托给它呈现的内部实例，也可以卸载它并在其位置挂载一个新的实例。

组件重新挂载而不是接收元素的另一种情况是，当元素的键发生变化时。我们在本文档中不讨论密钥处理，因为它增加了本就复杂的教程的复杂性。

注意，我们需要在内部实例契约中添加一个名为getHostNode()的方法，以便能够定位特定于平台的节点，并在更新期间替换它。它的实现对于两个类都很简单:
```
```
## Updating Host Components
主机组件实现(如DOMComponent)更新方式不同。当它们接收到一个元素时，它们需要更新底层特定于平台的视图。在发生React DOM时，这意味着更新DOM属性:
```
```
然后，主机组件需要更新它们的子组件。与复合组件不同，它们可能包含多个子组件。

在这个简化的示例中，我们使用一个内部实例数组并对其进行迭代，根据接收到的类型是否匹配以前的类型来更新或替换内部实例。除了插入和删除之外，真正的协调器还在帐户中使用元素的键并跟踪移动，但是我们将省略这个逻辑。

我们收集列表中的子节点的DOM操作，以便我们可以批量执行:
```
```
作为最后一步，我们执行DOM操作。同样，真正的协调代码更复杂，因为它也处理移动:
```
```
这就是用来更新主机组件的。

## Top-Level Updates
既然CompositeComponent和DOMComponent都实现了receive(nextElement)方法，那么当元素类型与上次相同时，我们可以更改顶级mountTree()函数来使用它:
```
```
现在用相同类型调用两次mountTree()并不具有破坏性:
```
```
这些是如何反应的基本原理。

## 我们遗漏了
