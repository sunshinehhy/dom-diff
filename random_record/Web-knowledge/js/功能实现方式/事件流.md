## 我的实例

```
<div id="outer">
    <div id="middle">
        <div id="inner">
            click me!
        </div>
    </div>
</div>

    var innerCircle= document.getElementById("inner");
    innerCircle.addEventListener("click", function () {
        alert("innerCircle的click事件在捕获阶段被触发");
    },true);
    innerCircle.addEventListener("click", function () {
        alert("innerCircle的click事件在冒泡阶段被触发");
    },false);
    var middleCircle= document.getElementById("middle");
    middleCircle.addEventListener("click", function () {
        alert("middleCircle的click事件在捕获阶段被触发");
    },true);
    middleCircle.addEventListener("click", function () {
        alert("middleCircle的click事件在冒泡阶段被触发");
    },false);
    var outerCircle= document.getElementById("outer");
    outerCircle.addEventListener("click", function () {
        alert("outerCircle的click事件在捕获阶段被触发");
    },true);
    outerCircle.addEventListener("click", function () {
        alert("outerCircle的click事件在冒泡阶段被触发");
    },false);

```
当点击inner，执行顺序：

outerCircle的click事件在捕获阶段被触发--》middleCircle的click事件在捕获阶段被触发--》innerCircle的click事件在捕获阶段被触发--》innerCircle的click事件在冒泡阶段被触发--》middleCircle的click事件在冒泡阶段被触发--》outerCircle的click事件在冒泡阶段被触发

当点击middle，执行顺序：

middleCircle的click事件在捕获阶段被触发--》outerCircle的click事件在捕获阶段被触发--》outerCircle的click事件在冒泡阶段被触发--》middleCircle的click事件在冒泡阶段被触发


当把每个动作写出来，就很容易观察到现象。


## 事件委托

给最外面的ul加点击事件，那么里面的li，a做点击事件的时候，都会冒泡到最外层的ul上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。

https://www.cnblogs.com/liugang-vip/p/5616484.html

`适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress`。

值得注意的是，`mouseover和mouseout`虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为`需要经常计算它们的位置，处理起来不太容易`。

不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。

## 用冒泡的思路实现时间委托（也就是动作仅仅写在父级上，这样就不用在每个子元素上重复写动作）

如果需要父元素点击不触发，仅仅子元素被点击触发：

思路：可以比较e.target == e.currentTarget
```
if(e.target == e.currentTarget){
    return;
}
```


## onclick和addEventLister

### 区别
onclick：
优点： 
- 简洁 
- 处理事件的this关键字指向当前元素 
缺点： 
- 不能对事件捕获或事件冒泡进行控制，`只能使用事件冒泡，无法切换成事件捕获 `
- `一次只能对一个元素绑定一个事件处理程序`，当使用window.onload属性时，会覆盖采用相同方法所绑定的事件代码

addEventListener：

优点： 
- 可以支持事件处理的捕获阶段，也可以支持时间处理的冒泡阶段，两个阶段都是通过addEventListener最后一个参数设置为false(默认值，表示事件冒泡)或者true(表示事件捕获)来切换 
- 事件处理 this与onclick一样 
- 事件处理函数中，event对象总是作为第一个可用参数 
- 你可以为某个元素绑定多个事件而不会覆盖之前绑定的处理程序 （按照顺序执行）

缺点： 
- IE8以下不支持

使用addEventListener的好处就是可以添加多个事件处理函数。
```
<div class="animate" id="animate"><div id="sp1"><div id="sp2">22</div></div></div>

var animate = document.getElementById('animate');
var sp1 = document.getElementById('sp1');
var sp2 = document.getElementById('sp2');
animate.onclick = function(){
    console.log('a1');   //不会执行
}
animate.onclick = function(e){
    console.log('sp0 click');  //会执行
}
sp1.onclick = function(e){
    console.log('sp1 click');  //点击子，有冒泡，但没用捕获
}
sp2.onclick = function(e){
    console.log('sp2 click');  //点击子，有冒泡，但没用捕获
}

 animate.addEventListener('click',function(e){
     console.log('a1 listener');  //会执行
 },true);

animate.addEventListener('click',function(e){
    console.log('sp0 listener');  //会执行
    // console.log( e.target.innerHTML );
},false);

sp1.addEventListener('click',function(e){
    console.log('sp1 listener');  //没触发捕获事件
},false);

sp2.addEventListener('click',function(e){
    console.log('sp2 listener');  //没触发捕获事件
},false);

var handle = function(){
    console.log('delete listener');  //不会输出，因为删除了
}
sp2.addEventListener('click',handle,false);

sp2.removeEventListener('click',handle,false);

// sp0 listener sp listener  sp2 listener   true     捕获
// sp2 listener sp listener  sp1 listener   false 默认冒泡
//由此得出结论addEventListener支持冒泡和捕获，onclick只支持冒泡
```

### 解除事件绑定
对于onclick

dd.onclick = null;

addEventListener只能使用removeEventListener移除。移除时传入的参数与添加处理程序时使用的参数相同。
```
function clickShow(){
    console.log( 'clickShow' );
}

function removeShow(){
    console.log( 'removeShow' );
    dd.removeEventListener('click',clickShow,false/true);
}
dd.addEventListener('click',clickShow,flase/true);//当第三个参数flase/true存在的时候 那么移除的时候也应该带有第三个参数,如果没有可以不带

cc.addEventListener('click',removeShow)
```