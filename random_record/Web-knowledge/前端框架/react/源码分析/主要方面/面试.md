## React中调用setState之后发生了什么事情?
React会将`当前传入的参数对象与组件当前的状态合并`,然后`触发调和过程`,在调和的过程中,React会以`相对高效的方式根据新的状态`构建React元素树并且重新渲染整个UI界面.

React得到的元素树之后,React会自动`计算出新的树与老的树的节点的差异`,然后根据差异`对界面进行最小化的渲染`,在React的差异算法中,React能够精确的`知道在哪些位置发生看改变以及应该如何去改变`,这样就保证了UI是`按需更新的而不是重新渲染整个界面`.

## React中Element与Component的区别?

ReactElement是`描述屏幕上所见的内容的数据结构,是对于UI的对象的表述`.典型的ReactElement就是利用JSX构建的声明式代码片段,然后被转化为createElement的调用组合.
ReactComponent则是可以接收参数输入并且`返回某个ReactElement的函数或者类`.

## 在什么情况下会优先选择使用ClassComponent而不是FunctionalComponent?

组件需要`包含内部状态或者使用到生命周期函数`的时候使用ClassComponent,否则使用函数式组件

## React中的refs属性的作用是什么?
Refs是React提供给我们`安全的访问DOM元素或者某个组件实例的句柄`,我们可以为元素添加ref属性然后在回调函数中接收该元素在DOM树中的句柄,该值会作为回调函数的第一个参数的返回.
```
class CustomerForm extends Component{
    handleSubmit = () => {
        console.log('Input Value:'+this.input.value);
    }
    render(){
        return (
            <form onSubmit = {this.handleSubmit}>
                <input type="text" ref={(input)=> this.input = input } />
                <button type="submit">Submit</botton>
            </form>
        )
    }
}
```
Input域中包含了一个ref属性,该属性的声明的回调函数会`接收inout对应的DOM元素`,我们将其绑定到this指针以便在其他的类函数中使用,`refs并不是类组件的专属`,`函数式组件同样可以利用闭包的方式暂时存储其值`.
```
function CustomerForm(handleSubmit){
    let inputElement ;
    return (
        <form onSubmit = {()=>handleSubmit(inputElement.value)}>
        <input type='text' ref={(input) => 
            inputElement = input 
        } />
        <button type="submit">Submit</botton>
        </form>
    )
}
```
## React中keys的作用是什么?
Keys 是React在`操作列表中元素被修改,添加,或者删除的辅助标识.`
```
render(){
    return (
        <ul>
            {this.state.todoItems.map(({task,uid})=>{
                return <li key={uid}>{task}</li>
            })}
        </ul>
    )
}
```
在开发过程中,我们需要保证某个元素的key 在其同级元素中具有唯一性,在ReactDiff算法中React`会借助元素的Key值来判断该元素是新创建的还是被移动而来的元素`,React会保存这个辅助状态,从而减少不必要的元素渲染.此外,React还需要`借助Key值来判断元素与本地状态的关联干洗`,因此我们在开发中不可忽视Key值的使用.

如果你创建了类似于下面的 Twitter 元素,那么他相关的类定义是什么样子的?
```
<Twitter username='chuhan'>
    {(user)=> user === null ? <Loading /> : <Badage info = {user}>}
</Twitter>
import React,{Component,PropTypes} from 'react';
import fetchUser from 'Twitter';

class Twitter extends Component {
    //todo something
}
```
回调渲染模式(Render Callback Pattern),在这种模式中,`组件会接收某个函数作为子组件`,然后在渲染函数中以props.children进行调用.
```
import React ,{Component,PropTypes} from 'react';
import fetchUser from 'Twitter';

class Twitter extends Component{
    state = {
        user : null
    }
    satic propTypes = {
        userName.propTypes.String.isRequied
    }
    componentDidMount(){
        fetchUser(this.props.userName)
            .then((user)=>{
                this.setState({user})
            })
    }
    render(){
        return this.props.children(this.state.user)
    }
}
```
此模式的优势在于将父组件与子组件解耦,父组件可以直接访问子组件的内部状态而`不需要再通过Props传递`,这样父组件能够更为`方便地控制子组件展示的UI界面`.如果将原本展示的Badge替换为Profile,`可以方便的修改回调函数来实现`
```
<Twitter username="chuhan">
    { (user) => user === null }
</Twitter>
```

## redux中间件

中间件提供第三方插件的模式，自定义拦截 action -> reducer 的过程。变为 action -> middlewares -> reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过滤，日志输出，异常报告等功能。

常见的中间件：

redux-logger：提供日志输出

redux-thunk：处理异步操作

redux-promise：处理异步操作，actionCreator的返回值是promise

 

## redux有什么缺点

1.一个组件所需要的数据，`必须由父组件传过来，而不能像flux中直接从store取`。

2.当一个组件相关数据更新时，`即使父组件不需要用到这个组件，父组件还是会重新render`，可能会有效率影响，或者需要写复杂的shouldComponentUpdate进行判断。

 

## react组件的划分业务组件技术组件？

根据组件的职责通常把组件分为UI组件和容器组件。

`UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。`

两者通过React-Redux 提供connect方法联系起来。

具体使用可以参照如下链接：http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html

 

## react生命周期函数

这个问题要考察的是组件的生命周期

一、初始化阶段：

getDefaultProps:获取实例的默认属性

getInitialState:获取每个实例的初始化状态

componentWillMount：组件即将被装载、渲染到页面上

render:组件在这里生成虚拟的DOM节点

componentDidMount:组件真正在被装载之后

二、运行中状态：

componentWillReceiveProps:组件将要接收到属性的时候调用

shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回false，接收数据后不更新，阻止render调用，后面的函数不会被继续执行了）

componentWillUpdate:组件即将更新不能修改属性和状态

render:组件重新描绘

componentDidUpdate:组件已经更新

三、销毁阶段：

componentWillUnmount:组件即将销毁

 

5、react性能优化是哪个周期函数？

shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom。因为dom的描绘非常消耗性能，如果我们能在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能。

详细参考：

https//segmentfault.com/a/1190000006254212

 

## 为什么虚拟dom会提高性能?

虚拟dom`相当于在js和真实dom中间加了一个缓存`，利用dom diff算法`避免了没有必要的dom操作`，从而提高性能。

具体实现步骤如下：

用 JavaScript `对象结构表示 DOM 树的结构`；然后用这个树构建一个真正的 DOM 树，插到文档当中

当`状态变更的时候，重新构造一棵新的对象树`。`然后用新的树和旧的树进行比较`，记录两棵树差异

把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。

参考链接：

https://www.zhihu.com/question/29504639?sort=created
 



## react性能优化方案

（1）重写shouldComponentUpdate来避免不必要的dom操作。

（2）使用 production 版本的react.js。

（3）使用key来帮助React识别列表中所有子组件的最小变化。

参考链接：

https://segmentfault.com/a/1190000006254212
 
 

## 简述flux 思想

Flux 的最大特点，就是数据的"单向流动"。

1.用户访问 View

2.View 发出用户的 Action

3.Dispatcher 收到 Action，要求 Store 进行相应的更新

4.Store 更新后，发出一个"change"事件

5.View 收到"change"事件后，更新页面

参考链接：

http://www.ruanyifeng.com/blog/2016/01/flux.html

## React项目用过什么脚手架？Mern? Yeoman?

Mern：MERN是脚手架的工具，它可以很容易地使用Mongo, Express, React and NodeJS生成同构JS应用。它最大限度地减少安装时间，并得到您使用的成熟技术来加速开发。

参考链接：http://www.open-open.com/lib/view/open1455953055292.html

##  疑问
最后面执行卸载，渲染到页面中卸载能看到那个过程吧？
有元素才能有元素删除