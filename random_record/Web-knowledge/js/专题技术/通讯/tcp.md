## 重点
https://www.cnblogs.com/ImBit/p/5513401.html
1. TCP（Transmission Control Protocol，传输控制协议）
2. HTTP（HyperText Transfer Protocol，超文本传输协议）

握手成功之后，就可以进行数据传输。

发送请求的过程是从最顶层（应用层）出发，每一层负责封装属于自己的信息到请求中，最后将一整个请求发送给对方。

接收请求的过程是从最底层（网络接口层）开始，每一层的协议负责解析属于自己的东西，比如网际层（IP）处理ip信息，传输层（TCP）处理点对点的端口，应用层（HTTP）处理Request或Response的Line\Header\Body。
## TCP/IP分层模型

1、数据包首部
每个分层都会对所发送的数据附加一个首部，首部中包含该层必要的信息；通常为协议提供的信息为包首部，所要发送的内容为数据

关于包、帧、数据报、段、消息的概述：

包：一个概括性术语，指数据整体

帧：数据链路层中包的单位

数据报：IP和UDP等网络层以上分层中包的单位

段：TCP数据流中的信息

消息：应用协议中数据的单位

TCP是英特网上的可靠连接，`TCP为HTTP提供了一条可靠地比特传输通道`，从TCP连接一端填入的字节会从另一端以原有的顺序、正确的传送出来。

HTTP在传送一条报文时，会`以流的形式将报文数据通过打开的TCP连接按序传输`。TCP收到数据流之后，将其划分为被称为段的小数据块，封装在IP分组中，通过英特网进行传输。

TCP通过端口号来保持连接持续不断的运行。IP地址可以连接到正确的计算机，端口号可以连接到正确的应用程序，TCP连接通过四个值来识别：

<源IP地址、源端口号、目的IP地址、目的端口号>

这四个值唯一的定义了一个连接（两条不同的TCP连接不能拥有4个完全相同的地址组件值，不同连接部分可以拥有同样的值）。

一般来说，相比于建立TCP连接及传输请求和响应报文的时间，事务处理时间可能是很短的（除非客户端或服务端超载或正在处理复杂的动态资源），否则HTTP时延是由TCP网络时延造成的。

http事务时延的原因有以下几点：

①、DNS将服务器域名转换解析为一个IP地址所花费的时间；

②、客户端向服务端发送一个TCP连接请求所造成的时延（一般不会花费很多时间，但如果有很多的HTTP事务的话，时延就会变大）；

③、服务端处理请求报文以及回传给客户端，都需要花费一定的时间；

④、服务器回送HTTP响应，也会花费一定的时间；

 OSI参考模型中的网络层，在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。
第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的syn（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
完成三次握手，客户端与服务器开始传送数据。



## 三次握手

Seq：顺序号码，是`发送方当前报文的顺序号码`。
ack：确定序号，是`发送方期望对方在下次返回报文中给回的Seq`。（小写ack）

ACK：标志位，确认，0x10。当ACK = 1时，代表这是一个确认的TCP包，取值0则不是确认包。（大写ACK）

SYN：标志位，同步，0x02。在建立连接是用来同步序号。SYN=1， ACK=0表示一个`连接请求报文段`。SYN=1，ACK=1表示`同意建立连接`。

第一次握手：`客户端向服务端发送连接请求报文（报文其实是转化为包）`，标志位SYN（同步序号）置为1，顺序号码为X=0。  
【SYN=1,SeqX=0   SeqX表示客户端的顺序号码   SYN报文是用来同步的】

第二次握手：服务端收到客户端`发过来报文`，`由SYN=1知道客户端要求建立联机，则为这次连接分配资源`。并向客户端发送一个SYN和ACK都置为1的TCP报文，设置初始顺序号码Y=0，将确认序号(ack)设置为`上一次客户端发送过来的顺序号`(Seq)加1，即X+1 = 0+1=1。(SYN和ACK都置为1,表示同意建立连接，并发送上一次客户端发送过来的顺序号)   
【SYN=1,ACK=1,SeqY=0,ack=1   SeqY表示服务端的顺序号码   SYN报文是用来同步的】

第三次握手：客户端收到服务端发来的包后检查确认号码(ack)是否正确，即第一次发送的Seq加1（X+1=1）。以及标志位ACK是否为1。若正确，向服务端再次发送确认包，ACK标志位为1，SYN标志位为0。确认号码(ack)=Y+1=0+1=1，发送顺序号码(Seq)为X+1=1。Server收到后确认号码值与ACK=1则连接建立成功，可以传送数据了。
【连接建立成功，可以传输数据】
【检查从服务端发送过来的ACK=1和SeqX=1,如正确,向服务端再发ACK=1、SYN=0、ack=1、seqX=0+1报文，这样进入连接状态】



第一次：首先Client端发送连接请求报文
第二次：Server段接受连接后回复ACK报文，并为这次连接分配资源
第三次：Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了

我的理解分配资源是确定序号、顺序号等




## 四次挥手
 FIN：终止，0x01。当FIN=1时，表明此报文段的发送端的数据已经发送完毕，并要求释放传输连接。

提醒：`中断连接端可以是Client端，也可以是Server端`。只要将下面两角色互换即可。

第一次挥手：客户端给服务端发送FIN报文，用来关闭客户端到服务端的数据传送。将标志位FIN和ACK置为1，顺序号码为X=1，确认号码为Z=1。意思是说”我Client端没有数据要发给你了，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK过来。”
【客户端给服务端发送FIN报文】

第二次挥手：服务端收到FIN后，发回一个ACK(标志位ACK=1),确认号码为收到的顺序号码加1，即X=X+1=2。顺序号码为收到的确认号码=Z。意思是说“你的FIN请求我收到了，但是我还没准备好，请继续你等我的消息" 这个时候客户端就进入FIN_WAIT状态，继续等待服务端的FIN报文。
【服务端收到FIN，向客户端发送ACK】

第三次挥手：当服务端确定数据已发送完成，则向客户端发送FIN报文，关闭与客户端的连接。标志位FIN和ACK置为1，顺序号码为Y=1，确认号码为X=2。意思是告诉Client端“好了，我这边数据发完了，准备好关闭连接了。”
【服务端向客户端发送FIN报文】

第四次挥手：客户端收到服务器发送的FIN之后，发回ACK确认(标志位ACK=1),确认号码为收到的顺序号码加1，即Y+1=2。顺序号码为收到的确认号码X=2。意思是“我Client端知道可以关闭连接了，但是我还是不相信网络，怕 Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。“（在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。）
【客户端收到服务器发送的FIN之后，发回ACK确认】


## 为什么连接的时候是三次握手，关闭的时候却是四次握手？
答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。


## 我的理解
当面试时候，可以简化说三次握手和四次挥手，不需要把ACK和SYN等数据说的很明白


## http
HTTP是一个应用层协议

- 支持客户/服务器模式。

- 简单快速：客户向服务器请求服务时，`只需传送请求方法和路径。`由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

- 灵活：HTTP`允许传输任意类型的数据对象`。正在传输的类型由Content-Type加以标记。

- 无连接：无连接的含义是`限制每次连接只处理一个请求`。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

- 无状态：HTTP协议是无状态协议。`无状态是指协议对于事务处理没有记忆能力`。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。为了解决这个问题， Web程序引入了Cookie机制来维护状态。

另外，HTTP`请求报文和响应报文`都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。将在下面详细讲解。

`报文中的数据都使用ASCII编码`，各个字段的长度是不确定的（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。

## 关于HTTP请求GET和POST的区别

(1).提交形式：
   GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456.  POST方法是把提交的数据放在HTTP包的Body中.

(2).传输数据的大小：
   HTTP协议本身没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有：
   GET:`特定浏览器和服务器对URL长度有限制`，例如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。
   因此对于GET提交时，传输数据就会受到URL长度的限制。
   POST:由于不是通过URL传值，理论上数据不受限。但实际`各个WEB服务器会规定对post提交数据大小进行限制`，Apache、IIS6都有各自的配置。

(3).安全性：
    `POST的安全性要比GET的安全性高`，具有真正的Security的含义。而且通过GET提交数据，用户名和密码将明文出现在URL上，因为登录页面有可能被浏览器缓存，其他用户浏览历史纪录就可以拿到账号和密码了。


响应报文结构与请求报文结构`唯一真正的区别`在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。