可以通过回调函数解决。

setState() 是异步的。

setState()方法`通过一个队列机制实现state更新`，当执行setState()的时候，会将需要更新的state`合并之后放入状态队列`，而`不会立即更新this.state`(可以和浏览器的事件队列类比)。

如果我们`不使用setState而是使用this.state.key来修改，将不会触发组件的re-render`。如果将this.state赋值给一个新的对象引用，那么其他不在对象上的state将不会被放入状态队列中，当下次调用setState()并对状态队列进行合并时，直接造成了state丢失。

事实上，setState 方法与包含在其中的执行是一个很复杂的过程，从 React 最初的版本到现在，也有无数次的修改。它的工作`除了要更动 this.state 之外，还要负责触发重新渲染`，这里面要经过 React 核心 diff 算法，最终才能决定是否要进行重渲染，以及如何渲染。而且为了批次与效能的理由，多个 setState 呼叫有可能在执行过程中还需要被合并，所以它`被设计以延时的来进行执行是相当合理的`。

react会合并state然后一次性处理多个state。

## 为什么需要异步？

1. 保证内部的一致性

首先，我想我们都同意推迟并批量处理重渲染是有益而且对性能优化很重要的，无论 setState() 是同步的还是异步的。
那么就算让 state 同步更新，props 也不行，因为当父组件重渲染（re-render ）了你才知道 props。

保证内部的一致性和状态提升的安全性，而不总是追求代码的简洁性。

2. 性能优化

我们通常认为状态更新会按照既定顺序被应用，无论 state 是同步更新还是异步更新。然而事实并不一定如此。

React 会依据不同的调用源，给不同的 setState() 调用分配不同的优先级。调用源包括事件处理、网络请求、动画等。

