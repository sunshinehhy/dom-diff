## 问题
'X-Frame-Options'
Refused to display 'http://www.ftchinese.com/' in a frame because it set 'X-Frame-Options' to 'deny'.
```
    function postData(){
        var iframe = document.getElementById('proxy');
        var win = iframe.contentWindow;
        win.postMessage(window.gSubscriptionEventLabel);
    }
```
## 跨域知识点

http://blog.csdn.net/joyhen/article/details/21631833
http://www.ruanyifeng.com/blog/2016/04/cors.html

在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。

**允许跨域的几种情况：**
- 修改document.domain的方法只适用于不同子域的框架(父类与子类)间的交互。
- 如果想通过使用ajax的方法去与不同子域间的数据交互或者是js调用，只有两种方法,一种是使用jsonp的方法外，还有一种是使用iframe来做一个代理。

 原理就是让这个iframe载入一个与你想要通过ajax获取数据的目标页面处在相同的域的页面(把frame放在让ajax获取数据的目标页面)，所以这个iframe中的页面是可以正常使用ajax去获取你要的数据的，然后就是通过我们刚刚讲得修改document.domain的方法，让我们能通过js完全控制这个iframe，这样我们就可以让iframe去发送ajax请求，然后收到的数据我们也可以获得了。


不同的框架之间（父子或同辈），是能够获取到彼此的window对象的，但蛋疼的是你却不能使用获取到的window对象的属性和方法，所以需要跨域方式。

https://www.cnblogs.com/roam/p/7520433.html   几种跨域

1. 通过jsonp跨域
- jsonp缺点：只能实现get一种请求。
```
执行回调函数onBack，能获取其它域名中的值
 <script>
    var script = document.createElement('script');
    script.type = 'text/javascript';

    // 传参并指定回调执行函数为onBack
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=onBack';
    document.head.appendChild(script);

    // 回调执行函数
    function onBack(res) {
        alert(JSON.stringify(res));
    }
 </script>
```
2. document.domain + iframe跨域

- 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。
- `此方案仅限主域相同，子域不同的跨域应用场景。`
- `只能把document.domain设置成自身或更高一级的父域，且主域必须相同。`
- 修改document.domain的方法只适用于不同子域的`框架间`的交互，还是不能通过ajax直接请求。比如：http://www.example.com/a.html 页面中不能通过ajax直接请求http://example.com/b.html 页面，尽管设置了相同的document.domain。
- 如果你想通过`ajax的方法去与不同子域的页面交互`，`除了使用jsonp的方法外`，`还可以用一个隐藏的iframe来做一个代理。`
 + 不同子域间通过ajax方法交互的原理：
 1. 让这个iframe载入一个与你`想要通过ajax获取数据的目标页面处在相同的域`的页面，所以这个iframe中的页面是可以正常使用ajax去获取你要的数据的。（iframe是载入与ajax要请求的网址【即get/post后面要写的网址】有相同的域，这样就可以通过ajax去获取数据）
 2. 然后就是通过修改iframe所在页面和要获取数据的页面（触发ajax请求的页面）的document.domain的方法，再通过js完全控制这个iframe，这样我们就可以让iframe去发送ajax请求，然后收到的数据我们也可以获得了。

```
domain.com主域相同
    1.）父窗口：(www.domain.com/a.html)

    <iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
    <script>
        document.domain = 'domain.com';
        var user = 'admin';
    </script>
    2.）子窗口：(child.domain.com/b.html)

    <script>
        document.domain = 'domain.com';
        // 获取父窗口中变量
        alert('get js data from parent ---> ' + window.parent.user);
    </script>
```
3. location.hash + iframe
- 实现原理：` a欲与b跨域相互通信，通过中间页c来实现`。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。

- 具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但`c与a同域，所以c可通过parent.parent访问a页面所有对象`。

```
// c.html和a.html为同源；a.html通过#user=admin向b.html传hash值；b.html 监听a.html传来的hash值，再传给c.html
    1.）a.html：(www.domain1.com/a.html)

    <iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
    <script>
        var iframe = document.getElementById('iframe');

        // 向b.html传hash值
        setTimeout(function() {
            iframe.src = iframe.src + '#user=admin';
        }, 1000);
        
        // 开放给同域c.html的回调方法
        function onCallback(res) {
            alert('data from c.html ---> ' + res);
        }
    </script>
    2.）b.html：(www.domain2.com/b.html)

    <iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"></iframe>
    <script>
        var iframe = document.getElementById('iframe');

        // 监听a.html传来的hash值，再传给c.html
        window.onhashchange = function () {
            iframe.src = iframe.src + location.hash;
        };
    </script>
    3.）c.html：(www.domain1.com/c.html)

    <script>
        // 监听b.html传来的hash值
        window.onhashchange = function () {
            // 再通过操作同域a.html的js回调，将结果传回
            window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));
        };
    </script>
```
4. window.name + iframe跨域
- window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在。
- window对象的name属性有个特征：即在一个窗口(window)的生命周期内,`窗口载入的所有的页面都是共享一个window.name，每个页面对window.name都有读写的权限`，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置(意思是不会因为其他页面载入而改变它的name，除非这个新页面再设置window.name的值)。
- window.name的值只能是字符串的形式，这个字符串的大小`最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器`。

   **比如：a.html需要获取data.html的数据**   `原理是：`

        1）在a.html页面中使用一个隐藏的iframe来充当一个中间人角色；

        2）由iframe去获取data.html的数据；

        3）然后a.html再去得到iframe获取到的数据。

    `注意点：`
    1）把这个iframe的src设为 xxx/data.html（即data.html页面网址） ，iframe可以获取到data.html通过window.name设置的数据
    
    2）在a.html获取iframe对象，然后iframe.contentWindow.name获取到值（此值跟data.html通过window.name设置的数据相同），获取到值之后，再重新设置此iframe的src（此src设成跟a.html页面同一个域，目的是让a.html能访问到此iframe里的数据）。

    `这样做代理的目的`：我当时第一想法是直接用window.name就能获取值，为什么还要用iframe代理。我个人认为是仅仅想获取data.html页面的window.name，假如其它页面也设置了window.name，那只在a.html中直接用window.name获取，就不能获取到data.html中的数据了。

    其实window.name是一种跨域传递数据的思路，它这是仅仅要获取data.html中的数据，所以用iframe代理。

```
//data.html页面
<script>
 window.name="想要被获取的数据。"
</script>

//a.html页面
<script>
    function getData(){
        var iframe = document.getElementId('proxy');
        iframe.onload = function(){
            var data = iframe.contentWindow.name;
            alert(data);
        }
        iframe.src = 'b.html';
        /*
        这里的b.html为与a.html同源的随便一个页面，目的是让a.html能访问到iframe中的东西
        设置为src="about:blank"也行
        about:blank是打开浏览器空白页的命令。
        */
    }
</script>
<body>
    <iframe id="proxy" src="http://www.domain2.com/data.html" style="display:none;" onload="getData()"></iframe>
</body>
```
5. postMessage跨域
- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的iframe消息传递
- 上面三个场景的跨域数据传递
- 论这个window对象是属于同源或不同源都可以使用

用法：postMessage(data,origin)方法接受两个参数

data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。

origin： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。

6. 跨域资源共享（CORS）
7. nginx代理跨域
8. nodejs中间件代理跨域
9. WebSocket协议跨域

## fetch跨域请求相关设置
### Access-Control-Allow-Origin
<https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin>

响应头设置Access-Control-Allow-Origin：https://backyard.ftchinese.com

### fetch的mode字段

设为

```js
mode: 'cors'
```

<https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/fetch>

### 参考博客

https://www.jianshu.com/p/b587dd1b7086

