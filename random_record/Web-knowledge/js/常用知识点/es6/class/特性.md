- ES6 的class可以看作只是一个`语法糖`，它的绝大部分功能，ES5 都可以做到，新的class写法只是`让对象原型的写法更加清晰、更像面向对象编程的语法而已`。
- ES6 的类，完全可以看作构造函数的另一种写法。
- 更接近传统面向对象语言的写法。
- ES5 的构造函数Point，对应 ES6 的Point类的构造方法。
- constructor方法（构造方法），它里面的`this关键字则代表实例对象`。
- 类方法定义前面不需要加function；
- 方法之间不需要加逗号分隔，加了会报错；
```
class Point {
  // ...
}

typeof Point // "function"
Point === Point.prototype.constructor // true
```
- 类的数据类型就是函数，类本身就指向构造函数。
- 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。
- 构造函数的prototype属性，在ES6的类上面继续存在，类的所有方法都定义在prototype属性上面。
```
class Point {
  constructor() {
    // ...
  }

  toString() {
    // ...
  }

  toValue() {
    // ...
  }
}

// 等同于

Point.prototype = {
  constructor() {},
  toString() {},
  toValue() {},
};
```
- 在类的实例上面调用方法，其实就是调用原型上的方法。
```
class B {}
let b = new B();

b.constructor === B.prototype.constructor //true(在类的实例上面调用方法，其实就是调用原型上的方法。)
b.constructor == B  // true（实例的构造函数属性（constructor）指向构造函数）
B === B.prototype.constructor  // true (类本身就指向构造函数。)
typeof B // "function"   (类的数据类型就是函数)
B.prototype.constructor === B // true  (prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的。)
```

由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。
```
class Point {
  constructor(){
    // ...
  }
}

Object.assign(Point.prototype, {
  toString(){},
  toValue(){}
});
```

- 类的`内部所有定义的方法`，`都是不可枚举的（non-enumerable）`。

```
class Point {
  constructor(x, y) {
    // ...
  }

  toString() {
    // ...
  }
}

Object.keys(Point.prototype)
// []
Object.getOwnPropertyNames(Point.prototype)
// ["constructor","toString"]
```
上面代码中，`toString方法是Point类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。`

```
var Point = function (x, y) {
  // ...
};

Point.prototype.toString = function() {
  // ...
};

Object.keys(Point.prototype)
// ["toString"]
Object.getOwnPropertyNames(Point.prototype)
// ["constructor","toString"]
```
上面代码采用` ES5 的写法，toString方法就是可枚举的`。

- 类的属性名，可以采用表达式。
```
let methodName = 'getArea';

class Square {
  constructor(length) {
    // ...
  }

  [methodName]() {
    // ...
  }
}
```

