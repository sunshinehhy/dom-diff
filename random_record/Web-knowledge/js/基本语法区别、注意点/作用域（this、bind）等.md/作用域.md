
## 变量提升和块级作用域
```
if(!a in window){
    var a = 1;
}
console.log(a);  //undefinded
```
因为先提升变量，再提升函数
```
function a(){}
var a ;
console.log(typeof a);  //function
```

var b = (10 == '10')  //true
var b = (10 >= '10')  //true

## 继承子类能找到对应属性就调用子类的，否则往父类找
## 闭包：内部和外部的桥梁
function a(){
    var scope = 'son';
    return function sonScope(){
        var scope = 'son1';
        return scope;
    }
};
a()(); //son1  一般不这样写

var fun = (function a(){
    var scope = 'son';
    return function sonScope(){
        var scope = 'son1';
        return scope;
    }
}());
fun();  //son1

## 闭包引用当前对应的值
```
function setup(x){
    var i=0;
    return function(){
        return x[i++];
    }
}
var next = setup([a,b,c]);
next(); //a
next(); //b
next(); //c

var fun = (function setup(x){
    var i=0;
    return function(){
        return x[i++];
    }
})([a,b,c]);
fun()   //a
fun()   //b
fun()   //c
```

```
<!--先调用函数，再输出-->
function foo() {
    window.bar = "this is an explicit global variable";
    console.log(bar);//this is an explicit global variable
}

foo();
console.log(bar); //this is an explicit global variable

<!--先输出，再调用函数-->
function foo() {
    window.bar = "this is an explicit global variable";
    console.log(bar); //没有输出，因为foo()没有执行
}
console.log(bar); //Uncaught ReferenceError: bar is not defined
foo();
```
以下实例也是创建了全局变量
```
function foo() {
    this.variable = "potential accidental global";
}
// Foo called on its own, this points to the global object (window)
// rather than being undefined.
// 函数自身发生了调用，this 指向全局对象（window），（译者注：这时候会为全局对象 window 添加一个 variable 属性）而不是 undefined。
 
foo();
```

```
var name = 'hhy';
var obj={
    name:'hehuiyun',
    func:function(){
        console.log(this.name);
    }
}
console.log(this.name); //'hhy'
obj.func();  //'hehuiyun'
var c = obj.func;
c(); //'hhy'
```