## Composition
React的关键特征是成分的组成。由不同的人编写的组件应该在一起工作得很好。对我们来说，很重要的一点是，您可以向组件添加功能，而不会在整个代码基中引起波动。

例如，应该可以将一些本地状态引入到组件中，而不需要更改任何使用它的组件。类似地，在需要的时候，应该可以向任何组件添加一些初始化和拆解代码。

在组件中使用状态或生命周期钩子并没有什么“不好”之处。像任何强大的功能一样，它们应该被适度使用，但是我们没有打算删除它们。相反，我们认为它们是使反应有效的组成部分。将来我们可能会启用更多的功能模式，但是本地状态和生命周期挂钩都将是该模型的一部分。

组件通常被描述为“仅仅是函数”，但在我们看来，它们需要更多的功能才能发挥作用。在反应中，组件描述任何可组合的行为，包括呈现、生命周期和状态。一些外部库如Relay使用其他职责(如描述数据依赖关系)来增强组件。很有可能这些想法会让它在react以某种形式做出。

## Common Abstraction
一般来说，我们不愿意添加可以在用户界面中实现的特性。我们不想让你的应用程序充斥着无用的库代码。然而，也有例外。

例如，如果React不支持本地状态或生命周期挂钩，人们就会为它们创建自定义抽象。当多个抽象相互竞争时，React不能强制或利用它们中的任何一个属性。它必须用最小公分母。

这就是为什么有时我们添加特性来进行响应。如果我们注意到许多组件以不兼容或低效的方式实现某个特性，我们可能更喜欢将其转换为React。我们不会轻易做这件事。当我们这样做的时候，是因为我们有信心提高抽象层次会使整个生态系统受益。状态、生命周期挂钩、跨浏览器事件规范化都是很好的例子。

我们经常与社会各界讨论这些改善建议。你可以在React issue tracker上的“大图”标签上找到一些这样的讨论。

## Escape Hatches 逃避的退路
React是务实的。它是由Facebook上的产品需求驱动的。虽然它受到一些尚未完全主流的范例(如函数式编程)的影响，但是对拥有不同技能和经验水平的广泛开发人员保持可访问性是项目的一个明确目标。

如果我们想要弃用我们不喜欢的模式，我们的责任是在弃用它之前考虑它的所有现有用例并教育社区关于替代方案。如果一些用于构建应用程序的模式很难用声明式的方式表示，我们将为它提供必要的API。如果我们不能为我们在许多应用程序中发现的某些东西找到一个完美的API，我们将提供一个临时的subpar工作API，只要它能够在以后处理掉它，它就会为将来的改进留下一扇门。

## Stability
我们重视API的稳定性。在Facebook，我们有超过5万个组件在使用React。许多其他公司，包括Twitter和Airbnb，也是React的主要用户。这就是为什么我们通常不愿意改变公共api或行为。

然而，我们认为“无变化”意义上的稳定性被高估了。它很快就会变成停滞。相反，我们更喜欢稳定性，因为“它在生产中被大量使用，当某些东西发生变化时，有一个清晰(最好是自动)的迁移路径。”

当我们弃用一个模式时，我们会研究它在Facebook中的内部用法，并添加弃用警告。他们让我们评估变化的影响。有时，如果发现还为时过早，我们就会退出，我们需要更有策略地考虑如何使代码库达到它们为这种更改做好准备的程度。

如果我们确信更改不会造成太大的破坏，并且迁移策略对所有用例都是可行的，那么我们就向开源社区发布弃用警告。我们与Facebook之外的许多用户保持密切联系，我们监控流行的开源项目，并指导他们修复这些问题。

考虑到Facebook的庞大规模，成功的内部迁移通常是一个很好的指标，表明其他公司也不会有问题。然而，有时人们指出我们没有想到的其他用例，我们为它们添加了逃生舱口或重新考虑我们的方法。

没有充分的理由，我们不反对任何事情。我们认识到，有时不赞成的警告会引起沮丧，但我们会添加它们，因为我们和社区中许多人认为有价值的改进和新特性会被破坏。

例如，我们在React 15.2.0中添加了关于未知DOM道具的警告。许多项目都受到了影响。但是，修复这个警告非常重要，这样我们就可以引入对自定义属性的支持以进行响应。在我们添加的每一个弃用之后都有这样的原因。

当我们添加一个弃用警告时，我们将它保留到当前主要版本的其余部分，并在下一个主要版本中更改行为。如果涉及大量重复的手工工作，我们将发布codemod脚本，该脚本可以自动完成大部分更改。Codemods使我们能够在一个巨大的代码基中不停滞地前进，我们鼓励您也使用它们。

您可以找到我们在反应堆-codemod存储库中释放的codemod。

## Interoperability 互操作性
我们高度重视与现有系统的互操作性和逐步采用。Facebook有大量的非即时代码库。它的网站使用了一个名为XHP的服务器端组件系统，内部的UI库在作出反应之前出现，并进行自我反应。对我们来说，重要的是任何产品团队都可以开始使用React来开发一个小特性，而不是重写他们的代码来打赌。

这就是为什么React提供了escape hatches来处理可变模型，并试图与其他UI库很好地合作。您可以将现有的命令式UI封装到声明式组件中，反之亦然。这对于逐步采用是至关重要的。

## Scheduling 调度
即使您的组件被描述为函数，当您使用React时也不会直接调用它们。每个组件都返回需要呈现的内容的描述，该描述可能包括用户编写的组件(如<LikeButton>)和特定于平台的组件(如<div>)。在将来的某一时刻，它将对“unroll”<LikeButton> >做出响应，并根据组件的递归结果对UI树进行更改。

这是一个微妙的区别，但却是一个强有力的区别。既然你不调用那个组件函数，而是让它起作用，它的意思是反应有能力在必要时延迟调用它。在其当前实现中，React递归地遍历树，并在一次滴答中调用整个更新树的呈现函数。然而，未来它可能会开始延迟一些更新以避免帧丢失。

这是React设计的一个常见主题。一些流行的库实现了“push”方法，即当新数据可用时执行计算。然而，React坚持“拉”方法，在这种情况下，计算可能会被推迟到必要的时候。

React不是通用数据处理库。它是一个用于构建用户界面的库。我们认为，它在应用程序中是唯一定位的，可以知道哪些计算现在是相关的，哪些不是。

如果有东西不在屏幕上，我们可以延迟与它相关的任何逻辑。如果数据到达的速度比帧速率快，我们可以合并和批处理更新。我们可以将来自用户交互的工作(如按钮点击引起的动画)优先于不太重要的后台工作(如呈现刚刚从网络加载的新内容)，以避免帧丢失。

明确地说，我们现在没有利用这一点。但是，这样做的自由是为什么我们更喜欢控制调度，为什么setState()是异步的。从概念上讲，我们将其视为“调度更新”。

如果我们让用户直接使用函数反应编程中常见的“push”范式组合视图，那么对调度的控制将更难实现。我们想拥有“胶水”代码。

React的一个关键目标是，在返回React之前执行的用户代码数量最少。这确保了React保留了根据它对UI的了解来安排和分割工作的能力。

在团队内部有一个笑话，反应应该被称为“计划”，因为反应不希望完全“反应”。
## Developer Experience
提供良好的开发经验对我们来说很重要。

例如，我们维护了React DevTools，它允许您查看Chrome和Firefox中的React组件树。我们听说它给Facebook的工程师和社区带来了巨大的生产力提升。

我们还尝试做更多的工作来提供有用的开发人员警告。例如，如果您在开发中以浏览器无法理解的方式嵌套标记，或者在API中使用常见的类型错误，则React会警告您。开发人员警告和相关检查是React开发版本比生产版本慢的主要原因。

我们在Facebook内部看到的使用模式帮助我们了解常见的错误是什么，以及如何及早预防它们。当我们添加新特性时，我们试图预测常见的错误并警告它们。

我们一直在寻找改善开发人员体验的方法。我们喜欢听你的建议，接受你的贡献，使它变得更好。

## Debugging
当出现问题时，一定要在代码基中使用面包屑跟踪错误的来源。在《回应》中，道具和国家就是这些面包屑。

如果您在屏幕上看到错误，可以打开React DevTools，找到负责呈现的组件，然后查看道具和状态是否正确。如果它们是，那么问题就出现在组件的render()函数中，或者通过render()调用的某个函数中。问题是孤立的。

如果状态错误，则您知道问题是由该文件中的一个setState()调用引起的。这也是比较容易定位和修复的，因为通常在一个文件中只有几个setState()调用。

如果道具是错误的，您可以在检查器中遍历这棵树，通过向下传递坏的道具寻找第一个“毒害油井”的部件。

将任何UI跟踪到以当前道具和状态形式生成的数据的能力非常重要。一个明确的设计目标是状态不被“困住”在闭包和组合器中，并且可以直接进行响应。

虽然UI是动态的，但是我们认为道具和状态的同步渲染()功能将调试从猜测变成了一个无聊但有限的过程。我们希望在反作用中保留这个约束，即使它使一些用例(如复杂的动画)更加困难。

## Configuration
我们发现全局运行时配置选项有问题。

例如，有时会要求我们实现一个函数，如React.configure(options) or React.register(component)。然而，这带来了许多问题，我们没有意识到这些问题有好的解决方案。

如果有人从第三方组件库调用这样的函数呢?如果一个React应用嵌入另一个React应用，而它们想要的配置又不兼容怎么办?第三方组件如何指定它需要特定的配置?我们认为全局配置与组合不太匹配。由于组合是响应的核心，所以我们在代码中不提供全局配置。

但是，我们在构建级别上提供了一些全局配置。例如，我们提供独立的开发和生产构建。我们还可能在将来添加一个分析构建，并且我们愿意考虑其他构建标志。

## Beyond the DOM
我们看到了React的价值所在，它允许我们编写bug较少的组件，并将它们很好地组合在一起。DOM是产生反应的原始呈现目标，但对于Facebook和社区来说，React Native 同样重要。

与渲染器无关是React的一个重要设计约束。它在内部表示中增加了一些开销。另一方面，对核心的任何改进都可以跨平台进行转换。

拥有一个单一的编程模型可以让我们围绕产品而不是平台组建工程团队。到目前为止，这种权衡对我们来说是值得的。

## Implementation
我们尽量提供优雅的api。我们不太关心实现是否优雅。现实世界远非完美，在某种程度上，我们宁愿将丑陋的代码放入库中，如果这意味着用户不必编写它。当我们评估新代码时，我们正在寻找一个正确的、性能良好并能提供良好开发经验的实现。优雅是次要的。

比起巧妙的代码，我们更喜欢乏味的代码。代码是可丢弃的，并且经常更改。所以重要的是，除非绝对必要，否则不要引入新的内部抽象。Verbose代码很容易移动，更改和删除是首选的优雅代码，它过早地抽象和难以更改。

## Optimized for Tooling
一些常用的api有冗长的名称。例如，我们使用componentDidMount()而不是didMount()或onMount()。这是故意的。目标是使与库的交互点高度可见。

在Facebook这样的大型代码库中，能够搜索特定api的使用非常重要。我们重视不同的详细名称，特别是应该谨慎使用的特性。例如，危险的setinnerhtml在代码检查中很难被忽略。

优化搜索也很重要，因为我们依赖codemods进行突破性的更改。我们希望在代码库中应用大量的自动更改是容易且安全的，并且独特的详细名称可以帮助我们实现这一点。类似地，独特的名称使编写定制的lint规则更容易，而不用担心潜在的误报。

JSX起着类似的作用。虽然这并不是React的必备话题，但我们在Facebook上大量使用它是出于审美和实用两方面的原因。

在我们的代码基中，JSX为处理React元素树的工具提供了明确的提示。这使得可以添加构建时的优化，例如提升常量元素、安全的lint和codemod内部组件的使用，并将JSX源位置包含到警告中。

## Dogfooding
我们尽力解决社区提出的问题。然而，我们可能会优先考虑人们在Facebook内部经历的问题。也许与直觉相反，我们认为这是社区能够做出反应的主要原因。

大量的内部使用给了我们自信，这种自信不会在明天消失。React创立于Facebook，旨在解决问题。它为公司带来了有形的商业价值，并被用于其许多产品中。Dogfooding意思是我们的眼光保持敏锐，我们有一个专注的方向。

这并不意味着我们忽视了社区提出的问题。例如，我们添加了对web组件和SVG的支持以进行响应，即使我们内部不依赖它们中的任何一个。我们正在积极倾听您的痛处，并尽我们最大的努力解决它们。社区是让我们做出特殊反应的地方，我们很荣幸能做出贡献。

在Facebook上发布了许多开源项目之后，我们认识到，试图让每个人同时感到快乐，却产生了焦点不明确的项目，而这些项目并没有得到很好的发展。相反，我们发现，选择一个小的听众并专注于让他们快乐，会带来积极的净效果。这正是我们所做的反应，到目前为止，解决Facebook产品团队遇到的问题已经很好地转化为开源社区。

这种方法的缺点是，有时我们不能对Facebook团队不需要处理的事情给予足够的关注，比如“开始”体验。我们非常清楚这一点，我们正在考虑如何改进，使社区中的每个人都能从中受益，而不会犯我们以前在开源项目中犯过的错误。