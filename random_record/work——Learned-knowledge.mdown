  2017.11.13
    func getPlatformNSString() {
        #if (arch(i386) || arch(x86_64)) && os(iOS)
            let DEVICE_IS_SIMULATOR = true
        #else
            let DEVICE_IS_SIMULATOR = false
        #endif
        
        var machineSwiftString : String = ""
        
        if DEVICE_IS_SIMULATOR == true
        {
            // this neat trick is found at http://kelan.io/2015/easier-getenv-in-swift/
            if let dir = ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"] {
                machineSwiftString = dir
            }
        } else {
            var size : size_t = 0
            sysctlbyname("hw.machine", nil, &size, nil, 0)
            var machine = [CChar](repeating: 0, count: Int(size))
            sysctlbyname("hw.machine", &machine, &size, nil, 0)
            machineSwiftString = String(cString: machine)
            
        }
        print("machineSwiftString\(machineSwiftString)")
    }

    CustomNavigationController 中tabBarView中打开，用present不用pushViewController的原因是：如果用push，会导致tabBarView在audioPlayerController前面。

//        self.navigationItem.leftBarButtonItem = UIBarButtonItem(title: "back", style: .plain, target: self, action: #selector(backNavigation))
//        self.navigationItem.leftBarButtonItem?.title = ""
区分三种颜色：
self.navigationController?.toolbar.barTintColor = UIColor.brown
self.navigationController?.toolbar.backgroundColor = UIColor.black
self.navigationController?.toolbar.layer.backgroundColor = UIColor.black.cgColor
假如到toolbar中的元素自动垂直居中：
let allSelectButton = UIBarButtonItem(customView: allSelect)
let deleteButton = UIBarButtonItem(customView: delete)
let toolArray = [allSelectButton,deleteButton]
self.toolbarItems = toolArray

//        self.navigationController?.toolbarItems?.removeAll()
//        self.navigationController?.toolbar.isHidden = true
  2017.11.14
learn：
1.self.navigationController?.toolbar不能在iphonex中自动布局；
2.toolbar中的内容自动会在中间。
3.用自定义的toolBar碰到的问题：不能在xcode中调整位置，应该用代码实现可以？
4.view加在tableview上，但不会显示，必须在代码中设置zPosition的大小，尽管这样还不能操作view，要能操作就不能让view在其上面。
5.innerView2.preservesSuperviewLayoutMargins = true设置为true，会考虑父类页面的margin。
2017.11.16
string(withContentsOfFile:)
2017.11.20


2017.11.22
learn：
   var dataArray:NSMutableArray = []     
   dataArray = allCellContent.mutableCopy() as! NSMutableArray
  let aa = dataArray[1] as! NSDictionary
   print("dataArray1--\(aa["headline"])")
toolBar.leadingAnchor.constraint(equalTo: view.layoutMarginsGuide.leadingAnchor).isActive = true
NSMutableArray和NSArray都可以使用，NSArray是不可变的数组，一旦初始化了就不能再改变。
此方法反应有些慢
        let url = URL(string:"http://www.apple.com/euro/ios/ios8/a/generic/images/og.png")
        let data = try? Data(contentsOf: url!)
        let image: UIImage = UIImage(data: data!)!
        cell.selectedImageView.image = image
此方法反应不慢
        let url = URL(string: aa!)
        let sessionTask = URLSession.shared
        let request = URLRequest(url: url!)
        let task = sessionTask.dataTask(with: request, completionHandler: {(data: Data?, response: URLResponse?, error: Error?) -> Void in
            if (error == nil) {
                let image: UIImage = UIImage(data: data!)!
                OperationQueue.main.addOperation({
                    cell.selectedImageView.image = image
                })
            }
        })
        task.resume()

2017.11.23
        Data?  是可选型才能返回nil

        try JSONSerialization.jsonObject(with: downloadRealData, options: .mutableContainers) as! NSMutableArray
        这种方法是错误的，会弹出错误：Could not cast value of type '__NSDictionaryM' (0x111637218) to 'NSMutableArray' (0x111636598).



2017.11.27
OperationQueue：
对于当前执行操作，这意味着操作对象的工作代码必须检查取消状态，停止它正在做的事情，并标记自己完成。对于排队但尚未执行的操作，队列仍然必须调用操作对象的start方法，以便它能够处理取消事件并标记自己完成。
abstract class：好像是不能直接使用，需要使用子类？

使用API时：尽可能的使用上层API去实现，除非上层API没办法实现再考虑底层API
detachNewThreadSelector
cell 上做了自定义绘制的话，最好将它们放入 operation 的子类中去。
你的所有网络请求都应该采取异步的方式完成。
在主队列中接收事件或者数据，然后用后台操作队列来执行实际操作，然后回到主队列去传递结果，遵循这样的原则来编写尽量简单的并行代码，将是保证高效正确的不二法则。

2017.11.28
 let downloadedJsonData = String(data: downloadedData,encoding: String.Encoding(rawValue: String.Encoding.utf8.rawValue))
 let aa = UIImage(data: downloadedData)
downloadedData需要根据数据来源格式来确定显示数据方式
此种方法获得为空
let data = NSData(bytes: &playingIndex, length: MemoryLayout<Int>.size)
此方法可以存为数值
 let playingIndexStr = String(playingIndex)
let playingIndexData = playingIndexStr.data(using: String.Encoding.utf8)
2017.11.29
input需要清空内容才会显示placeholder
2017.12.02
        //        switchChAndEnAudio.layer.borderWidth = 0.5
        //        switchChAndEnAudio.layer.cornerRadius = 5
        //        switchChAndEnAudio.layer.masksToBounds = true
2017.12.03
正确修改按钮图片内容和文本内容的位置的两种方法：
1.自定义类继承UIButton，重写titleRect(forContentRect:)和imageRect(forContentRect:)函数
2.重写layoutSubviews()
2017.12.04
获取项目名称：
let aa = Bundle.main.object(forInfoDictionaryKey: kCFBundleExecutableKey as String)
移除所有子对象：
subviews.map {
    $0.removeFromSuperview()
}
过滤处某一子view：
    func filerSmallPlayView(){
        let controller = UIApplication.shared.keyWindow?.rootViewController
        let views = controller?.view.subviews
        for view in views! {
            if view.tag == 1001{  方法一
//            if view.isKind(of: CustomSmallPlayView.self){  方法二
              print("views include--\(String(describing:views))--\(view)")
            }
        }
    }
为什么UIApplication.shared.keyWindow?.rootViewController不行呢，一定得放到CustomNavigationController中
    UIApplication.shared.keyWindow?.rootViewController?.navigationController?.navigationBar.barStyle = .black
//        self.navigationBar.barStyle = .black

    <key>NSPhotoLibraryAddUsageDescription</key>
    <string>Save FTChinese Image to Your Own Photo Library</string>

    <key>NSPhotoLibraryUsageDescription</key>
    <string>photo description</string>
    


## 文件上传：
var formData = new FormData();
formData.append(name, value);
formData.append(name, value, filename);
    ### 两种方式：
formData.append(name, value);
formData.append(name, value, filename);

**2017.12.07**
对于一个应用程序，主bundle对象会让你访问与你的应用程序一起发布的资源。
 let downloaded = { () -> Bool in
        if Download.checkFilePath(fileUrl: productIdentifier, for: .documentDirectory) == nil {
            return false
        } else {
            return true
        }
}()

异步注意使用self weak
keychains文件夹是系统文件夹。存密码的
plist文件的使用：支持的数据类型有：NSDictionary、NSArray、Boolean、NSData、NSNumber、NSString。Swift3.0暂时不支持Array、Dictionary等类型，但支持String。建议都使用带NS的类型。
NSUserDefaults可以存储的数据类型：NSData、NSString、NSNumber、NSDate、NSArray、NSDictionary。
 对于不是基础数据类型，可以转换为NSData进行存储：使用NSKeyedArchiver   







**2017.12.11**
invalidate()
此方法是从RunLoop对象中删除计时器的惟一方法。RunLoop对象在invalidate()方法返回或稍后的某个点之前，删除它对计时器的强引用。
如果它配置了目标和用户信息对象，则接收方也会移除对这些对象的强引用。

OutputStream
NSOutputStream是一个具体的NSStream子类，它允许您将数据写入流。尽管在大多数情况下，NSOutputStream可能足够满足需要此功能的大多数情况，但如果您需要更专门化的行为(例如，您希望记录流中数据的统计数据)，您可以创建一个NSOutputStream的子类。

php全部是同步，没有异步，跟html没有关系，除非用ajax

 UIScrollView 滚动过快，需要代码去修复异常
 UIPageControl代表水平点
UICollectionView继承UUIScrollView
启动到哪个页面设置，这个页面为rootViewController

makeKey()使接收者成为关键窗口。该方法导致前一个关键窗口退出关键状态。

####UNUserNotificationCenter
你直接从应用程序中安排的通知被称为本地通知，因为你的应用程序在用户的设备上本地创建它们。相比之下，远程通知是由您自己的服务器创建的，并通过Apple推送通知服务(APNS)交付给用户的设备。
**2017.12.12**
UserDefaults.standard.synchronize()将对持久域的任何修改写入磁盘，并将所有未修改的持久域更新到磁盘上。
因为定期自动调用此方法,使用这种方法只有如果你不能等待自动同步(例如,如果您的应用程序即将退出)或即使你没有做任何变化,如果您想要更新用户默认的磁盘上的内容。

在开发过程中，请注意，在用户修改微信头像后，旧的微信头像URL将会失效，因此开发者应该自己在获取用户信息后，将头像图片保存下来，避免微信头像URL失效后的异常情况。

pagespeed insights

UIGraphicsBeginImageContextWithOptions需要放在主线程中使用
// 显示UI需要回到主线程
    dispatch_async(dispatch_get_main_queue(), ^{
        //code
    });
从形式来说：UIView 的绘制是建立在 CoreGraphic 上的，使用的是 CPU。CALayer 使用的是 Core Animation，CPU，GPU 通吃，由系统决定使用哪个。View的绘制使用的是自下向上的一层一层的绘制，然后渲染。Layer处理的是 Texure，利用 GPU 的 Texture Cache 和独立的浮点数计算单元加速 纹理 的处理。
https://robots.thoughtbot.com/designing-for-ios-graphics-performance  
大部分阻碍主进程的情形是你的app在做一些牵涉到读写外部资源的I/O操作，比如存储或者网络。一般存储或者网络需要另开线程。
http://blog.jobbole.com/37984/   （性能优化）
http://www.2bjs.com/
http://www.code4app.com/thread-22933-1-1.html
https://zhuanlan.zhihu.com/p/28514566
https://www.zhihu.com/question/20016551 (如何才能系统的学习 iOS 开发，理解一些规则和深层次的机制原理？)
https://github.com/RolandasRazma/RRFPSBar (RRFPSBar)



