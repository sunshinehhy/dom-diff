https://reactjs.org/docs/codebase-overview.html

https://github.com/reactjs/reactjs.org

https://github.com/facebook/react/tree/master/packages/

## Warnings and Invariants
The warning is shown when the warning condition is false.
一种思考方式是，这种情况应该反映正常情况，而不是异常情况。

避免在控制台中出现重复警告，这是一个好主意:
```
var warning = require('warning');

var didWarnAboutMath = false;
if (!didWarnAboutMath) {
  warning(
    2 + 2 === 4,
    'Math is not working today.'
  );
  didWarnAboutMath = true;
}
```

警告只在开发中启用。在生产中，它们被完全剥离。如果您需要禁止某些代码路径执行，请使用invariant模块代替:
```
var invariant = require('invariant');

invariant(
  2 + 2 === 4,
  'You shall not pass!'
);
```

当invariant条件为假时抛出invariant。

“Invariant”只是说“这个条件总是成立”的一种说法。你可以把它想象成一个断言。

保持开发和生产行为相似是很重要的，因此invariant在开发和生产中都存在。在生产环境中，错误消息将被自动替换为错误代码，以避免对字节大小产生负面影响。

## Development and Production
您可以在代码库中使用__DEV__ pseudo-global变量来保护只开发的代码块。

在编译步骤中，它是内联的， in the CommonJS builds，转换为process.env.NODE_ENV !== 'production'检查。

对于独立的构建，它在非压缩的编译中是true，并在压缩的编译中使用if块完全剥离出来。
```
if (__DEV__) {
  // This code will only run in development.
}
```

## Flow
我们最近开始在代码基中引入Flow 检查。用许可头注释中的@flow注释标记的文件正在进行类型检查。

我们接受向 现有代码添加Flow annotations 的pull requests。流注释看起来是这样的:
```
ReactRef.detachRefs = function(
  instance: ReactInstance,
  element: ReactElement | string | number | null | false,
): void {
  // ...
}
```
如果可能，新代码应该使用Flow annotations。You can run yarn flow locally to check your code with Flow.

## Dynamic Injection
在一些模块中React使用dynamic injection。虽然它总是显式的，但仍然很不幸，因为它阻碍了对代码的理解。它存在的主要原因是因为React最初只支持DOM作为目标。React Native以一个React fork开头。我们必须添加dynamic injection，让React Native重写一些行为。

您可能会看到模块声明它们的动态依赖关系像这样:
```
// Dynamically injected
var textComponentClass = null;

// Relies on dynamically injected value
function createInstanceForText(text) {
  return new textComponentClass(text);
}

var ReactHostComponent = {
  createInstanceForText,

  // Provides an opportunity for dynamic injection
  injection: {
    injectTextComponentClass: function(componentClass) {
      textComponentClass = componentClass;
    },
  },
};

module.exports = ReactHostComponent;
```
注入字段不会以任何方式进行特殊处理。但是按照惯例，这意味着这个模块希望在运行时向它注入一些(可能是特定于平台的)依赖关系。

代码基中有多个注入点。在未来，我们打算摆脱动态注入机制，并在构建过程中静态地连接所有部件。

## Multiple Packages
React 是一个monorepo。它的存储库包含多个独立的包，以便它们的更改可以协调在一起，并且问题存在于一个地方。

## React Core
React的“核心”包括所有顶级的React api，例如:
React.createElement()
React.Component
React.Children

React core只包含定义组件所需的api。它不包含和解算法或任何特定于平台的代码。它被React DOM和React Native 组件都使用。

React core的代码位于源代码树中的 packages/react 中。它在npm作为react包时可用。相应的独立浏览器构建称为react.js。它导出一个名为React的全局变量。

## Renderers
React最初是为DOM创建的，但后来又进行了调整，以支持使用React native平台。这就引入了“renderers”的概念来给React internals。

渲染器管理如何将响应树转换为底层平台调用。

渲染器也位于packages/:

React DOM Renderer 呈现对DOM的React components。它实现了顶级的ReactDOM api，并且可以作为react-dom npm包使用。它也可以作为独立的浏览器包使用，称为react-dom.js。输出一个全局的ReactDOM 。
React Native Renderer 渲染React components组件到原生视图。它由React Native在内部使用。
React Test Renderer将响应组件呈现为JSON树。它被Jest的快照测试特性所使用，并且可以作为react-test-renderer npm包使用。
唯一得到官方支持的渲染器是react-art。它曾经是在一个单独的GitHub存储库中，但是现在我们将它移动到主源树中。

注意:从技术上讲，react-native-renderer 是一个非常薄的层，它教导React如何与React Native进行交互。管理本机视图的真正特定于平台的代码与它的组件一起驻留在React Native存储库中。

## Reconcilers
即使是非常不同的渲染器，比如React DOM和React Native也需要共享很多逻辑。特别是，和解算法应该尽可能地相似，以便声明性呈现、自定义组件、状态、生命周期方法和refs能够在不同的平台上一致地工作。

为了解决这个问题，不同的渲染器在它们之间共享一些代码。我们称这部分反应为“和解者”。当计划了更新(如setState()))时，协调器调用render()树中的组件并挂载、更新或卸载它们。

和解程序不是单独打包的，因为它们目前没有公共API。相反，它们只被诸如React DOM和React Native这样的渲染器使用。

## Stack Reconciler
The “stack” reconciler 是支持React  15和更早的实现。我们已经停止使用它了，但是在下一节将详细记录它。

## Fiber Reconciler
The “fiber” reconciler 是一种新的努力，旨在解决在stack reconciler中固有的问题并修复一些长期存在的问题。自React16以来，它一直是默认的reconciler 。

它的主要目标是:

能够将可中断的工作分割成块。
能够对正在进行的工作进行优先级、重设基础和重用。
有能力在父母和孩子之间来回让步，在React中以支持布局。
能够从render()返回多个元素。
更好地支持错误边界。

您可以在React Fiber Architecture中阅读更多相关内容。虽然与React 16一起发布了，但默认情况下异步特性还没有启用。

它的源代码位于packages/react-reconciler中。

## Event System
React实现了一个与呈现程序无关的合成事件系统，它与React DOM和React Native都起作用。它的源代码位于packages/events中。

有一个视频有一个深入的代码(66分钟)。  https://www.youtube.com/watch?reload=9&v=dRo_egw7tBc

## 下一节是什么呢?
请阅读下一节以了解更多关于reconciler的pre-React 16实现的细节。我们还没有记录新的reconciler的内部情况。