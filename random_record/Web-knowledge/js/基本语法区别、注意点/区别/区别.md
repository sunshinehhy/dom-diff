## null 和 undefined 的区别

http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html

```
Boolean(undefined):false
Boolean('undefinded'):true
Boolean(null):false
console.log(!'undefinded'):false
console.log(!undefined):true
console.log(!null):true
!'':true
!'1':false
Boolean(''):false
```

`使用var声明变量但未对其加以初始化，为undefined。`

`对于未声明过的变量，只能使用typeof操作符检测其数据类型，会返回undefined，未初始化的变量使用typeof操作符检测其数据类型，也会返回undefined。`

`如果意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。`

## slice,substr 和 substring 的区别

https://www.cnblogs.com/littledu/archive/2011/04/18/2019475.html

1. slice(start,end)

- slice 接收的是起始位置和结束位置(不包括结束位置)
- start 要抽取的片断的起始下标。`如果是负数`，则该参数规定的是从字符串的`尾部开始算起的位置`。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。
- end 紧接着要抽取的片段的结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是`负数`，那么它规定的是从`字符串的尾部开始算起的位置`。

```
var a = "123456";
a.slice(-1,-3)  //""
a.slice(-3,-1)  //"45"
a.slice(3,1)   //""
```

2. substr

- 接收的则是起始位置和所要返回的字符串长度。
- start 必需。要抽取的子串的起始下标。必须是数值。如果是`负数`，那么该参数声明`从字符串的尾部开始算起的位置`。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。
- length 可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的`开始位置到结尾的字串`。

```
var a = "123456";
a.substr(1,3)
//"234"
a.substr(-1,3)
//"6"
a.substr(-3,3)
//"456"
```

3. substring

- 以两个参数中`较小一个作为起始位置，较大的参数作为结束位置`。
- 从 start 处到 stop-1 处的所有字符，其长度为 stop 减 start。
- 如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。如果 start 比 stop 大，那么该方法在提取子串之前会`先交换这两个参数`。
- 不接受负的参数

```
var a = "123456";
a.substring(-4,-2);
//""
a.substring(-4);
//"123456"
```

## indexOf 和 includes 的区别

- indexOf 方法`无法识别数组的NaN成员`，但是 findIndex 方法可以借助 Object.is 方法做到。ie8 不支持 Array.proptype.indexOf()

- Object.is()方法判断两个值是否是相同的值。

- array.findIndex(function(currentValue, index, arr), thisValue)
  findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。

findIndex() 方法为数组中的每个元素都调用一次函数执行：
当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的·索引位置·，之后的值不会再调用执行函数。如果没有符合条件的元素返回 -1。

注意: findIndex() 对于空数组，函数是不会执行的。 findIndex() 并`没有改变数组的原始值`。

```
Object.is('foo', 'foo');     // true
Object.is(window, window);   // true

Object.is('foo', 'bar');     // false
Object.is([], []);           // false

var test = { a: 1 };
Object.is(test, test);       // true

Object.is(null, null);       // true

// 特例
Object.is(0, -0);            // false
Object.is(-0, -0);           // true
Object.is(NaN, 0/0);         // true

```

```
[NaN].indexOf(NaN)
// -1
[NaN].findIndex(y => Object.is(NaN, y))
// 0
[NaN].findIndex(NaN => Object.is(NaN, NaN))
//0
[NaN].includes(NaN)
// true


const contains = (() =>
  Array.prototype.includes
    ? (arr, value) => arr.includes(value)
    : (arr, value) => arr.some(el => el === value)
)();
contains(['foo', 'bar'], 'baz'); // => false
```

Map 和 Set 数据结构有一个 has 方法，需要注意与 includes 区分。

Map 结构的 has 方法，是`用来查找键名的`，比如 Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。
Set 结构的 has 方法，是`用来查找值的`，比如 Set.prototype.has(value)、WeakSet.prototype.has(value)。

**`如果指定的属性在指定的对象或其原型链中，则in 运算符返回true.`**

参考博客：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in

```
0 in [undefined, undefined, undefined] // true
0 in [, , ,] // false
```

`空位不是undefined，一个位置的值等于undefined，依然是有值的`。空位是没有任何值，in 运算符可以说明这一点
ES6 则是明确将空位转为 undefined。

!{} //false

## 数组无法直接进行相等比较

```
[1,2,3] === [1,2,3];//false
[1,2,3] == [1,2,3];//false
```

## Number、parseInt、parseFloat 区别

- Number：将**任意一种数据类型**转换为 number
- parseInt、parseFloat:将**字符串转**换为 number

即针对的对象一个为**任意数据类型**,一个为**字符串**

可参考<http://www.jb51.net/article/100606.htm>

实例：

```
parseInt('') ;//NaN
Number("");　//0
parseInt('10px');//10
Number('10px');//NaN
Number({});//NaN
parseInt("11",2);　//3　　(按照二进制解析)
parseInt("30",2);　//NaN　　(按照二进制解析)
parseInt("17",16);　//3　　(按照十六进制解析)
parseInt("30",16); //48  (按照十六进制解析)
```

## NaN

typeof NaN //"number"

## js 中 script 的 onreadystatechange 和 onload 事件

IE 的 script 元素只支持 onreadystatechange 事件，不支持 onload 事件。

FF 的 script 元素不支持 onreadystatechange 事件，只支持 onload 事件。

如果要在一个<\script src="xx.js"> 加载完成执行一个操作，FF 使用 onload 事件就行了，IE 下则要结合 onreadystatechange 事件和 this.readyState，

当 document 文档正在加载时,返回"loading"。当文档结束渲染但在加载内嵌资源时，返回"interactive"，并引发 DOMContentLoaded 事件。当文档加载完成时,返回"complete"，并引发 load 事件。

readystatechange 事件会在 document 对象上的 readyState 属性的属性值发生变化时触发.

### <font color="#AA7A53">window.location 与 window.open()的区别</font>

    http://blog.csdn.net/sdfdyubo/article/details/59482655

- "top.location.href"是最外层的页面跳转
- "window.location.href"、"location.href"是本页面跳转
- "parent.location.href"是上一层页面跳转.

- location 是 window 对象的属性，而所有的网页下的对象都是属于 window 作用域链中（这是顶级作用域），所以使用时是可以省略 window。而 top 是指向顶级窗口对象，parent 是指向父级窗口对象。

- window.location 是 window 对象的`属性`，而 window.open 是 window 对象的`方法`
- window.location 是你对`当前浏览器窗口的URL地址对象的参考`！
- window.open 是用来`打开一个新窗口的函数`！

- window.open()是可以`在一个网站上打开另外的一个网站的地址`
- 而 window.location()是`只能在一个网站中打开本网站的网页`

- window.location 或 window.open 如何指定 target?

  这是一个经常遇到的问题，特别是在用 frame 框架的时候 。解决办法:

```
window.location 改为 top.location　即可在顶部链接到指定页
或 window.open("你的网址","_top");

<input type="button" value="新窗口打开" onclick="window.open('http://www.baidu.com')">
<input type="button" value="当前页打开" onclick="top.location='http://www.baidu.com','_top'">

```

## 开发环境、生产环境、测试环境的基本理解与区别

开发环境：开发环境是程序猿们专门用于开发的服务器，配置可以比较随意， 为了开发调试方便，一般打开全部错误报告。
测试环境：一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产机上。
生产环境：是值正式提供对外服务的，一般会关掉错误报告，打开错误日志。
三个环境也可以说是系统开发的三个阶段：开发->测试->上线，其中生产环境也就是通常说的真实环境。

## 函数.length 和 arguments.length 的区别

每个函数都有一个 length 属性 （函数名.length）， 表示期望接收的函数的个数（而不是实际接收的参数个数）

它与 arguments 不同。 arguments.length 是表示函数实际接收的参数个数。
