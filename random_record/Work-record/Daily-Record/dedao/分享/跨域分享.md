## 跨域分享
https://www.cnblogs.com/liang-wei/p/5849771.html（nginx配置文件nginx.conf超详细讲解）

分享跨域知识
https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS  (cors)
https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#Preflighted_requests （Preflighted_requests）
https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Server-Side_Access_Control （server cors）
http://arunranga.com/examples/access-control/ （实例）

https://www.cnblogs.com/chenshishuo/p/4919224.html
https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy (里面链接都得看，尤其是window和location)
https://segmentfault.com/a/1190000015597029?utm_source=tag-newest
https://www.zhangxinxu.com/wordpress/2018/02/crossorigin-canvas-getimagedata-cors/  (解决canvas图片getImageData,toDataURL跨域问题)
https://segmentfault.com/a/1190000015597029?utm_source=tag-newest (
不要再问我跨域的问题了)

https://developer.mozilla.org/zh-CN/docs/Web/API/Document/domain  (document.domain)
https://html.spec.whatwg.org/multipage/origin.html#relaxing-the-same-origin-restriction (same-origin-restriction)
https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options  (X-Frame-Options)
https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29
https://developer.mozilla.org/zh-CN/docs/Archive/Misc_top_level/Same-origin_policy_for_file:_URIs  (档案同源策略
)

https://www.jianshu.com/p/9a17768b4ad4 （实例，包含用node写的反向代理方法）

https://html.spec.whatwg.org/multipage/images.html#img-req-data (img)

https://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html  （Web安全测试之XSS）
http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html （浅谈CSRF攻击方式）

https://www.cnblogs.com/unclekeith/p/7750681.html (xss)
https://zhuanlan.zhihu.com/p/24249045 (xss)
https://baike.baidu.com/item/XSS%E6%94%BB%E5%87%BB/954065?fr=aladdin (xss)
https://www.freebuf.com/column/155799.html （XSS实例）
https://zhuanlan.zhihu.com/p/26177815
https://zhuanlan.zhihu.com/p/24249045

https://www.cnblogs.com/shytong/p/5308667.html （CSRF）
https://www.cnblogs.com/wangyuyu/p/3388169.html (CSRF实例，需要看参考文献)

https://blog.csdn.net/zhongshanxian/article/details/81294829（HTTP认证（基于HTTP/1.1）） https://www.jianshu.com/p/87a1322d325e


https://blog.csdn.net/alps1992/article/details/51201657 （TCP长连接和短连接 - http长轮询和短轮询）
https://blog.csdn.net/LEE1996JUN/article/details/79702848 （长轮询和短轮询的区别）

https://www.cnblogs.com/hoojo/p/longPolling_comet_jquery_iframe_ajax.html (Web 通信 之 长连接、长轮询（long polling）)
(http中长连接和websocket的长连接的区别)

https://blog.csdn.net/lldouble/article/details/80742082 （websocket应用场景）

https://www.cnblogs.com/gabrielchen/p/5066120.html  (用nginx的反向代理机制解决前端跨域问题)
1. 跨域的定义
同源策略限制了`从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互`。这是一个`用于隔离潜在恶意文件的重要安全机制`。
2. 跨域解决方式
- jsonp （举我写的2个例子）
jsonp 全称是JSON with Padding,是`为了解决跨域请求资源而产生`的解决方案,是一种依靠开发人员创造出的一种`非官方跨域数据交互协议`。一个是描述信息的格式，一个是信息传递双方约定的方法。
jsonp的产生:
1.AJAX直接请求普通文件`存在跨域无权限访问的问题,不管是静态页面也好`.

2.不过我们在调用js文件的时候又不受跨域影响,比如引入jquery框架的,或者是调用相片的时候

3.凡是拥有scr这个属性的标签都可以跨域例如<script><img><iframe>

4.如果想通过纯web端跨域访问数据只有一种可能,那就是`把远程服务器上的数据装进js格式的文件里`.

5.而json又是一个轻量级的数据格式,还被js原生支持

6.为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是`允许用户传递一个callback 参数给服务端`，

jsonp形式的ajax请求:并且通过get请求的方式传入参数,注意:跨域请求是只能是get请求不能使用post请求。

- script
- 基于jquery
- 通过iframe来跨子域
基于iframe实现的跨域要求两个域具有aa.xx.com,bb.xx.com 这种特点，

父页面调用子页面的函数。

也就是`两个页面必须属于一个基础域（例如都是xxx.com)`，`使用同一协议和同一端口`，这样在`两个页面中同时添加document.domain`，就可以实现父页面调用子页面的函数

修改document.domain的方法`只适用于不同子域的框架(父类与子类)间的交互`。

3. 跨域实例
4. 源码分析（jquery跨域源码分析，这个需要深究）
5. 小程序跨域情况？
同一域名,不同文件夹
同一域名,同一文件夹
不同域名,文件路径相同
同一域名,不同端口
同一域名,不同协议　


HTTP1.1通过使用Connection:keep-alive进行长连接，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。这种长连接是一种“伪链接”
websocket的长连接，是一个真的全双工。长连接第一次tcp链路建立之后，后续数据可以双方都进行发送，不需要发送请求头。
 
keep-alive双方并没有建立正真的连接会话，服务端可以在任何一次请求完成后关闭。WebSocket 它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。

基于HTTP的`长连接,是一种通过长轮询方式实现"服务器推"的技术`,它弥补了HTTP简单的请求应答模式的不足,极大地增强了程序的实时性和交互性。（我的理解：长轮询必须要依赖于长连接）

三、什么是长连接、短连接
 
短连接：
连接->传输数据->关闭连接
HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。
也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。
 
长连接、
连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。
长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。


长连接：能够保持一段时间持久连接。
短连接：流程就是：建立连接->发送数据->断开连接。一次发送之后立即断开连接。短连接不用一直占用服务器资源，可以让服务器空出资源来解决其他的连接。


**长连接**

客户端不停的向服务器发送请求以获取最新的数据信息。减少了每次建立连接和断开连接的开销。所以现在大部分都是长连接，例如一个页面有很多文件，JS文件，CSS文件等等，不能每次都要建立一次连接，所以长连接是比较好的解决办法。

长连接不会长时间保持的，如果长时间没有响应，超时会自动断开的。但是如果都保持连接，那么服务器会爆掉，所以TCP连接数量是有限制的。HTTP1.1默认是长连接，也就是默认Connection的值就是keep-alive

**短连接**

`数据传送过程中，只在需要发送数据时，才去建立一个连接，数据发送完成后，则断开此连接，即每次连接只完成一项业务的发送`。


`轮询：向服务器发送请求，服务器返回请求结果。不断的操作，就叫轮询`

http 长轮询：
http `长轮询是服务器收到请求后如果有数据, 立刻响应请求; 如果没有数据就会 hold 一段时间,这段时间内如果有数据立刻响应请求; 如果时间到了还没有数据, 则响应 http 请求;浏览器受到 http 响应后立在发送一个同样http 请求查询是否有数据;`
前端发送请求给后端，后台接收到请求来返回，但是中间有一点不一样不是瞬间返回。也就是看是否后台的数据有更新，假如后台数据还没有更新，可以把请求暂时挂起来，这样就不会造成频繁请求堵塞服务器了。

http 长轮询的局限:

浏览器端对统一服务器同时 http 连接有最大限制, 最好同一用户只存在一个长轮询;
服务器端没有数据 hold 住连接时会造成浪费, 容易产生服务器瓶颈;

短轮询：
http端轮询是服务器收到请求`不管是否有数据都直接响应 http 请求`; `浏览器受到 http 响应隔一段时间再发送同样的http 请求查询是否有数据`;
向服务器发送请求，服务器返回请求结果。`不断的操作`，就叫轮询。

注意事项
TCP的keep alive是检查当前的tcp连接是否还是活着的，而HTTP的keep-alive是设置让当前的tcp连接可以保持活着的状态。

当TCP连接一段时间没有进行数据通信的时候，一方会发出一个心跳包keep alive包来检测当前连接是否有效，继续监控。这个间隔时间是可以设置的。

长连接看网上的说法是在页面里嵌入一个隐蔵iframe，将这个隐蔵iframe的src属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。其实我也没看懂，毕竟没有真的实现过。

长短轮询的理想实现都应当基于长连接。偶然在一篇文章中发现了字眼“HTTP是一种应用层的网络协议”，突然想起，`长连接是存在于网络层`的一种连接状态。

短连接

所谓短连接,及连接`只保持在数据传输过程，请求发起，连接建立，数据返回，连接关闭`。它适用于一些实时数据请求，配合轮询来进行新旧数据的更替。

长连接
长连接便是在连接发起后，在请求关闭连接前客户端与服务端都保持连接，实质是保持这个通信管道，之后便可以对其进行复用。
它适用于涉及消息推送，请求频繁的场景（直播，流媒体）。连接建立后，在该连接下的所有请求都可以重用这个长连接管道，避免了频繁了连接请求，提升了效率。

`轮询，即是在一个循环周期内不断发起请求来得到数据的机制。`
`所谓的支持长连接，其实是基于'Keep-Alive'请求头所约定，从而向下进行长连接发起的一种机制。该长连接依然是基于TCP的。`

## 适用场景
短轮询：比如电商网站，每个物品的库存，是要不断更新的，就会在前段不断的发起请求，保证数据同步。
    缺点：请求中有大半是无用，浪费带宽和服务器资源。
    实例：适于小型应用。

长轮询：
服务器收到请求后如果有数据，立刻响应请求；如果没有数据 就会 停留 一段时间，这段时间内，如果服务器请求的数据到达（如查询数据库或数据的逻辑处理完成），就会立刻响应；如果这段时间过后，还没有数据到达，则以空数据的形式响应http请求；若浏览器收到的数据为空，会再次发送同样的http请求到server；客户端处理完响应信息后再向服务器发送新的请求。

优点：在无消息的情况下不会频繁的请求。
缺点：服务器hold连接会消耗资源。

实例：WebQQ、Hi网页版、Facebook IM。

## 自己的疑问：
ajax请求是长轮询吗？


## 分享获益
1. 可以当成常识来了解，技不压身
2. 通过分享有个初级认识，说不定跨岗位工作，以后看代码很容易
3. 抓包可以看下面的请求头和响应头
4. 有些单位有XSS测试

大家好，首先在正式分享之前，感谢大家抽出宝贵的时间来听我的分享，我大概花半个小时讲完，不占用大家太多时间，我把自己有限的关于跨域的知识整理出来在此抛砖引玉，我会尽量给大家讲清楚，如果遇到我讲错或者没讲明白的地方，希望大家多多指正。
好，我今天主要分享的是跨域知识，我命名为跨域述，本打算叫算术的术，但显得范围太大不是大牛还是此述吧，虽然此述非彼术，那也算个小术吧。嘿嘿（笑一个）
我主要从这下面4个方面来讲解

### CSRF
https://www.jianshu.com/p/94fd1a5d5413 （实例）

https://blog.csdn.net/stpeace/article/details/53512283 （实例）

1. CSRF攻击是`源于WEB的隐式身份验证机制`！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！XSS容易盗取cookie。

增加伪随机数，XSS 是实现 CSRF 的途径之一。伪造某一个用户的身份给其好友发送垃圾信息，这些垃圾信息的超链接可能带有木马程序或者一些欺骗信息（比如借钱之类的）
referer是请求来源。用户操作限制，比如验证码、再次输入密码。（在举例验证码的时候，可以说等这种用户操作限制）。使用验证码，服务器端验证过得`记得销毁`。token验证机制，比如请求数据字段中添加一个token，响应请求时`校验其有效性`;

伪造用户身份向好友发送垃圾信息；引导用户去点击链接或者图片，这样会触发请求事件（我的理解是有人特意加入一段代码）
img没有跨域，可以在img的src中写上请求网址，如果获取到cookie就产生安全问题。
获取cookie信息，如果是没有同源策略限制，攻击者会刻意发起请求，这样后台误以为是安全请求，返回需要数据，容易产生安全问题。

讲这块：首先说CSRF是什么（跨域请求伪造）？再讲原理（cookie）？再总结CSRF攻击是是源于WEB的隐式身份验证机制？然后讲有这几个攻击方式，分别解释这几种攻击方式，导致攻击后果？然后讲有几种防御方式

https://www.aliyun.com/jiaocheng/1006189.html?spm=5176.100033.2.7.780150a7b2zsfx

CSRF通过XSS途径来实现，CSRF 和 XSS 根本是两个不同维度上的分类。看起来有点相似,它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户,但前面说了,它们的攻击类型是不同维度上的分类。
我们知道,绝大多数网站是通过 cookie 等方式辨识用户身份(包括使用服务器端 Session 的网站,因为 Session ID 也是大多保存在 cookie 里面的),再予以授权的。所以要伪造用户的正常操作,最好的方法是通过 XSS 或链接欺骗等途径,让用户在本机(即拥有身份 cookie 的浏览器端)发起用户所不知道的请求。


严格意义上来说,CSRF 不能分类为注入攻击,因为 CSRF 的实现途径远远不止 XSS 注入这一条。通过 XSS 来实现 CSRF 易如反掌,但对于设计不佳的网站,一条正常的链接都能造成 CSRF

CSRF攻击的主要目的是让用户在不知情的情况下攻击自己已登录的一个系统，类似于钓鱼。
CSRF攻击的主要目的是让用户在不知情的情况下攻击自己已登录的一个系统，借用用户的身份去执行用户的操作，类似于钓鱼

### XSS
不对服务器端造成任何伤害，注入一段代码。
https://blog.csdn.net/wy_97/article/details/77413317 （关键）
跨站脚本攻击是通过在网页中加入恶意代码，当访问者浏览网页时恶意代码会被执行或者通过给管理员发信息的方式诱使管理员浏览，从而获得管理员权限，控制整个网站。攻击者利用跨站请求伪造能够轻松地强迫用户的浏览器发出非故意的HTTP请求，如诈骗性的电汇请求、修改口令和下载非法的内容等请求。

盗用 cookie ，获取敏感信息：这个注入document.cookie代码

攻击后果:
运行预期之外的脚本可能是一个关不掉的窗口
盗用 cookie ，获取敏感信息（注入document.cookie）
利用iframe、frame、XMLHttpRequest等方式，以用户身份执行一些加好友、发私信等操作。

基于反射的XSS攻击，主要`依靠站点服务端返回脚本`，`在客户端触发执行从而发起Web攻击`。（可以冒充发送url到邮件中）在URL中嵌入恶意脚本（如果url中的值会影响页面渲染，比如url中的值直接影响dom的输出，或者生成js文件，这样会引起页面弹出内容或者获取cookie信息，然后发送到攻击者的站点）。（Web客户端使用服务端脚本生成页面并为用户提供数据）———— 经过服务器，但是不经过数据库。
XSS反射型攻击，恶意代码并没有保存在目标网站，`通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击的`。
`我说：`基于反射的XSS攻击，主要是依赖站点服务器返回脚本生成页面并为用户提供数据，它是在URL中嵌入恶意脚本，如果url中的值会影响页面渲染，比如url中的值直接影响dom的输出，或者生成js文件，这样会引起页面弹出内容或者获取cookie信息，然后发送到攻击者的站点———— 经过服务器，但是不经过数据库

**特征**
- 恶意脚本附加到 url 中。只有点击此链接才会引起攻击
- 不具备持久性，即只要不通过这个特定 url 访问，就不会有问题


基于DOM或本地的XSS攻击（漏洞存在于页面中客户端脚本自身）
比如获取本地域名的cookie信息
类型A，本地利用漏洞，这种漏洞存在于页面中客户端脚本自身。其攻击过程如下所示：
Alice给Bob发送一个恶意构造了Web的URL。
Bob点击并查看了这个URL。
恶意页面中的JavaScript打开一个具有漏洞的HTML页面并将其安装在Bob电脑上。
具有漏洞的HTML页面包含了在Bob电脑本地域执行的JavaScript。
Alice的恶意脚本可以在Bob的电脑上执行Bob所持有的权限下的命令。

不需要服务器解析响应的直接参与，触发XSS`靠的是浏览器端的DOM解析`。

`我说：`基于DOM攻击也是通过URL中嵌入恶意脚本，但是它会影响dom的输出，比如它输入的值正好js脚本中对dom有影响，这个时候就产生了攻击。所以尽量影响dom中值不受url影响———— 不经过服务器，也不经过数据库

```
<script>
  document.getElementById("a").innerHTML="yyyyyy";
</script>
```
如果yyyyyy内容是请求过来的参数，那么攻击者就可以通过构造请求的参数完成DOM XSS攻击。
触发点击input

https://blog.csdn.net/cavalier_anyue/article/details/51069044

基于存储的XSS攻击，是通过发表带有恶意跨域脚本的帖子/文章，从而把恶意脚本存储在服务器，每个访问该帖子/文章的人就会触发执行。
**特征**
- 如果具备持久性（例如数据会存储到服务器上），只要访问这个页面就会触发漏洞代码执行，则认为是存储性 XSS

`我说：`基于存储的XSS攻击，是通过发表带有恶意跨域脚本的帖子/文章，从而把恶意脚本存储在服务器，每个访问该帖子/文章的人就会触发执行———— 经过服务器，也经过数据库

**特征**
对所有用户提交内容进行可靠的输入验证或者过滤；
确认接收的的内容被妥善的规范化，仅包含最小的、安全的Tag(没有javascript)，去掉任何对远程内容的引用(尤其是样式表和javascript)，使用HTTP only的cookie。
1.在输入点过滤敏感关键字
2.innerHTML=encodeHTML([输出])
知道了HTML和JavaScript自动解码的差异，如果防御没有区分这样的场景，就会出现问题 （可以不说）
HTML进行实体转码过滤，特殊字符需要编码过滤。
标签属性事件黑名单。
特殊字符HTML实体转码。



讲这块逻辑：首先说XSS是什么（跨站脚本攻击），讲特点（XSS不对服务器端造成任何伤害，注入一段代码。）？然后讲有这几个攻击方式，分别解释这几种攻击方式，导致攻击后果？然后讲有几种防御方式

http://www.91ri.org/7330.html

黑客攻防技术宝典。

https://www.cnblogs.com/phpstudy2015-6/p/6767032.html#_label7 （解析很详细）

比如：
当输入获取document.cookie脚本时或者弹出窗口或者死循环逻辑或者发恶意邮件，就会触发这些问题。其他只是攻击手段不一样，但是效果同样有这些种。
**原因解析**
主要原因：过于信任客户端提交的数据！
解决办法：不信任任何客户端提交的数据，只要是客户端提交的数据就应该先进行相应的过滤处理然后方可进行下一步的操作。
进一步分析细节：
　　客户端提交的数据本来就是应用所需要的，但是恶意攻击者利用网站对客户端提交数据的信任，在数据中插入一些符号以及javascript代码，那么这些数据将会成为应用代码中的一部分了。那么攻击者就可以肆无忌惮地展开攻击啦。

### jsonp
https://blog.csdn.net/jian_xi/article/details/66472870

1.防止callback参数意外截断js代码,特殊字符单引号双引号,换行符存在风险.
2.防止callback参数恶意添加script标签,造成xss漏洞
3.防止跨域请求滥用,阻止非法站点恶意调用
先原理再应用场景
应用场景：用js进行封装的数据


