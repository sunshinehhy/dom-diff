**2017.12.18**
## <font color="red">订阅</font>
 ### 订阅相关类：
 - SKPaymentQueue
 - SKPaymentTransaction
 - SKPayment

  ### iap内核：

    在iOS中应用程序的购买是由StoreKit框架提供的，该框架自ios3以来一直存在。StoreKit是一系列简化了整个内购过程的类。它的目的是成为你与App Store的主接口。而且它还帮助处理诸如支付处理、接收处理、甚至是提供可下载内容的任务，而这些内容是你直接选择的。应用程序内购买的数字商品或服务可以在你的应用程序内购买。这不是指实体商品，而是指数字产品或服务。

    您有可消费的产品，这些产品可以购买，一旦使用，用户将不得不再次购买。换句话说，这些产品在使用后不会粘在一起。
    一个可消费产品的例子是一个视频游戏的电源，一旦用户激活它，他们的力量就会持续一个有限的时间，在那个时间结束之后，他们将不得不在以后再购买一个。

    你也可以添加非消耗品。这些产品可以在用户购买后多次使用。一个例子就是我们将在我们的应用程序中加入的拍照功能，一旦用户购买了它，他们就可以在自己的笔记中添加图片，并将其添加到自己的笔记中。另外，因为任何原因他们都需要重新安装这个应用程序，用户将来也可以恢复这个功能。你也可以添加订阅到你的应用，有两种类型。首先，有不可再生的订阅。

    这些订阅是最后一段时间的订阅，并且不打算在一学期结束后自动续订。例如，您可以提供年度订阅服务，在第一年之后想继续订阅，要求用户重新订阅。另一方面，您可以拥有自动更新的订阅，而这些订阅是指在期限结束后自动更新的。用户将订阅自动更新的订阅，直到他们选择退出。一个好的例子是每月订阅一份杂志或流媒体电视服务。

    iOS 10发布版的订阅经历了一点变化。在过去，订阅只适用于属于特定类别的应用程序。现在，订阅不是类别依赖的意思，你可以为几乎任何东西创建订阅购买。但是，你购买的产品在应用程序审查期间仍然需要进行检查，所以如果你的产品不符合订阅的模式，那么你的产品就有可能被拒绝。

    而且，如果您的订阅方在初始期限之后仍然坚持，那么将会有更多的收益返回给开发人员。因此，在第一项中，开发者和苹果的收入差距仍然是70比30。然而，如果用户在第一项之后继续使用，则拆分为85,15，给开发人员额外的15%。你可以为不同的地区设定不同的定价，这让你在其他货币的定价时更加灵活。

    你也有保留定价的能力，比如你开始以一种价格提供你的订阅，但是你想要提高价格。你可以保留那些已经订阅了你的初始价格的人，并且在你选择的日期之后将你的价格提高到新的订户。最后，订阅用户界面允许用户更好地管理升级和降级。因此，如果你的应用程序提供不同的层，你的用户可以更好地浏览它们，而不会破坏他们的用户体验。

    还应该指出的是，在iOS 10中，你现在可以在iMessage应用程序中构建应用程序内的购买功能。因此，如果你选择建立一个iMessage扩展的体验，你可以使用你在这里学习的相同的框架，在他们的应用内购买。

  ### iap过程概述：

    在应用内购时，首先你需要确定你想要提供什么产品，然后在iTunes Connect中设置这些项目。然后你需要在你的应用程序中建立店面并处理用户交互。这就是从显示产品到选择项目、解锁功能甚至恢复购买的一切。因此，当您的用户与您的商店进行交互时，StoreKit框架会再次处理所有必需的事务项，并与应用程序商店进行通信。

    在完成它所需要的所有功能之后，它会将数据返回给您的应用程序，并最终返回给您的用户。然后，如果需要，您可以获取返回的数据并与您自己的服务器同步，这样您就可以跟踪额外的消耗和度量。现在，进一步深入研究这个过程，整个内购程序可以分为三个阶段。首先，我们必须检索我们的产品信息。我们的应用程序会向app Store发出产品请求然后返回我们在iTunes Connect中输入的请求的产品信息。

    我们的应用程序将会接收返回的内容并在我们自己的商店UI中显示。然后在第二阶段，这是我们要求支付的地方。我们的用户会选择一个他们想购买的产品然后我们的应用会向app Store支付这个产品的支付请求。第三阶段是交付阶段，这是appStore处理我们付款的地方，如果成功，它会向我们的应用程序的观察者发送响应，我们的应用程序的任务是向用户交付所请求的产品。

    这是我们触发需求下载、提供一次性产品或激活订阅的部分。当我们测试我们的内购功能时，我们通过在沙箱环境中进行测试来实现。在这里，我们可以测试我们正在构建的所有不同功能，而不需要这样做。你可以在iTunes Connect中创建沙盒帐号，或者你可以使用你的iTunes账户。后者是理想的，如果您有一组测试测试人员在您的直接开发组织之外。

    当在沙箱环境中测试时，应用程序商店知道这一点，并且在你测试的时候不会对iTunes账户进行购买。但是，在沙箱环境中进行的采购将不会继续进行生产。在测试的过程中，我不能强调一次又一次地测试功能的重要性。这是你的用户第一次与你的商店互动，你想给他们留下一个好印象，让他们继续回来。应该注意的是，从StoreKit返回到您的大多数错误都不是要呈现给您的用户的。

    相反，这些错误决定了你的应用程序应该如何处理某些事情，所以这些错误是针对开发者的。现在，关于您将要返回的错误类型的更多信息，请您提供应用内购买指南或存储框架指南，这些都可以在开发人员门户中找到。

  ### 看StoreKit框架：

    当你使用StoreKit时，你首先需要做的是在启动应用程序时从设备上获取一个指向默认支付队列的指针，通过调用skpaymentqueue.default。要接收回调，您需要实现SKPaymentQueueDelegate协议。SKPaymentQueueDelegate有一个叫做paymentQueue回调:updatedTransactions,叫做每当发生交易状态的变化。不同的事务状态是购买、延迟、失败、购买和恢复。

      我们将要看到的重要的是购买了的，然而，另一个重要的被推迟了，当要求购买特性是在iTunes家庭帐户上实现的时候触发。这是父母控制的地方，用户正在等待审批，然后才能完成购买。稍后将详细讨论如何处理这个问题。SKPaymentQueueDelegate还有一些额外的回调,你需要注意到如paymentQueue:restoreCompletedTransactions,叫做当试图恢复以前的购买。

      例如当用户重新安装你的应用新设备和他们想要恢复已经支付的内容,paymentQueue:restoreCompletedTransactionsFailedWithError,当导致购买恢复过程失败时调用,即如果用户恢复从app Store主控的下载时paymentQueue:updatedDownloads被调用和当一个事务是突然从付款队列中删除paymentQueue:removedTransactions被调用。当我们从应用程序商店获取产品信息时，我们将进行一个SKProductRequest。

      现在，SKProductRequest有一个名为SKProductRequestDelegate的委托协议，它会返回App Store中找到的所有匹配的产品。现在，这些SKProducts返回给你，它们都有本地化的属性，你应该使用它们，这样你就可以提供本地化给你的用户的信息。现在，你要使用的关键属性是localizedTitle,localizedDescription,price和priceLocale。关于本地化的一些东西。

    应用商店为你做所有必要的货币转换。因此，你不需要在试图转换货币的功能上写字。只要确保在用户当前的语言环境中显示你的价格，在App Store中的StoreKit就可以完成剩下的工作。在支付请求时，你创建一个SKPaymentObject然后你将这个对象添加到支付队列中。更新付款请求和整体事务过程称为回到paymentQueue:updatedTransactions。

    现在，这是一个简单的概述，您将需要在StoreKit类中使用。让我们继续下一节课，我们将开始把我们的产品输入iTunes Connect。

    manage your products

    Set up products in iTunes Connect

    所以，我在这里，在我的浏览器中，我现在在我的应用程序记录，在iTunes Connect。首先，我们要做的是建立我们店面的App Store部分。我们必须输入我们的产品。我将继续，点击功能。所以，一旦有了功能，我将选择应用内购买。我们可以看到，在这里，我已经创建了一个可消费的测试项目。我在这里有一个消耗品，可以用它来测试我们的代码。非消耗品和订阅项，与购买的iTunes账户保持链接，只能购买一次。

    所以，使用一个iTunes账户，消耗品是解决你代码中的问题的好方法。当你准备好了，你可以在其他项目上进行测试。所以，要添加一个可购买的项，你会来到这里，点击加号按钮。一旦你这样做了，你就会被带到菜单上。然后，你想要选择你想要创建的项目类型。在这种情况下，让我们选择消耗品。一旦我们在项目中详细说明，让我们输入一个名称和一个产品ID，因此，对于名称，它将是测试项。

    对于产品ID，我正使用的是com.notetaker.testitem。但是，您的产品ID和您的引用名称可能会有所不同。你要做的一件事是，确保你的产品ID与你在在Xcode项目中的产品plist文件中相匹配。我们还想确保这件物品可以出售。因此，确保在可用性部分中有一个复选标记。这样做将允许它出现在您的产品请求查询中。

    现在，我们也可以通过选择下拉菜单来设置价格。但是，如果您不选择一个项目，这意味着您的项目是免费的。在定价下，我们有本地化。在这里，我们必须输入我们想要提供的每个本地化的显示名称和描述。正如我们所看到的，英语是自动为我们创造的。如果你的产品是跨国的，你成功的机会增加了，你的市场就越多，你就需要在这里添加支持的语言。

    因此，现在，我将继续，用英语输入一个显示名称和描述。最后一个项目,你要做的,就是,输入您购买的截图,和它在你的应用程序的哪里,进入任何类型的评论家所指出的,如果你想给审稿人一些额外的信息,而他们会通过应用程序审查过程。现在，一旦你进入了这两个项目，继续，点击保存，在屏幕的右上角。因为我已经创建了这个测试项，所以我不打算保存我的。

    所以，我要点击，不要保存，回到我的购买列表。让我们重复这个过程，但是，现在，有一个不可消耗的项目。这将是我们的照片笔记项目。我将继续，然后输入我的产品的详细信息。当我使用非消耗品时，根据价格，我们可以看到内容托管的选项。现在，如果你想在App Store中运行你的产品，你需要打开它。这允许你通过一个已经存在的基础设施来发送可下载的内容，这意味着你不必在你自己的服务器上托管它，如果用户购买的内容是可下载的。

    所以，如果你想这样做，你只需点击打开内容主机。因为我们的只是一个功能，在应用程序中，我们现在不需要这么做。我将向下滚动，我将进入我的本地化。完成后，我将继续，点击Save。回到这里，在我的购买列表中，我想创建一个自动更新订阅，这将用于我们的云备份项。我将继续，选择Create。当你在使用自动更新订阅时，你会得到一些不同的工作流程。

    首先，你仍然输入你的名字和你的产品ID，我将继续，说云备份，然后输入我的产品ID，但是，当我点击Next时，它会要求我创建一个订阅组。现在，所有的自动更新订阅都必须成为订阅组的一部分。现在，在这些订阅组中，您可以提供它们的倍数，但是，用户只能在给定的时间内订阅一组订阅。他们可以通过不同的订阅，在同一组。

    那么，我将继续，创建一个新的订阅组。我们将调用这个备份组。现在，在我将云备份添加到备份组后，我现在被带到信息屏幕，在那里我可以选择其他的项目，因为它们与我的订阅有关。首先，我要选择持续时间。这是你的订阅期。他们可以是一个星期，一个月，几个月，一年。对于这个产品，我想每月使用它。

    然后，在你这样做之后，你可以选择进入一个免费的试用期。而且，我确实想提供一个免费试用期。我想提供为期一周的免费试用。现在，记住，订阅，你可以设定不同的价格，你可以设定一个起始价格，你可以改变你的价格，随着你的到来。如果你想这样做，你可以先设定初始价格。初始价格是99美分。

    现在，如果我想为不同的地区设置不同的价格，我可以选择在这里做。但是，我将继续，点击Save。现在，我有了我的订阅价格，它将保持这个价格，直到我改变它。如果我想添加额外的本地化，我可以继续，点击这个加号，然后，我可以添加我的不同本地化。我想从美国英语开始而且，我们将会说云备份，备份您的笔记，到云!再一次，我们将不得不进入屏幕截图，一旦我们把它放在我们的应用程序中。

    如果我们想添加任何评论，我们可以继续，在这里输入。然后，当我们完成时，我们将继续，点击Save。太好了。现在，让我们继续，回到我们的内购项目列表。现在，我们有三个产品在这里，我们的可消费测试项目，我们的非消耗性照片记录，以及我们的自动更新订阅云备份，我们现在已经准备好进入我们的Xcode项目，并详细介绍它，并开始整合这些特性，在我们的应用程序内部。

    Examine our project files and settings

    我在Xcode中，我想做的第一件事就是检查我的开发环境。我现在在Xcode8中，我们用的是Swift 3。在我们的项目中，我们希望确保我们正在签署我们的项目，并且我正在使用Xcode自动管理签名。我还想确保我在应用程序购买的能力打开了。现在，要想在应用程序购买上打开，有两步必须要做。首先，我们必须把storekit . framework，用于我们的项目，我们还必须确保在我们的app ID上启用了应用程序购买的功能，并且在开发门户中这样做。

    在一般情况下，我将向下滚动这里，我将验证我们实际上已经链接了store kit框架。如您所见，我还链接了两个独立的文件:libssl_iOS和libcrypto_iOS。这是因为我们的项目的收据验证部分必须包含一个名为RM store的开放源码项目，它将帮助我们对我们的接收文件进行设备验证。

    我以后会详细讲这个问题，但是你们会看到，收据验证过程非常复杂，这是有原因的。这是为了确保你的收据和你的购买保持安全。因此，我们不需要遍历所有需要的加密部分，这是收据验证的一个重要部分，我们将使用RM store来帮助我们处理繁重的任务。但我们以后会讲到。

    这里我们有一个管理器文件夹在这个管理器文件夹中我有两个单例对象。首先,我们有IAPManager.swift。这个类将会是我们在应用程序购买逻辑中实现的所有东西。我们看到，到目前为止，这个类被设置为一个singleton，它有两个属性。我们有一个SK产品的请求，我们有一个SK产品的数组，叫做product。接下来,我们有notemanager。在这个类中，它负责处理保存和检索核心数据所需的所有逻辑，我们不需要在这个类中进行任何修改。

    这是我在这里输入的东西，我已经重新开始处理所有的繁重工作，这样我们就可以把注意力集中在应用程序的购买上。下一组我要强调的是控制器文件夹在这里我们有四个视图控制器类在我们的主故事板中有相应的场景。每个类都已经设置好了，足以让我们能够加载、运行和模拟。我们的工作就是把它们分别具体化。我已经创建了一个名为products的属性列表，我在这里输入了它，我们可以看到它有三个项目，它有三个proct id，我们已经在iTunes Connect中输入了。

    我们有一个测试项目，一个用于拍照，另一个用于云备份。这应该表示在我们取回产品时从web服务器返回给我们的数据。稍后我将讨论这个问题以及如何正确地实现这个，但是现在我们看到它在这里，以便我们可以重用它。除此之外，这是一个非常简单的项目。我实际上是在一个master detail产品模板中创建的，然后继续做一些额外的修改。我们有一个app委托，我们有一个主要的故事板，一个资产。xcassets，一个发射屏幕和我们的信息。p列表。

    现在我们已经有了这个项目本身的好主意，让我们开始使用Store Kit，并从应用程序商店请求产品信息。

    Implement the SKProductsRequestDelegate protocol：

    因此，第一个大任务是请求一个产品列表，这些产品目前可以从应用商店中获得。这个产品列表是我们将要填充数组属性的内容，因此我们需要提交一个SK产品请求并观察我们从查询得到的响应的属性。现在，为了得到那个响应，我们需要实现那个对象的委派回调方法，让我们先来做这个。我在IAPManager中，现在我要让这个类遵循SK产品的请求委托协议。

    现在我已经完成了，我想要实现产品请求收到相应的回调函数。现在我们得到的响应有一个属性，这个属性叫做产品，这个属性是一个包含所有与查询匹配的SK产品的数组。所以在此我要做的是，我想 设置我们的产品属性为响应属性。太好了。现在我已经完成了，我们已经处理了SK产品请求的回调部分，让我们继续下一节课，我们继续创建这个产品请求并将其付诸行动。
    let products = response.products

    Request products from the App Store:

    当从app store请求可用产品列表时，我们需要提供一系列产品标识符列表供查询。匹配的任何事将会回到我们SKProductsRequestDelegate回调。我将创建一个名为get product identifier的函数它将返回一个字符串数组，这些数组的每个字符串都是我们想要查询的产品的标识符。现在，提供这个标识符列表可以通过两种方式完成。我们可以用已经输入的产品标识符来烘烤我们的应用程序，或者我们可以调用我们托管的web服务器并检索标识符列表。

    现在，两者都有好处。如果我们要用产品标识来烘烤我们的应用程序，我们只是简单地将这些项硬编码成一个数组，然后，我们会将该数组包含到我们的产品请求中。虽然这是最简单的方法，但它也是最不具有可伸缩性的，因为每次您想要添加或删除产品时，您都需要提交一个新的应用程序更新。现在，当您使用web服务器时，您可以动态地更新您的产品列表，并且每次您的store加载时，您可以对您的服务器进行一个调用，并更新可用的产品列表。

    这与在iTunes connect中使用的标记产品相结合，可以为你提供一个很好的方式让你的店面保持新鲜，而不需要你的用户随时更新他们的应用。在这节课中，我们不会讨论如何建立一个web服务器来完成这个任务，因为有很多方法可以完成这个任务。然而，对于我们的getproductidentifier函数，我们仅仅是通过构建基于plist文件的一系列项目，来模拟web服务器的响应。

    在我们的getproductidentifier函数中，我将创建一个名为标识符的变量，我将把它作为一个包含字符串对象的数组进行类型转换。现在我要把它初始化。在我这样做之后，让我们继续添加我们的返回值，我们可以返回我们的标识符。然而，我们并没有这样做。我们需要做一些事情。让我来创建一些空间我们将在函数之间进行工作。我现在要检查是否可以创建一个url到我们的产品plist中。

    我将通过检查资源的bundleMainURL来实现这一点。对于资源名，我们要放入产品。对于扩展名，我们赋为plist。如果文件url存在，我要做的是创建一个基于内容的nsarray。一旦我这样做了，我将继续遍历所有的产品数组，在这里的每个条目中，我将把它添加到我们的标识符数组中。

    再次，看一下我们的getproductidentifier函数，首先我要做的是初始化一个数组，我们期望它包含字符串。然后，我将检查我们的主bundle，看看是否有一个产品p列表文件，如果是，我们将创建一个数组。然后，我们将遍历我们的产品数组，并且对于我们找到的每个条目，我们将它添加到我们的标识符数组中，然后返回它。接下来，我要创建一个函数来执行实际的产品请求。

    让我跳到下面这里，我将创建一个名为performproductrequest的函数来寻找标识符。现在，这个函数将接受一个参数，它将被称为标识符。这将是一个字符串数组。现在，在这个函数中，我要做的第一件事是创建一个nsset对象它将基于传入的参数数组。让我们来调用这个产品，我将说nsset我们将使用我们正在传入的数组。

    现在我要把它打开来设置成setstring。现在我们有了这个，我将初始化我们的Skrequestproperty，然后我们将设置self。要求，等于Skproductsrequest。对于它的产品标识符参数，我们将传递我们刚刚创建的产品。然后，我们希望设置请求委托属性，最后，我们希望启动请求。

    现在我们到了这里，我要做的是调用一个函数来将所有这些联系起来。我将创建一个名为requestproducts的功能,在这里我们要叫self.performrequestsforidentifiers。现在,标识符的参数,我们只是要self.getproductidentifiers打电话。现在为了测试，我想做的是回到我们的产品请求委托调用。

    我要做的是，一旦我们得到它，我想简单地打印出响应。所以我要说，print,response。当这个完全回调时，我们会看到输出到log。现在我们要做的最后一件事是调用函数请求产品。我将跳转到我们的应用程序委托，我将会来到应用程序完成启动和选项，我将简单地调用我们的函数。

    现在我有这条线在这里,我要做的就是我要运行我们的应用对我们的设备和加载应用程序时,它会调用请求的产品和日志出现时,我们应该看到一个打印的响应对象。我们来做一下，确保这是可行的。很好，我们看到我们的应用程序加载了如果我们看一下我们的日志，我们看到我们有一个Skproductresponse。这很好，我们看到我们得到了响应。现在让我们确保所有的产品都在这里。

    所以我要回到这里给IAPManager。在这里，在product request中，收到响应，我想通过这个响应迭代，我想打印出所有不同的产品。所以对自我的产品说、printproduct .localizedtitle，我很快就会来到这里，。我将继续运行我们的应用程序。

    现在我们看到我们的应用程序负载，如果我们看一下我们的控制台，现在我们得到了我们输入的三个项目。我们有云备份，我们的照片说明和我们的商店套件测试项目。很好，现在我们可以从app store检索产品了，让我们继续下一节课我们将在我们的店面中展示这些东西。

    Create a SKPayment：

    最后我们还可以看到产品列表;然而，无论何时我们利用我们的产品，什么都没有发生。在这节课中，我们将讨论如何处理交互和支付请求。所以我想去找IAPManager.Swift。我想跳到课程的最底层，我要创建一个新的函数。这个函数,我们将称之为createPaymentRequestForProduct。所以这个函数的目的是，能够接收到一个产品并创建一个skmumu_payment。

    一旦我们这样做了，我们将把它添加到我们系统的默认支付队列中，这样我们就可以把它提交到App Store。我们来做这个，然后我们会解释代码。好的，让我们看一下我在这里输入的代码。如您所见，这是您为App Store创建支付请求所需的最低限度。你创建一个SKMutable payment ，你需要传递它一个产品，我们正在使用这个函数调用时的产品。

    我们将付款数量设为1，并且你必须在你的付款申请中有一个数量，以便它知道要对多少项收费。我们选择的数量是一个，因为我们的订阅项只有一个数量。在我们的照片说明中，我们的非消耗品，我们希望它是一个数量。而我们的测试项目，我们也希望这些是一个量，这样我们就可以继续消耗它们。如果我们想动态地创建这个数量，你可以通过一个参数来表示你想要的数字，你可以把它添加到支付请求中，但是你必须有一个数量和你的SKMutable payment。

    最后我们要做的是获取默认的SKPaymentQueue，并将支付添加到它。当你这样做的时候，这就开始了交易过程。它要求用户登录iTunes，如果他们最近没有登录，然后它会问他们是否想确认他们的购买，如果用户按下购买，那么它就会启动整个交易流程和应用程序商店。现在我们来调用刚才创建的函数。所以我想跳过StoreTableViewController,我想去到函数tableView_didSelectRowAt indexPath。

    我想在这里做的是抓取在indexPath中的product数组中的产品。行值，然后我想把这个产品传递给我们要创建支付请求的函数。我们来做一下。让我们运行应用程序看看会发生什么。好的，我在我们的应用程序中，我要按下gear图标。我们看到了我们的Add On Store所以我将继续点击它，然后我将点击StoreKit测试项。

    当我做的时候，它会问我是否想要登录App Store，所以我要继续做这个。我使用的是我创建的沙箱帐户。当我按下OK，它会登陆，然后它会问我是否想确认我的内购，它问我是否想买我的一项StoreKit测试项目。它让我知道我在环境沙箱里。如果我按下Buy，我们将会用App Store启动整个交易过程。如果我按下取消，我们就取消购买。

    现在我们可以处理整个应用程序商店的事务处理过程，我们需要观察默认的SKPaymentQueue。现在让我们在窗口上按一下Cancel，这样我们就不会发起购买了，让我们进入下一个课程，我们将讨论观察SKPayment默认队列。

    我要按下ok。这是对我们的支付队列的监控，我们肯定会充实这个委托函数还有很多其他的，因为我们的课程会继续，但是现在让我们继续下一节课我们将讨论处理递延事务。

    Handle deferred transactions：

    我们需要确保处理的一个支付事务状态是递延事务状态。这个状态从ios8开始就已经存在了，它是当一个事务仍然在队列中时被调用的状态，但是它正在等待某种形式的外部操作，比如请求购买带有iTunes家庭帐户的特性。现在，在这个状态下，一个事务将在一个队列中无限期地存在，您将通过另一个回调来查看您的最终状态，以便在稍后的时间内对更新的事务进行支付队列。

    因为我们不知道这个回调是什么时候发生的，你不想因为这个状态而阻塞你的UI。你可能会不小心让你的应用程序在很长时间内无法使用。模拟一个付款请求，此请求会触发一个延期付款交易,你想设置 你的SKMutablePayment的simulatesAskToBuyInSandbox flag。这样做会将事务返回到带有延迟状态的回调。你应该让你的应用程序做出相应的响应。

    Receipt validation：

目前，我们的应用程序完成了一次交易，一旦购买完成。而现在，我们需要做更多的尽职调查，以确认购买不是假的。现在要做这个，我们需要了解App Store收据，当我们完成购买时，它会返回给我们。App Store收据是应用程序和应用内购买的可信记录。它列出了一个应用程序是在特定日期为特定设备购买的。它还列出了在特定日期为该应用购买的任何iap。

它存储在app容器中，你可以使用NSBundle API访问它。只需查找主包App Store URL属性即可。你可以把数据取出来，创建一个NSData对象，来处理接收二进制文件。这个收据是由苹果公司发布的，同样，它只针对特定的设备。收据是在购买时发出的，对于某些类型的内购是可更新的。

可消费的或不可再生的订阅将不会出现在一个刷新的应用程序收据上。然而，非消耗性和自动更新的应用内购买总是会出现在收据上。现在，如果您需要从应用程序商店获得新的收据，您可以通过Store kit API SKReceiptRefreshRequest请求它。这需要网络，并且需要用户登录才能完成这个过程。

您要做的一件事是避免验证和请求新收据的连续循环。您不希望不断地检查启动，如果验证失败，就取回。应该注意的是，收据也是加密的。通过使用不同的开放标准，您需要在检查收据本身之前对内容解密。首先，它是一个PKCS 7加密容器，它被编码在asn . 1中。

要想解密此消息，需要加载OpenSSL或asn1.c之类的库，它不包含在Xcode中，但是是开源的，可以访问您的搜索。我已经将OpenSSL构建并连接到我们正在使用的项目文件中。现在，当您解密容器时，您应该评估签名和证书，以确保您所信任的收据实际上是有效的。因此，验证根证书颁发机构来自苹果。

`虽然证书有一个过期日期，但您不应该对此进行检查，因为发行日期并不意味着过期日期在将来是有效的`。相反，您将希望在发出收据时进行比较，以`查看证书是否在规定的时间段内有效`。需要执行的另一种验证方法是在收据上与该应用程序进行比较时检查捆绑包标识符和版本。

在收据中，您希望使用Type 2或Type 3属性进行验证。这些是bundle标识符和app版本。类型4和类型5是指您还想要检查的SHA1散列。类型4是不透明的值，类型5是实际的SHA1散列。你想要在你的应用程序中对这些硬编码的条目进行验证。在过去，对相同的值进行比较，但是在p - list中。

但是，很明显，恶意用户可以轻松地使用二进制文件并修改p - list数据以获得伪造的收据的验证。您的收据包含关于所有应用程序购买的信息，这些是文档中的17类属性。每个应用程序购买的记录都是一个记录。现在，这些类型的17个属性都有自己的ASN。1文件，以及关于你的内购的详细信息。

你有这样的类型，像1701是数量，1702是产品标识符，1703是交易标识符，1704是购买日期。现在，在使用订阅时，您还需要在应用程序购买收据中验证类型1708，这是一个订阅过期日期。现在你还需要检查的是在实际应用程序收据上的19类型。

当购买被做，这是最初的应用程序版本。如果你把你的应用程序作为一次性支付，但随后决定将你的商业模式转换为订阅，这个数据是非常有用的。您可以使用此信息来了解是否将应用程序视为付费版本或订阅版本。现在，在验证和验证您的收据时，您可以选择两个选项。您可以进行设备验证，这意味着您将在应用程序中打开您的特性和内容。

没有必要做任何其他事情，因为你在本地确认一切。现在，如果你要做这个方法，我想敦促你尽量不要使用现成的解决方案。我们的项目应用程序有RMStore，它是一个开放源码项目，任何人都可以免费使用。我们正在使用它的功能来处理我们的收据验证。但是，如果攻击者发现了这个工具包中的缺陷，那么他们就可以很容易地利用我们的应用程序。

我们仅用这个来进行演示购买，我绝不建议让它成为应用程序的安全机制的中心。您应该最终生成自己的验证算法。现在，`另一种接收验证的方法是通过服务器到服务器API`。在这个特殊的例子中，我们有我们的设备，我们有一个我们操作的托管服务器，我们有应用程序商店。我们要做的是，`从我们的设备，我们将把我们的收据数据上传到我们的服务器`。

`我们的服务器将会接收这些数据，并通过一个API将其发送到App Store，该API可以访问web服务器。现在App Store会接收我们的接收数据，它会验证它，它会将JSON的响应发送到我们的服务器。然后我们的服务器就可以把它调出来，然后把响应发送回我们的设备`。现在，我们之所以要这么做是因为我们将安全从设备控制到托管服务器。

`因此，我们能够建立机制来确保我们的设备实际上连接到我们的服务器，而不是一个不同的服务器`。与此同时，我们的托管服务器也可以进行同样的安全检查，以验证它是否将你的收据数据发送到应用程序商店，它实际上是从应用程序商店接收数据而不是其他人。反过来，它会以可信的方式将数据从服务器返回到您的设备。所以每个链接，你都希望服务能在那里。

`我们想要防止的是中间人攻击，所以不要直接从你的设备发送收据数据到App Store`。一直使用你的个人中间服务器。现在，中间攻击的人是你认为你向一台服务器发送信息的地方，然而，你和设备之间可以安装一个假服务器，反过来，你的接收数据就会被拦截。而且由于你的设备正在等待响应，这个假冒的商店可以制造一个恶意的信息，然后把它发送给你，完全阻止你输入的任何安全层。

这就是为什么我们要用我们控制的中间服务器来验证收据的重要性。

Validate an App Store receipt：

为了在本地验证收据数据，我将使用我与项目绑定的开源包RMStore。特别是，我们将使用RMStore应用程序收据验证器。提醒一下，如果你跟随你自己的项目文件而不使用捆绑的练习文件，如果你要使用RMStore，你需要静态地链接打开的SSL库，否则你的应用程序就不能正常的构建。另外，由于RMStore是一个objective - c项目，您应该在导入该代码时重新创建了一个桥接头。

现在，让我们进入IAP manager，向下滚动到类的底部。这里，我想创建一个名为validate receipt的函数。在这个函数中，我要做的第一件事是初始化我的RMStore应用程序收据验证器。我们的验证器有一个方法叫验证应用程序收据，它返回一个布尔值。该方法将抓取我们的应用程序收据，解密并验证我们的收据是否正确。

我们来检查一下。处理if子句，如果收据验证了，我只是想抓住我的处理程序，我想要传递一个真实的语句。如果没有，现在我们只是简单地传递一个错误的声明。现在我在这里，让我们继续跳到我们的支付队列更新的事务函数。在这里，我想做的是修改我们在购买的案例中所做的事情。

目前，我们正在打印一条已经购买的线，我们正在让我们的付款队列完成交易。然而，我们现在还不想这么做。我要做的首先是我想核实我们的收据一旦我们收到购买的交易只是为了确保事实上一切检查从a到z一旦确认,我们就可以完成我们的交易和做其他事情,比如解锁功能并保存新购买。让我们把线移开，我想调用self。验证收据，让我们进入完成处理程序。

在那里，让我们来看看我们是否获得了成功。如果我们是，那么我想完成交易。在else子句中，我们继续，声明收据没有生效，我们将继续，在以后的时间内解决这个问题。再一次，让我们看看我们做了什么。我们去到付款队列更新的交易，当我们收到购买交易时，我们不想仅仅接受它是被购买的，所以我们调用我们创建的validate receipt函数，它反过来会触发RMStore应用程序收据验证器去做它的事情。

然后在返回的完成处理程序中，如果它成功了，我们会说收据被验证了我们将让我们的支付队列完成交易。但是如果它没有验证，我们只需要打印出收据没有验证的内容。现在我们有了这个，让我们继续下一节课我们将讨论持续购买。

  Persisting purchases：

  当我们想要坚持购买时，我们本质上是想要追踪我们app中某个对象的购买行为，所以有很多方法可以做到这一点。`其中之一是在我们自己的私有web服务器上跟踪这些内容，在购买事务完成之后，我们可以这样做。这是一个很好的方法来确保我们保持同步`。比如，如果我们有一个游戏，我们试着记录一个用户购买多少个硬币，或者他们使用了多少个电源。

  现在我们`可以使用UserDefaults来保存购买`的另一种方法，这是一种非常简单的方法。如果我们看一下DetailViewController，我将跳到这个我在这里创建的函数叫做photoButtonPressed。这个函数是在DetailViewController中按下照片图标时调用的。正如我们在这里看到的，在第145行中，我检查了一个键的UserDefaults和我们正在使用的键。

  这是照片注释功能，也是产品标识符。所以我要做的是检查我们是否有这个bouillon，如果它是真的，那么照片说明就被解锁了。所以我们要打印那条线，这个功能应该进一步充实。但是，如果UserDefault不在那里，或者如果它是假的，我们将向用户显示一个警告，提示“购买我!”“我们要让他们来我们店里。”来到IAPManager，我想引入一些逻辑来进行购买，它会抓取产品标识符并相应地设置UserDefaults。

  在IAPManager中，我将向下滚动到类的底部，我将创建一个新函数。这个函数叫做persistPurchases（“持续购买”）我们将在这里保留这个函数，我将继续创建另一个函数来设置我们的UserDefaults。在这里，我只需要调用UserDefaults。我将设置我们正在传递的密钥的bouillon值。因为我们想要解锁，我要将值设为true而键是我们要传入的标识符。

  `然后我们需要同步这些UserDefaults`。在我的persistPurchases中，我只是想要遍历它将要传递的数组，对于每个RMAppReceiptIAP item，我们将抓取它的产品标识符并将其传递给我们未锁定的产品标识符函数。最后我要做的是回到validateReceipt函数。我想在我们的完成处理器中添加一个不同的项。

  我想要添加的是我们的RMAppReceipt iap数组。我们要把它变成可选的。然后让我们更新我们的处理程序调用。所以如果我们做验证,我们将返回true,然后我们将返回verifier.appReceipt.inAppPurchases。对于错误处理程序，我们会说nil。现在让我们返回到paymentQueue updatedTransactions。

  在这里，我们需要修正我们的呼叫。为了成功，我们会有这个，我们会有购买，如果成功，那么让我们更新我们的成功条款，这样如果有成功，我们就可以调用self.persistPurchases，并且对于购买，我们将从完成处理程序中传递给我们的东西。现在我们已经完成了，让我们继续运行我们的应用程序，并验证我们是否能够坚持我们的购买。

  好吧。在我们的app中，我要点击加号，这样我们就可以进入一个新的音符了。在这里，我们看到我们的照片注释图标到右上角。如果我点击它，它会说“嘿，给我买!”在你的笔记中添加图片。“我们回去吧，我们去商店。”所以，你就可以去到艾登商店。让我们购买我们的照片。让我们来看看这个过程，它将验证我们是否会购买。

  当我买的时候，我们看一看，我们看到“谢谢你”。你的购买是成功的。现在，让我们看一下Xcode中的控制台日志。正如我们看到的，我们点击了购买，我们也得到了收据被确认的电话。很好，我们知道我们的收据验证是有效的。现在，为了最终的测试，让我们进行反击。点击完成，离开我们的商店，去我们的新笔记，我将击中相机图标。

  正如我们在Xcode中的控制台所看到的，我们看到照片注释被解锁了。因此，它确保了我们的购买持久性已经得到了处理。

  Persisting auto-renewing subscriptions：

  当我们与我们的自动更新订阅，云备份功能，我们如何坚持我们的购买将只是一个tad不同。我们仍然希望使用用户默认的方式解锁功能，但是因为订阅可能过期，我们需要包括一种方法来锁定一个功能备份。现在，如果我们记得我们的app store收据，`如果它是自动更新的订阅，它也会有一个1708的属性，也就是订阅的截止日期。`

  我们想要`检查设备当前日期与此属性`，以查看描述是否应该保持活跃。我在IAP Manager中，我将跳到类的最底层。我将创建一个名为lock product identifier的函数，这个函数将会与解锁产品标识符类似，除非我们为boulean设置一个错误值我们将同步用户的默认值。让我来做一下。

  很直接。为我们传入的标识符字符串设置伪值，并同步。现在让我们看一下我们的函数持久化购买。在遍历购买数组时，应该检查购买是否有订阅结束日期。如果是这样的话，我们知道我们将会使用自动更新订阅。我来输入这个代码。如果购买没有结束日期，那么我们就像对待购买的其他物品一样对待它。

  我们继续打开这个标识符。现在回到我们的自动更新订阅。我们要做的是检查结束日期，看看我们的订阅是否仍然有效。现在有很多不同的方法可以处理这个问题,但是与我们的RM应用RM收据IAP对象涉及与我们的应用收到IAP对象调用它带有一个函数是活跃的再生订阅,将到期日期,我们通过它,它会返回给我们的boulean，也就是它的状态再生订阅是否活跃。
  
  现在让我进入这个。我们要检查是否有主动的自动更新订阅，并且如果我们想要打开这个功能，我先复制粘贴这段代码。但是，如果它是不活动的，那么我们就想要使用我们拥有的锁产品标识符函数，这样我们就可以将该特性锁起来。所以我们要说self.lockProductIdentifier。和字符串是purchase.productIdentifier。

  `现在，当我们使用自动更新订阅的时候，订阅更新，无论是试验周期的结束还是订阅期限的结束，一个新的收据将自动生成并发送到你的应用程序容器。这通常发生在订阅开始更新的前几天。在收据上，它将包含一个更新的截止日期供您订阅。所以一定要在代码中验证这一点。现在我要做的最后一件事是在支票上写，看看我们的云订阅是否活跃。`

  让我们进入设置表视图控制器。现在我要创建一个叫做，云服务的函数?这个函数要做的是检查云服务是否活跃，如果它是活跃的，它会返回一个状态字符串。如果不是，我们将返回一个字符串，该字符串表示云服务是不活动的。所以看一下这个函数它是很直接的。我们正在检查钥匙com.notetaker.cloudbackup，如果它是可用的，那么我们将返回字符串云备份。

  如果它不是我们返回字符串，云备份是关闭的，我想要做的是，我想把这个函数命名为表视图标题为footer和section。我想把这个footer添加到第二个部分中，它显示了我们的add on store。我要做的是重载这个表格视图标题为footer和section函数。在这里我将执行一个简单的切换语句在我们正在传递的部分中，如果它是我们在存储中添加的部分，我将调用这个函数，如果不是，我们将返回一个空字符串。
  
  让我们在设备上运行这个，看看是否一切都像我们期望的那样。我要按下取消键现在我要按下gear图标。当我这样做的时候，我看到了我的add on store，在它下面有一个footer，它说云备份是关闭的，这是我所期望的，因为我们还没有购买这个项目。我们继续，点击add on store。我们看到我们的项目。现在我要选择云备份。

  它会让我登录iTunes商店。所以当我们处理订阅时，我们在这个购买过程中首先要提到的是订阅条款。它让我们知道我们订阅了云备份。订阅免费试用7天，之后我们会按月收取99美分。它让我们知道我们有一个音箱的环境如果我们想选择继续我们可以按这个。我们继续。

  它会确认的。然后我要按下ok，这样做。有了自动更新订阅用户，用户可以选择将他们的信息提交给开发人员，以便您可以随时跟踪任何需要的额外用途。用户可以选择允许或不允许，您将在iTunes Connect的报告中收到此信息。所以我要选择allow。看看这里的ex代码，如果我查看我的控制台，我看到我们已经达到了购买状态，并且确认了收据。

  现在，在我的设备上，如果我回车，我想关闭商店，然后按下齿轮图标把它打开。我们看到，现在表视图刷新了，它检测到我们的云备份启用了。所以现在我们的应用程序能够处理定期的购买和自动更新的订阅。让我们继续下一节课，我们将讨论恢复已完成的事务。

Restore purchases：

我们的程序差不多完成了。然而，我们还有一项任务要做。我们希望给用户一个机制来`恢复已完成的事务`，并且当用户需要在设备上`重新安装他们的应用程序时，这可能需要发生`。这里我要注意的是，`非消耗性产品和自动更新订阅是通过我将要演示的恢复API来处理的。可使用和非更新的订阅应该由开发人员通过一个保存了这些购买记录的web服务器来处理。`

现在我在IAPManager中，我想跳到这个类的底部，我将创建一个名为restoreTransactions的函数。我想`用这个函数调用默认支付队列恢复已完成的事务方法。这个过程从应用程序商店中提取一个更新的收据，并还原出现在收据上的每个单独的事务。如果我们希望在事务恢复时得到通知，我们希望观察支付队列，以便我们可以检查这些通知。`

让我们看一下paymentQueue updatedTransactions。我们将在switch语句中看到，我们正在处理恢复的情况，目前在这种情况下，我们只是告诉队列完成事务，然后打印出恢复的行。让我们继续跳到IAPManager的底部。支付队列的恢复完成的事务功能是，在完成整个恢复过程后，它执行回调。

因此，我希望实现以下方法。func paymentQueueRestoreCompletedTransactionsFinished,当我们成功地完成了恢复过程，这再次被调用。现在我想暂时别管这个函数因为我想添加另一个委托出现的回调,paymentQueueRestoreCompletedTransactionsFailedWithError的函数。这是在恢复过程中出现错误时被调用的，我们必须学习如何处理这个，所以现在我要把错误打印出来。

那么让我们回到这里paymentQueueRestoreCompletedTransactions。我想在这里做什么?我实际上想做的是，我想分析，由于这个恢复过程给我们的新的收据，然后基于有效性的收据,我想开始在它里面发现的持续购买,所以我们已经做了大量的代码,所以我们可以重用,实现相同的结果正如我们所当我们最初购买项目。

现在如果我们有这个收据的问题，让我们先打印一条线，让我们知道在恢复过程中我们有一个收据验证的问题。现在我们有我们的函数来处理产品恢复,我们需要能够调用这个,所以我要跳过SettingsTableViewController。在这里，我有一个叫做`恢复购买的函数`，当我们点击这个视图左上角的restore按钮时，这个函数就会被调用。

我要做的是调用IAPManager.sharedInstance.restoreTransactions，每当我点击那个按钮，它就会启动并启动进程。此外，你应该登出你的iTunes账户，迫使StoreKit在恢复交易前请求验证。现在我要在我的设备上运行我的应用程序，它将重新安装。如果你第一次打开你的应用程序，你被带到一个窗口，要求你登录iTunes商店，现在就去点击取消。

现在我要做的是快速访问应用程序,以确保我们的购买都启用,所以如果我单击+图标,然后单击图片图标,我们可以看到,在显示警报通知我我应该购买这种产品。好了，我回车了，现在我要到gear图标了。我在Add On Store下看到了云备份现在已经关闭了，让我们开始恢复进程，当我们做的时候，我想让你同时注意到设备，以及在Xcode的控制台上被输出的东西。

点击恢复。它会让我登录。所以我去这样做。现在看看在这个过程中发生了什么。我们在控制台看到我们的物品已经恢复。我们收到通知，恢复已经完成，我们还坚持恢复购买。回到我们的设备，如果我点击Done按钮，然后再次点击gear图标，我们看到云备份已经被启用。

然后如果我加上图标，然后点击相机，我们会看到在Xcode的控制台，我们的照片节点被解锁了。就是这样了。要到这里，有很多步骤。然而，我们现在可以与应用商店沟通，购买，保存产品，处理订阅，甚至恢复完成的事务，不管什么原因，用户需要重新安装我们的应用程序。

### 我的理解

购买数字产品或者服务。公司是卖非消耗品，使用时间期限。
在iOS 10中，现在可以在iMessage应用程序中构建应用程序内的购买功能
首先，我们必须**检索我们的产品信息**。我们的应用程序会向app Store`发出产品请求然后返回我们在iTunes Connect中输入的请求的产品信息`。
我们的应用程序将会接收返回的内容并在我们自己的商店UI中显示。然后在第二阶段，这是我们**要求支付**的地方。我们的`用户会选择一个他们想购买的产品`然后我们的`应用会向app Store支付这个产品的支付请求`。第三阶段是**交付阶段**，这是`appStore处理我们付款的地方，如果成功，它会向我们的应用程序的观察者发送响应`，我们的应用程序的任务是`向用户交付所请求的产品`。

`发出产品请求`然后返回我们在iTunes Connect中输入的请求的产品信息-->将接收返回的内容在我们自己的`商店UI中显示`-->用户会选择一个他们想购买的产品-->应用会向app Store支付这个产品的支付请求-->appStore处理我们付款的地方，如果成功，它会向我们的应用程序的`观察者发送响应`-->应用程序向用户交付所请求的产品(在UI中有体现)


skpaymentqueue.default:从设备上获取一个指向默认支付队列的指针
SKPaymentQueueDelegate协议:接收回调,它有paymentQueue回调:updatedTransactions,叫做每当发生交易状态的变化。不同的事务状态是购买、延迟、失败、购买和恢复
当我们从应用程序商店获取产品信息时，我们将进行一个SKProductRequest。
SKProductRequest：我们从应用程序商店获取产品信息

一个类：一个SK产品的请求，我们有一个SK产品的数组，叫做product
一个类：负责处理保存和检索核心数据所需的所有逻辑，我们不需要在这个类中进行任何修改。

购买时，会返回收据：
它存储在app容器中，你可以使用NSBundle API访问它。只需查找主包App Store URL属性即可。你可以把数据取出来，创建一个NSData对象，来处理接收二进制文件。这个收据是由苹果公司发布的，同样，它只针对特定的设备。收据是在购买时发出的，对于某些类型的内购是可更新的。
`可消费的或不可再生的订阅将不会出现在一个刷新的应用程序收据上。然而，非消耗性和自动更新的应用内购买总是会出现在收据上。`现在，如果您需要从应用程序商店获得新的收据，您可以通过Store kit API SKReceiptRefreshRequest请求它。

`您要做的一件事是避免验证和请求新收据的连续循环。您不希望不断地检查启动，如果验证失败，就取回。应该注意的是，收据也是加密的。通过使用不同的开放标准，您需要在检查收据本身之前对内容解密。`
```
let dict = [
      "receipt-data": receiptString,
      "user-id": UserInfo.shared.userId ?? "",
      "user-name": UserInfo.shared.userName ?? "",
      "device-token": UserInfo.shared.deviceToken ?? ""
  ] as [String : String]

```
本地保存这些购买信息。
更新订阅截止日期
收据上包含订阅截止时间。
当设备更换时，请求后台
当我们使用自动更新订阅的时候，订阅更新，无论是试验周期的结束还是订阅期限的结束，一个`新的收据将自动生成并发送到你的应用程序容器。`

恢复购买：
MARK: `1. First save the purchase information to device`
  savePurchaseInfoToDevice(transaction, actionType: actionType, productId: productId)
MARK:` 2. Use the saved information to update Privileges`
  PrivilegeHelper.updateFromDevice()
MARK: `3. Send notification to related objects such the view controllers and iap views so that UI can be updated`
deliverPurchaseNotificationFor(actionType, identifier: productId, date: transaction.transactionDate)
        SKPaymentQueue.default().finishTransaction(transaction)