箭头函数有几个使用注意点。

1. 函数体内的this对象，就是`定义时所在的对象，而不是使用时所在的对象`。

```
    var obj = {
    a: 10,
    b: () => {
        console.log(this.a); // undefined
        console.log(this); // Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}
    },
    c: function() {
        console.log(this.a); // 10
        console.log(this); // {a: 10, b: ƒ, c: ƒ}
    }
    }
    obj.b(); 
    obj.c();
```
```
    var obj = {
    a: 10,
    b: function(){
        console.log(this.a); //10
    },
    c: function() {
        return ()=>{
            console.log(this.a); //10
        }
    }
    }
    obj.b(); 
    obj.c()();
```


2. 箭头函数是匿名函数，不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
```
    let FunConstructor = () => {
        console.log('lll');
    }

    let fc = new FunConstructor();  //报错
```
3. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。（即不绑定arguments，取而代之用rest参数...解决）

```
    function A(a){
        console.log(arguments);
    }
    A(1,2,3,4,5,8);  //  [1, 2, 3, 4, 5, 8, callee: ƒ, Symbol(Symbol.iterator): ƒ]


    let B = (b)=>{
        console.log(arguments);
    }
    B(2,92,32,32);   // Uncaught ReferenceError: arguments is not defined


    let C = (...c) => {
        console.log(c);
    }
    C(3,82,32,11323);  // [3, 82, 32, 11323]
```

4. 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。

5. 箭头函数通过 call()  或   apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。

```
    let obj2 = {
        a: 10,
        b: function(n) {
            let f = (n) => n + this.a;
            return f(n);
        },
        c: function(n) {
            let f = (n) => n + this.a;
            let m = {
                a: 20
            };
            return f.call(m,n);
        }
    };
    console.log(obj2.b(1));  // 11
    console.log(obj2.c(1)); // 11
```

6. 箭头函数没有原型属性

```
    var a = ()=>{
        return 1;
    }

    function b(){
        return 2;
    }

    console.log(a.prototype);  // undefined
    console.log(b.prototype);   // {constructor: ƒ}
```