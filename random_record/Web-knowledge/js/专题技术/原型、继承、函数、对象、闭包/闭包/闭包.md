## 闭包

闭包会引用包含函数的整个活动对象。
js从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（`不过，它会执行后续声明中的变量初始化`）
```
var diffIndustries=[];
var cateFinances={};
var diff0=[];
for(var i=0, len=diffIndustries.length;i<len;i++){
    diff0[i]= (function(){
                return diff.filter(function(item,index,array){
                    return ((item.first_industry).localeCompare(diffIndustries[i])==0)
        });
    })(i);  
 } //把数组中相同的元素依次取出来，再分别存储到数组中
for(var i=0, len=diffIndustries.length;i<len;i++){
          cateFinances[diffIndustries[i]]=diff0[i];
 }//把取出来的数组放入对象cateFinances中
 ```
通过闭包功能能实现循环，这样外面能取到函数里面的变量

### 碰到的问题，还没找到原因
  var time = 0;
  while(time<5){
     setTimeout(function(){
             payWall();
     }, 3000);
     time+=1;
  }
  for (var i = 0; i < 5; i++) {
    <!--使用此方法发现i值是是从1-5，但是每次循环都不会3秒后执行，是一下子执行5次payWall()-->
    // setTimeout((function(i){
    //     return function(){
    //         payWall();
    //         console.log(i);
    //     };
    // })(i), 3000);
    <!--使用此方法发现i值是一直等于5，但是每次循环都会3秒后执行-->
    setTimeout(function(){
            payWall();
            console.log(i);
    }, 3000);
    
  }
    var interval = setInterval(function(){
        payWall();
    },3000);
    setTimeout(function( ) {
        clearInterval(interval); 
    }, 15000);


## 使用闭包的注意点
    闭包存在内存泄漏，比如：如果闭包的作用域中保存着一个HTML元素，那么该元素无法被销毁。

1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。`解决方法是，在退出函数之前，将不使用的局部变量全部删除。`

2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便
改变父函数内部变量的值。

## 闭包实例：
function makeFunc() {
    var name = "Mozilla";
    function displayName() {
        alert(name);
    }
    return displayName;
}

var myFunc = makeFunc();
myFunc();

function makeAdder(x) {
  return function(y) {
    return x + y;
  };
}

var add5 = makeAdder(5);
var add10 = makeAdder(10);

console.log(add5(2));  // 7
console.log(add10(2)); // 12

##

## 概念理解
在**定义**某函数的词法作用域**以外**调用该函数时，该函数依然保留有对其定义时的词法作用域的引用。那么该函数可以叫做闭包。
**NOTE**：这里的**以外**有两种含义：
### 1. 空间上的以外。
Eg:模块模式。
```
  function CoolModule(x) {
    function doSomething() {
      ...
    }
    return {
      doSomething
    }
  }
  CooleModule(x).doSomething();  
```
### 2. 时间上的以外。
Eg:setTimeout中的。
```
  for (var i = 1; i <= 5; i++) {
      (function(j) {
        setTimeout(function timer() {
          console.log(j);
        }, j * 1000);
      })(i);
  }
```

#### 参考《你所不知道的JavaScript》上卷 Part1 Chapter5

### 13）思考下面的代码段：

	```
	for(var i=0;i<5;i++){
	    var btn=document.createElement('button');//document.createElement(<tag>)方法：创建一个属于指定标签类型的新HTMLElement对象
	    btn.appendChild(document.createTextNode('Button'+i));//document.createTextNode(<text>)方法：创建一个带有指定内容的新Text对象（即上述button元素上写的文字）
	    btn.addEventListener(//为元素添加事件监听器
	      'click',
	       function(){
	          console.log(i);
	        }
	    );
	    document.body.appendChild(btn);//document.A.appendChild(B)方法：将B元素添加为A的子元素
	}
	```
(以上方法查看《HTML5权威指南》P589)

a. 点击“Button4”后输出什么？如何使得输出和预期相同

b. 给出一个可以和预期相同的写法。

**答案：** 

a. 输出5，因为形成了闭包，循环结束后，i为5，所有按钮点击都是5

b. 
1. 我的方法：

	```
	for(var i=0;i<5;i++){
	    var btn=document.createElement('button');
	    btn.appendChild(document.createTextNode('Button'+i));
	    btn.addEventListener(
	      'click',
	       function(e){
	          for(var i=0;i<5;i++){
	            if (e.target.innerHTML=='Button'+i) {
	                console.log(i);
	            }
	          }
	        }
	    );
	    document.body.appendChild(btn);//document.A.appendChild(B)方法：将B元素添加为A的子元素
	}
	```
作者大神的方法：

[这10道javascript笔试题](http://www.cnblogs.com/zichi/p/4359786.html)你都会么 中的第 8 题。

参考可以得出其他方法：
2. 闭包

这是错误的：

	```
	for(var i=0;i<5;i++){
	    var btn=document.createElement('button');
	    btn.appendChild(document.createTextNode('Button'+i));
	    btn.addEventListener(
	      'click',
	       (function(i){
	          (function(){
	            console.log(i);
	          })();
	       })(i)
	    );
	    document.body.appendChild(btn);//document.A.appendChild(B)方法：将B元素添加为A的子元素
	}
	```
这也是错误的：
	
	```
	for(var i=0;i<5;i++){
	    var btn=document.createElement('button');
	    btn.appendChild(document.createTextNode('Button'+i));
	    btn.addEventListener(
	      'click',
	       (function(i){
	            console.log(i);
	       })(i)
	    );
	    document.body.appendChild(btn);//document.A.appendChild(B)方法：将B元素添加为A的子元素
	}
	```
这才是正确的闭包：

	```
	for(var i=0;i<5;i++){
	    var btn=document.createElement('button');
	    btn.appendChild(document.createTextNode('Button'+i));
	    (function(a){
	        btn.addEventListener(
	            'click',
	            function () {
	                console.log(a);
	            }
	        )
	    })(i);
	    document.body.appendChild(btn);//document.A.appendChild(B)方法：将B元素添加为A的子元素
	}
	```
**其实，闭包就是在要引用外部变量i的函数外面加上一个 用作块级作用域的匿名函数**
	
	```
	(function(i){
		//某某内部使用了i的函数
	})(i);
	```
### 13) 引申  [这10道javascript笔试题](http://www.cnblogs.com/zichi/p/4359786.html)你都会么 中的第 8 题。

 实现一段脚本，使得点击对应链接alert出相应的编号

1. DOM	污染法
通过给document元素对象添加了属性值，故污染了DOM

		```
		 var lis = document.links;// 属于DOM Document对象，非Dom Element对象,返回文档里具备href属性的a和area元素的对象。参见《HTML5权威指南》P545
		    for(var i = 0, length = lis.length; i < length; i++) {
		      lis[i].index = i;//此index为自己设置的任意变量值，可任意替换为myindex等等，也可使用固有的元素对象属性，如id等
		      lis[i].onclick = function( ) {
		        alert(this.index);//也可用function(e),后面this换为e.target
		      };
		
		    }
		```
该法自己的习惯写法为:

		```
		 var lis = document.getElementsByTagName("a");// 属于DOM Document对象，非Dom Element对象
		    for(var i = 0; i <lis.length; i++) {
		      lis[i].id = i;//把number型的i赋值给id后，直接转换为了string型，因为id都是string型的。
		      lis[i].onclick = function(e) {
		        alert(e.target.id);
		      };
		    }
		```

2. 使用闭包

		```
		var lis=document.links;
		
		for(var i=0,len=lis.length;i<len;i++){
		    (function(a){
		        lis[a].onclick=function(){
		            alert(a);
		        };
		    })(i);
		}
		```

3.我的惯用方法(事件循环索引法***自己命的名***)
```
var lis=document.links;

for(var i=0,len=lis.length;i<len;i++){
    lis[i].onclick=function(){
        for(var j=0;j<lis.length;j++){
            if (this==lis[j]) {
                alert(j);
            }
        }
    };
}
```
其实，上述j也可就写作i,因为内部循环参数是在局部函数中的，故循环完成后自动销毁，对外部i没有影响。

更多关于闭包[其实闭包并不高深莫测](http://web.jobbole.com/84456/)


### 实践总结2
这是对的：
```
const articleLists = Array.from(document.querySelectorAll('.article-list .article'));
  articleLists.forEach((elem, index) => {
    (function() {
       elem.addEventListener('click', function(){
        console.log(index);
        const labelForListArticle = `Article: ${index+1}`;
        ga('send', 'event', category, action, labelForListArticle);
        console.log('click ', labelForListArticle);
       })
    })(index);
  });
```

这是错的
```
const articleLists = Array.from(document.querySelectorAll('.article-list .article'));
  articleLists.forEach((elem, index) => {
    (function(i) {
       elem.addEventListener('click', function(){
        console.log(i);
        const labelForListArticle = `Article: ${i+1}`;
        ga('send', 'event', category, action, labelForListArticle);
        console.log('click ', labelForListArticle);
       })
    })(index);
  });
```

这也是错的
```
const articleLists = Array.from(document.querySelectorAll('.article-list .article'));
  articleLists.forEach((elem, index) => {
	 const labelForListArticle = `Article: ${index+1}`;
    (function(label) {
       elem.addEventListener('click', function(){
        console.log(index);
        ga('send', 'event', category, action, label);
        console.log('click ', label);
       })
    })(labelForListArticle);
  });
```

闭包是js的特性，我们经常会用来作为私有变量的保存处理，那么sizzle就很好的利用了这一特性，把选择器中每一个选择原子都变成了函数的处理方法，然后通过闭包保存着。再缓存在内存中去，这样有重复使用的时候就会首先调用缓存。