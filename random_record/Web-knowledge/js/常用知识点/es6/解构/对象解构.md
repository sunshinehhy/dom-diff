- 数组的元素是按次序排列的，变量的取值由它的位置决定；
- `对象的属性没有次序，变量必须与属性同名，才能取到正确的值。`
```
bar, foo是变量，会被赋值
let { bar, foo } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"

let { baz } = { foo: "aaa", bar: "bbb" };
baz // undefined   
变量必须与属性同名，才能取到正确的值
```

- 如果变量名与属性名不一致，必须写成下面这样。
- 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。
```
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"
真正被赋值的是变量baz，而不是模式foo
真正被赋值的是后者，而不是前者。

let obj = { first: 'hello', last: 'world' };
let { first: f, last: l } = obj;
f // 'hello'
l // 'world'
```

- 解构也可以用于嵌套结构的对象
```
p是模式，不是变量，因此不会被赋值
let { p: [x, { y }] } = obj; 

const node = {
  loc: {
    start: {
      line: 1,
      column: 5
    }
  }
};
loc作为变量。
let { loc, loc: { start }, loc: { start: { line }} } = node;
line // 1
loc  // Object {start: Object}
start // Object {line: 1, column: 5}
```

- 对象的解构也可以指定默认值
- 对象的属性值严格等于undefined
```
var {x = 3} = {x: undefined};
x // 3

var {x = 3} = {x: null};
x // null
```

- 如果解构模式是嵌套的对象，而且`子对象所在的父属性不存在，那么将会报错`
```
// 报错
let {foo: {bar}} = {baz: 'baz'};
```

- 将一个`已经声明的变量用于解构赋值，必须非常小心`
```
x已经声明

let x;
{x} = {x: 1};// SyntaxError: syntax error
({x} = {x: 1}); //正确

```

- `允许等号左边的模式之中，不放置任何变量名`
```
({} = [true, false]);
({} = 'abc');
({} = []);
语法是合法的，可以执行
```

- 由于`数组本质是特殊的对象`，因此`可以对数组进行对象属性的解构`
```
let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
```
```
const obj = { first: 'Jane', last: 'Doe' };
const {first: f, last: l} = obj;
    // f = 'Jane'; l = 'Doe'
注意： 必须确认obj中含有属性first,last,否则会报错
```