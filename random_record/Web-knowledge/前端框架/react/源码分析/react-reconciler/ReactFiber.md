Fiber是对需要完成或已经完成的组件的工作。每个组件可能不止一个。

这些第一个字段在概念上是实例的成员。它曾经被分割成一个单独的类型，并与其他光纤字段相交，但是在Flow修复它的交叉错误之前，我们已经将它们合并到一个单独的类型中。

在组件的所有版本之间共享一个实例。我们可以很容易地将其拆分为一个单独的对象，以避免复制到树的替代版本中。现在，我们将其放在单个对象上，以最小化在初始呈现期间创建的对象的数量。

标签标识纤维的类型。
这个子的唯一标识符。
与此纤维相关的函数/类/模块。
当前与这种纤维有关的状态。

/*概念的别名
parent: Instance ->，返回父节点，由于我们合并了光纤和实例，恰好与返回的fiber相同。

其余字段属于光纤

纤维在处理完这个后返回。
这是有效的父类，但可能有多个父类(两个)，所以这只是我们正在处理的事物的父类。
它在概念上与堆栈框架的返回地址相同。*/

单链表树结构。
最后用于附加此节点的ref。我将避免为prod添加所有者字段，并将其建模为函数。
input是处理该光纤的数据。Arguments. Props
状态更新和回调的队列
用于创建输出的状态

nextEffect 单链表快速路径到下一个有side-effect的纤维。

firstEffect lastEffect该子树中第一个和最后一个具有side-effect的光纤。当我们重用在该光纤中完成的工作时，这允许我们去重用链表中的一个部分。

expirationTime：表示将来完成这项工作的时间。这也用于快速确定子树是否没有挂起的更改。
alternate：这是一种混合的纤维。每一个被更新的纤维最终都会有一对。如果需要的话，我们可以清理成对以节省内存。

actualDuration?: 当前更新渲染此纤维及其后代的时间。这告诉我们树如何利用sCU进行记忆。此字段仅在启用enableProfilerTimer标志时设置。

 actualStartTime?: 如果光纤目前在“呈现”阶段处于活动状态，这将标志着工作开始的时间。此字段仅在启用enableProfilerTimer标志时设置。

selfBaseTime?: 该纤维最近渲染时间的持续时间。当我们出于记忆目的进行紧急救援时，这个值不会更新。此字段仅在启用enableProfilerTimer标志时设置。

treeBaseTime?:所有这些纤维的根的基次的和。这个值在“完成”阶段出现。此字段仅在启用enableProfilerTimer标志时设置。

function FiberNode(）

const createFiber = function(）{
    这是一个构造函数，而不是POJO构造函数，请确保我们做以下工作:
    1)任何人都不应该在上面添加任何实例方法。实例方法在优化时可能更难以预测，而且它们几乎从未在静态编译器中正确地内联。
    2)没有人应该依赖于“instanceof Fiber”来进行类型测试。我们应该知道什么时候它是纤维。
    3)我们可能想尝试使用数字键，因为在非jit环境中，数字键更容易优化。
    4)如果更快的话，我们可以很容易地从构造函数转换为createFiber对象。
    5)将其移植到C struct并保持C实现兼容应该很容易。
}
export function createWorkInProgress(）{
    这是用来创建一个替代纤维来工作。
    我们使用`双重缓冲池技术`，因为我们知道我们只需要最多两个版本的树。我们共享“其他”未使用的节点，我们可以自由地重用它们。这是延迟创建的，以避免为从未更新的东西分配额外的对象。它还允许我们在需要时回收额外的内存。
    我们故意重置，而不是复制，实际持续时间和实际开始时间。这可以防止时间在新的提交中不断积累。这有为不同优先级呈现重新设置值的缺点，但对屈服(通常情况)有用，并且应该支持恢复。
    在出现DevTools时，总是收集配置文件时间。这使DevTools能够在任何点开始捕获时间，而树中的某些节点没有空的基本时间。
}